|**
    kissAssist.mac Original Author: Maskoi.
    KissAssist v12.002 Maintained for RedGuides by Ctaylor22 9/24/2022
    Thanks to all who have Contributied.
    PetTank, PullerPetTank & HunterPetTank roles developed by TreeHuginDruid
    KISS Assist - A simple multi class macro
    Required plugins: MQ2Exchange, MQ2MoveUtils, MQ2Posse, MQ2Rez, & MQ2Twist (Bards), Extended Target Window and ninjadvloot.inc file.
    Optional plugins: MQ2Cast, MQ2Melee, MQ2Gmail, MQ2DanNet, MQ2eqbc, MQ2Nav, MQ2AdvPath, MQ2DPSAdv
    Usage - /mac kissassist assist TankName 95
    or target Main Tank and /mac kissassist assist
    For detailed Instructions go to: https://www.redguides.com/wiki/KissAssist
    This macro was written exclusively for subscribers of Redguides.com
  -------------------------------------------------------------------------------------
 **|
#warning
#turbo 120
#include ninjadvloot.inc
|#DEFINE /squelch " "
#DEFINE BuffsNotAnItem ${Select[TRUE,${Bool[${Me.AltAbility[${SpellToCast}]}]},${Bool[${Me.CombatAbility[${SpellToCast}]}]},${Bool[${Me.Skill[${SpellToCast}]}]},${Bool[${Me.Book[${SpellToCast}]}]}]}
#DEFINE DEBUGN "/if (${Debug}) /echo \atDEBUG-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGBUFF "/if (${DebugBuffs}) /echo \awBUFFS-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGCAST "/if (${DebugCast}) /echo \atCAST-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGCOMBAT "/if (${DebugCombat}) /echo \arCOMBAT-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGHEALS "/if (${DebugHeals}) /echo \amHEALS-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGMOVE "/if (${DebugMove}) /echo \ayMOVE-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGMEZ "/if (${DebugMez}) /echo \ayMEZ-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGPET "/if (${DebugPet}) /echo \aoPET-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGPULL "/if (${DebugPull}) /echo \ayPULL-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
#DEFINE DEBUGCHAINPULL "/if (${DebugChainP}) /echo \ayPULL-${KissRevision} \agL:${Macro.CurLine} T:${Macro.RunTime} \aw"
|---------------------------------------------------------------------------------------------------------------
#DEFINE DEBUGTIMES "/if (${DebugTime}) /echo \atDEBUGTIME START  \agL:${Macro.CurLine} TS:${Macro.RunTime} TT:${DebugTicker} ${Macro.CurSub} \aw"
#DEFINE DEBUGTIMEM "/if (${DebugTime}) /echo \atDEBUGTIME MARKER \agL:${Macro.CurLine} TS:${Macro.RunTime} TT:${DebugTicker} ${Macro.CurSub}:\aw"
#DEFINE DEBUGTIMEE "/if (${DebugTime}) /echo \atDEBUGTIME END    \agL:${Macro.CurLine} TS:${Macro.RunTime} TT:${DebugTicker} ${Macro.CurSub} \aw"
|---------------------------------------------------------------------------------------------------------------
#DEFINE BEGFORITEMS "modrod,modrodp,modrods,icenuke"
#DEFINE BEGFORAEITEMS "modrod,modrodp,modrods,icenuke"
#DEFINE BEGFORBUFFS "Symbol,Aego,Focus,Regen,Haste,Skin,Clarity,Brells,Growth,Speed,Altbuff1,Altbuff2"
|#DEFINE IGNOREGROUPV1LIST "5417,0"
#DEFINE PULLAGGROCHECK "${SpawnCount[xtarhater range ${PullRange} noalert 5]>0}"
#DEFINE DOPARSE "/varset Parse0 !${Parse0}"
#DEFINE DONOTHING "/varset Parse0 !${Parse0}"
#DEFINE XTCHECK "${Me.XTarget[1].ID},${Me.XTarget[2].ID},${Me.XTarget[3].ID},${Me.XTarget[4].ID},${Me.XTarget[5].ID},${Me.XTarget[6].ID},${Me.XTarget[7].ID},${Me.XTarget[8].ID},${Me.XTarget[9].ID},${Me.XTarget[10].ID},${Me.XTarget[11].ID},${Me.XTarget[12].ID},${Me.XTarget[13].ID},${Me.XTarget[14].ID},${Me.XTarget[15].ID},${Me.XTarget[16].ID},${Me.XTarget[17].ID},${Me.XTarget[18].ID},${Me.XTarget[19].ID},${Me.XTarget[20].ID}"
|---------------------------------------------------------------------------------------------------------------
| Defines to fix bracket checks in editor
#DEFINE TARGETCHECK {Target.
#DEFINE LEFTPAREN (
| ------------------------------casting events ----------------------------------------
#Event CAST_BEGIN                  "You begin casting #1#"
#Event CAST_BEGIN                  "You begin singing #1#"
#Event CAST_BEGIN                  "Your #1# begins to glow."
#Event CAST_COLLAPSE               "Your gate is too unstable, and collapses#*#"
#Event CAST_CANNOTSEE              "You cannot see your target#*#"
#Event CAST_COMPONENTS             "You are missing some required components#*#"
#Event CAST_COMPONENTS             "Your ability to use this item has been disabled because you do not have at least a gold membership#*#"
#Event CAST_DISTRACTED             "You need to play a#*#instrument for this song#*#"
#Event CAST_DISTRACTED             "You are too distracted to cast a spell now#*#"
#Event CAST_DISTRACTED             "You can't cast spells while invulnerable#*#"
#Event CAST_DISTRACTED             "You *CANNOT* cast spells, you have been silenced#*#"
#Event CAST_FAILED                 "Your ability failed.#*#"
#Event CAST_FDFAIL                 "#1# has fallen to the ground.#*#"
#Event CAST_FIZZLE                 "Your spell fizzles#*#"
#Event CAST_FIZZLE                 "Your #*#spell fizzles#*#"
#Event CAST_FIZZLE                 "You miss a note, bringing your song to a close#*#"
#Event CAST_IMMUNE                 "Your target has no mana to affect#*#"
#Event CAST_IMMUNE                 "Your target is immune to changes in its attack speed#*#"
#Event CAST_IMMUNE                 "Your target is immune to changes in its run speed#*#"
#Event CAST_IMMUNE                 "Your target is immune to snare spells#*#"
#Event CAST_IMMUNE                 "Your target is immune to the stun portion of this effect#*#"
#Event CAST_IMMUNE                 "Your target cannot be mesmerized#*#"
#Event CAST_IMMUNE                 "Your target looks unaffected#*#"
#Event CAST_INTERRUPTED            "Your spell is interrupted#*#"
#Event CAST_INTERRUPTED            "Your casting has been interrupted#*#"
#Event CAST_INTERRUPTED            "Your #*# spell is interrupted."
#Event CAST_NOMOUNT                "You can only summon a mount on dry land#*#"
#Event CAST_NOMOUNT                "You need to be in a more open area to summon a mount#*#"
#Event CAST_NOMOUNT                "You can not summon a mount here#*#"
#Event CAST_NOMOUNT                "You must have both the Horse Models and your current Luclin Character Model enabled to summon a mount#*#"
#Event CAST_NOMOUNT                "You can not summon a mount in this form#*#"
#Event CAST_NOTARGET               "You must first select a target for this spell#*#"
#Event CAST_NOTARGET               "This spell only works on#*#"
#Event CAST_NOTARGET               "You must first target a group member#*#"
#Event CAST_NOTREADY               "Spell recast time not yet met#*#"
#Event CAST_OUTOFMANA              "Insufficient Mana to cast this spell#*#"
#Event CAST_OUTOFRANGE             "Your target is out of range, get closer#*#"
#Event CAST_OUTDOORS               "This spell does not work here#*#"
#Event CAST_OUTDOORS               "You can only cast this spell in the outdoors#*#"
#Event CAST_RECOVER                "You haven't recovered yet#*#"
#Event CAST_RECOVER                "Spell recovery time not yet met#*#"
#Event CAST_RESISTED               "Your target resisted the #1# spell#*#"
#Event CAST_RESISTED               "#*# resisted your #1#!"
#Event CAST_RESISTEDYOU            "You resist the #1# spell#*#"
#Event CAST_RESISTEDYOU            "You resist #*#"
#Event CAST_STANDING               "You must be standing to cast a spell#*#"
#Event CAST_STUNNED                "You can't cast spells while stunned#*#"
#Event CAST_STUNNED                "You are stunned#*#"
#Event CAST_SUCCESS                "You are already on a mount#*#"
#Event CAST_TAKEHOLD               "Your spell did not take hold#*#"
#Event CAST_TAKEHOLD               "Your #*# spell did not take hold. (Blocked by#*#"
#Event CAST_TAKEHOLD               "Your spell would not have taken hold#*#"
#Event CAST_TAKEHOLD               "Your spell is too powerfull for your intended target#*#"
#Event CAST_TAKEHOLD               "This pet may not be made invisible#*#"
|**************************************** GENERAL EVENTS ***********************************************|
#Event Camping           "#*#seconds to prepare your camp."
#Event EQBCIRC           "<#1#> #2#"
#Event FSEQBC            "#1# tells the fellowship, #2#"
#Event GUEQBC            "#1# tells the guild, #2#"
#Event GainSomething     "#*#You have gained|#1#|"
#Event GotHit            "#1# bashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# bites YOU for #*# points of damage.#*#"
#Event GotHit            "#1# crushes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# gores YOU for #*# points of damage.#*#"
#Event GotHit            "#1# hits YOU for #*# points of damage.#*#"
#Event GotHit            "#1# kicks YOU for #*# points of damage.#*#"
#Event GotHit            "#1# mauls YOU for #*# points of damage.#*#"
#Event GotHit            "#1# pierces YOU for #*# points of damage.#*#"
#Event GotHit            "#1# punches YOU for #*# points of damage.#*#"
#Event GotHit            "#1# rampages YOU for #*# points of damage.#*#"
#Event GotHit            "#1# smashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# slashes YOU for #*# points of damage.#*#"
#Event GotHit            "#1# tries to #*# YOU, but #*#"
#Event Invised           "You Vanish #*#"
#Event Joined            "#1# has joined the group."
#Event KABegCheck        "#*#KABeg for #1# #2# #3#"
#Event KTDismount        "[MQ2] KTDismount#*#"
#Event KTDoorClick       "[MQ2] KTDoorClick #1#"
#Event KTDoorClick       "[MQ2] KTDoorClick#*#"
#Event KTHail            "[MQ2] KTHail #1#"
#Event KTInvite          "[MQ2] KTInvite #1#"
#Event KTSay             "[MQ2] KTSay #1# #2#"
#Event KTTarget          "[MQ2] KTTarget #1#"
#Event LeftGroup         "#1# has left the group."
#Event MezBroke          "#1# has been awakened by #2#."
#Event Missing           "#*#You are missing some required components.#*#"
#Event Missing           "#*#You are missing#*#"
|#Event PTaunt            "#*#Taunting attackers as normal, Master.#*#"
#Event PetSusStateAdd1   "#*# tells you, 'By your command, master.#*#"
#Event PetSusStateAdd2   "#*#You cannot have more than one pet at a time.#*#"
#Event PetSusStateSub    "#*# tells you, 'I live again...'#*#"
#Event PetToysPlease     "#*#PetToysPlease #1#"
#Event TaskUpdate        "Your task |#1#| has been updated#*#"
#Event Timer             Timer1
#Event TooSteep          "The ground here is too steep to camp"
#Event WornOff           "Your #1# spell has worn off of #2#."
#Event YouGotTell        "#1# tells you, #2#"
#Event Zoned             "LOADING, PLEASE WAIT#*#"
#Event Zoned             "You have entered#*#"
#Event AskForBuffs       "#1# tells you,#*#Buffs Please!#*#"
#Event AskForBuffs       "#1# says,#*#Buffs Please!#*#"
|**************************************** COMBAT EVENTS ***********************************************|
#Event AttackCalled      "<#1#>#*#TANKING-> #*# <- ID:#2#"
#Event AttackCalled     "[ #1# (#*#) ]#*#TANKING-> #*# <- ID:#2#"
#Event CantHit           "You can't hit them from here."
#Event CantSee           "You cannot see your target."
#Event GoMOff            "The gift of magic fades."
#Event GoMOff            "Your#*#gift of#*#mana fades."
#Event GoMOn             "#*#granted#*#gift of#*#mana#*#"
#Event GoMOn             "You feel strengthened by a gift of magic."
#Event GoMOn             "You feel strengthened by magic."
#Event ImDead            "#*#Returning to Bind Location#*#"
#Event ImDead            "You died."
#Event ImDead            "You have been slain by#*#"
#Event TooClose          "Your target is too close to use a ranged weapon!"
|#Event TooFar            "Your target is too far away, get closer!"
|#Event TooFar            "Your target is out of range, get closer!"
#Event TooFar            "Your target is #*#, get closer!"
#Event MLogOff           "#*#KissAssist Debug Off Marker!"
| -------------------------------------------------------------------------------------
| New Binds to replace old Events
| -------------------------------------------------------------------------------------
#bind AddAFriend     /addfriend
#bind AddMezImmune   /addimmune
#bind AddToIgnore    /addignore
#bind AddToPull      /addpull
#bind BackOff        /backoff
#bind BuffGroup      /buffgroup
#bind Burn           /burn
#bind Campfire       /campfire
#bind ChangeVarInt   /changevarint
#bind ChaseMe        /chaseme
#bind Debug          /debug
#bind IniWrite       /iniwrite
#bind KissCast       /kisscast
#bind KissCheck      /kisscheck
#bind KissE          /kissedit
#bind MakeCampHere   /makecamphere
#bind MemMySpells    /memmyspells
#bind MyCmds         /mycmd
#bind Parse          /parse
#bind SetPullArc     /SetPullArc
#bind Settings       /kasettings
#bind StayHere       /stayhere
#bind Switch         /switchnow
#bind SwitchMA       /switchma
#bind ToggleVariable /togglevariable
#bind TooBuffList    /tbmanager
#bind TrackMeDown    /trackmedown
#bind WriteMySpells  /writespells
#bind ZoneInfo       /zoneinfo
| -------------------------------------------------------------------------------------
| Sub Main
| -------------------------------------------------------------------------------------
Sub Main
    /doevents flush
    | Need to check for plugin MQ2Bucles and unload it. Do this ASAP so we can use /while commands from the start
    /if (${Bool[${Plugin[MQ2Bucles]}]}) {
        /squelch /plugin MQ2Bucles unload noauto
        /echo MQ2Bucles detected! This macro doesn't like it! Unloading ...
    }
| -------------------------------------------------------------------------------------
| Define needed outer variables to start pre processes
| -------------------------------------------------------------------------------------
    /call DeclareOuters pre
| -------------------------------------------------------------------------------------
| Get the zone name and fix it.
| Add an _I to the end for Instanced zones.
| -------------------------------------------------------------------------------------
    /if (${ZoneName.Find[,]} || ${ZoneName.Find[']}) {
        /echo ${ZoneName} has a comma or apostrophe in the name, setting Zone Short Name ...
        /varset ZoneName ${Zone.ShortName}
    }
    /if (${Me.InInstance}) {
        /varset ZoneName ${ZoneName}_I
    } else /if (${ZoneName.Find[_]}) {
        /varset ZoneName ${ZoneName.Left[${Math.Calc[${ZoneName.Find[_]}-1]}]}
    }
| -------------------------------------------------------------------------------------
| Process any Command Line Paramaters
| -------------------------------------------------------------------------------------
    /declare pi                     int         local       0
    /declare pj                     int         local       0
    /declare NumParams              int         local       0
    /if (${Macro.Params}) {
        |/echo There is ${Macro.Params} command line parameter(s)
        /varset NumParams ${Math.Calc[${Macro.Params}]}
        /varset pj ${Math.Calc[${NumParams}-1]}
        /for pi 0 to ${pj}
            /if (${Defined[Param${pi}]}) {
                |/echo P${pi}: ${Param${pi}}
                /declare PParam${pi} string outer ${Param${pi}}
                /if (${PParam${pi}.Equal[debug]}) {
                    /debug on log
                } else /if (${PParam${pi}.Equal[debugall]}) {
                    /debug all on log
                }
            }
        /next pi
        /call PParse 0 ${NumParams}
    }
    /deletevar pj
| -------------------------------------------------------------------------------------
| Lets open the KissAssist.ini file
| -------------------------------------------------------------------------------------
    | if Kiss finds a Kissassist_ServerName_ToonName.ini file it will use that one.
    /if (!${PIniSet}) {
        /if (${Ini[${MacroName}_${EverQuest.Server}_${Me.CleanName}.ini,General,KissAssistVer].Length}) {
            /varset IniFileName ${MacroName}_${EverQuest.Server}_${Me.CleanName}.ini
            /echo Server Name ini file detected using ${IniFileName}
        } else {
            /varset IniFileName ${MacroName}_${Me.CleanName}.ini
        }
    }
    /varset KissAssistVer ${Ini[${IniFileName},General,KissAssistVer]}
    DEBUGN ${IniFileName} ${KissAssistVer}
    /if (!${Ini[${IniFileName},General,KissAssistVer].Length}) /ini "${IniFileName}" "General" "KissAssistVer" "0.0"
| -------------------------------------------------------------------------------------
| Load Aliases
| -------------------------------------------------------------------------------------
    /call LoadAliases
| -------------------------------------------------------------------------------------
| Declare the Main Outer variables needed before loading ini entries
| -------------------------------------------------------------------------------------
    /call DeclareOuters main
| -------------------------------------------------------------------------------------
| If there were command line paramaters Lets Parse them to the p_vars.
| -------------------------------------------------------------------------------------
    /if (${NumParams}) /call PParse 1 ${NumParams}
| -------------------------------------------------------------------------------------
| Load Ini file settings
| -------------------------------------------------------------------------------------
    /call Bind_Settings load all 0
| -------------------------------------------------------------------------------------
| Declare the Main Outer variables that required the ini file loaded first.
| -------------------------------------------------------------------------------------
    /call DeclareOuters post
| -------------------------------------------------------------------------------------
| Declare Any Global variables. Used for PetToys Given.
| -------------------------------------------------------------------------------------
    /call DeclareOuters global
| -------------------------------------------------------------------------------------
|   ******** Clean old INI entries and move others to proper locations **|
| -------------------------------------------------------------------------------------
    /call IniCleanup
| -------------------------------------------------------------------------------------
| Lets finish setting everything up bassed off loaded information.
| -------------------------------------------------------------------------------------
    /call InitData
| -------------------------------------------------------------------------------------
| Check if required plugins are loaded and settings are set.
| -------------------------------------------------------------------------------------
    /call InitPlugins
| -------------------------------------------------------------------------------------
| Add in AdvancedLoot variables if needed
| -------------------------------------------------------------------------------------
    /if (${SubDefined[SetupAdvLootVars]}) {
        /call SetupAdvLootVars
        /if (${LootOn} && ${Defined[NALStatus]}) {
            /varset NALStatus 1
        }
    }
| -------------------------------------------------------------------------------------
| Parse DPS when Parse tag was used from command line.
| Otherwise Assign Main Tank from command line parameter or targeted player, merc or pet
| -------------------------------------------------------------------------------------
    /if (${ParseDPSTimer}>=1) {
        /target id ${Me.ID}
        /delay 10 ${Target.ID}==${Me.ID}
        /if (${DPSOn}) /varset DPSOn 2
        /if (${Select[${Me.Class.ShortName},mag,nec,bst]}) {
            /varset Role PetTank
        } else {
            /varset Role Tank
        }
        /call AssignMainAssist 0
        /call CheckRoles 1
        /call CheckBuffs ${ForceBuffs}
        /varset ForceBuffs 0
        /call Bind_Parse ${ParseDPSTimer}
        /endmacro
    }
| -------------------------------------------------------------------------------------
| Lets finish setting things up and start the main process loop
| -------------------------------------------------------------------------------------
    /call AssignMainAssist 1
    /call CheckRoles 1
    /varset WhoToChase ${MainAssist}
    /varset MyOriginalRole ${Role}
    /while (1) {
        /varset EventFlag 0
        /doevents
        /if (!${EventFlag}) /break
    }
    /call StartupCredits
    /call StartupMisc
    /call StartupCommands
    /call WinTitle
| -------------------------------------------------------------------------------------
| Main Loop
| -------------------------------------------------------------------------------------
    /while (1) {
        /while (1) {
            /varset EventFlag 0
            /doevents
            /if (!${EventFlag}) /break
        }
        /if (${ChainPull}!=2) {
            /if (!${IAmABard} && ${Me.Casting.ID} && ${CheckStuckGem}) /call CheckStuckGems
            /if (${ClickBacktoCamp}) /call CampfireBack
            /if (${CorpseRecoveryOn}==1) /call RecoverCorpses
            /if (${MiscGemRemem} && (${ReMemCast} || ${ReMemCastLW})) {
                /varset DontMoveMe 1
                /call CastReMem "${ReMemMiscSpell}" 1 mainloop
                /varset DontMoveMe 0
            }
            /if (${AFKToolsOn}) /call AFKTools
            /if (${DPSOn} || ${MeleeOn}) /call CheckForCombat 0 MainLoop1 0
            /if (${AEOn}) /call AECheck ${AEDisplayMobInfo}
            /if (${MezOn}) {
                /varset GoMByPass 1
                /call DoMezStuff MainLoop
                /varset GoMByPass 0
            }
            /call WriteDebuffs
            /if (${CuresOn}) /call CheckCures MainLoop
            /if (${HealsOn}) /call CheckHealth MainLoop
            /if (${Me.CombatState.NotEqual[COMBAT]} && ${ReturnToCamp}) /call DoWeMove 0 mainloop
            /if (${ChaseAssist}) /call DoWeChase
            /if (${AutoRezOn}) /call RezCheck all
            /if (${CampfireOn} && ${Me.CombatState.NotEqual[COMBAT]}) /call Campfire
            /if (${Select[${Me},${Group.Leader}]}==1 && !${LooterAssigned}) /call AssignLooter
            /call DoMiscStuff
            /call CanIDoStuff
            /if (${MercOn}) /call MercsDoWhat
            /call CastMana MainLoop
            /if (${PetOn}) /call DoPetStuff
            /if (${PetOn}) /call CheckPetBuffs
            /if (${PetToysOn} && ${KAPetBegActive}) /call CheckBegforPetBuffs
            /if (${Me.CombatState.NotEqual[COMBAT]} && !${DanNetOn}) {
                /call WriteBuffs
                /if (${MercOn}) /call WriteBuffsMerc
                /call WriteBuffsPet
            }
            /if (${BuffsOn}) {
                /call CheckBuffs ${ForceBuffs}
                /varset ForceBuffs 0
            }
            /if (${BuffsOn} && ${KABegActive} ) /call CheckBegforBuffs
            /if (${IAmABard}) /call DoBardStuff
            /if (${Me.CombatState.NotEqual[COMBAT]}) {
                /if (${MedOn}) /call DoWeMed 0 0 "${MedStat}" ${MedStop}
                /if (${GroupWatchOn}) /call GroupWatch
            }
        } else {
            /if (${AFKToolsOn}) /call AFKTools
        }
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
            /if (${If[${PullHoldCond},0,1]} && !${DragCorpse}) {
                /if (${Select[${PullWith},Melee,Pet]} || ${Select[TRUE,${Me.SpellReady[${PullWith}]},${Me.AltAbilityReady[${PullWith}]},${Me.CombatAbilityReady[${PullWith}]},${Me.ItemReady[${PullWith}]},${If[${PullWith.Equal[Ranged]} && ${Me.RangedReady},TRUE,FALSE]}]}) {
                    | Try and find mob and NOT force using Camp Location
                    /if (!${PullMob}) /call FindMobToPull 1 1 0
                    | If I am in Hunter mode and I didn't find a mob, then lets try using Camp Location.
                    /if (!${PullMob} && ${Select[${Role},hunter,hunterpettank]}) /call FindMobToPull 1 1 1
                    /call PullCheck
                    /varset PullMob 0
                    /if (${PullOnReturn} && ${Macro.Return.Equal[oor]}) /call FindMobOnReturn
                    /if (${DragCorpse}) /continue
                } else {
                    /if (!${SpamTimer1}) {
                        /echo Holding Pulls. PullWith ${PullWith} is not ready.
                        /varset SpamTimer1 50
                    }
                }
            } else {
                /if (!${SpamTimer1}) {
                    /if (!${DragCorpse}) {
                        /echo Holding Pulls Due to Pull Hold Condition.
                    } else {
                        /echo Holding Pulls Due to Dragging Corpse Back to Camp.
                        /if (!${SpawnCount[pccorpse ${Me} radius 89]}) {
                            /call PullReset
                            /continue
                        }
                    }
                    /varset SpamTimer1 50
                }
            }
        }
        /if (${DPSOn} || ${MeleeOn}) {
            /call CheckForCombat 0 MainLoop2 200
        } else {
            /call CheckForCombat 1 MainLoop3 0
        }
        /if (${LootOn}) /call LootStuff
        /if (${DebugHeals}) /delay 5
        /delay 1
        |End of While loop
    }
    | From here down executed when /endmacro is issued or macro crashes due to error.
:OnExit
    /if (!${MacroQuest.LastCommand.Find[/end]}) {
        /ini "${IniFileName}" "KissError"  "LastCMD:" "${MacroQuest.LastCommand}"
        /ini "${IniFileName}" "KissError"  "ErrorDateTime:" "${Time.Date} ${Time.Time24}"
        /ini "${IniFileName}" "KissError"  "ErrorMsg:" "${MacroQuest.Error}"
        /ini "${IniFileName}" "KissError"  "DataError:" "${MacroQuest.MQ2DataError}"
        /ini "${IniFileName}" "KissError"  "SyntaxError:" "${MacroQuest.SyntaxError}"
        /ini "${IniFileName}" "KissError"  "RunningTime:" "${MacroQuest.Running}"
        /ini "${IniFileName}" "KissError"  "BuildDate:" "${MacroQuest.BuildDate}"
        /ini "${IniFileName}" "KissError"  "CurrentUI:" "${EverQuest.CurrentUI}"
    }
    /if (${MQ2CastReload}) /plugin mq2cast
    /if (${MQ2MeleeReload}) /plugin mq2melee
    /if (${XTSlot}) {
        /xtarget set ${XTSlot} autohater
        /ini "${IniFileName}" "General" "XTSlot" "0"
    }
    /if (${Me.Pet.ID} && ${Me.Pet.Stance.NotEqual[follow]}) /pet follow
    /endmacro
/return
| -------------------------------------------------------------------------------------
| SUB: CheckForCombat Used to help with controlling combat
| -------------------------------------------------------------------------------------
    Sub CheckForCombat(int SkipCombat, string FromWhere, int WaitTime)
        /if (${ChaseAssist} && ${Me.Moving} && (!${IAmMA} || ${WhoToChase.NotEqual[${Me}]})) /return
        DEBUGCOMBAT CheckForCombat Enter SkipCombat: ${SkipCombat} ChainPull: ${ChainPull} Role: ${Role} ${FromWhere}
        /while (1) {
            /if (${SkipCombat}==0) {
                /if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0)) /varset IAmDead 0
                /call MobRadar los ${MeleeDistance} CheckForCombat
                /if (${ChaseAssist}) /call DoWeChase
                /if (${DebugCombat}) /delay 5
                /if ((${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Hovering} || (${IAmDead} && !${AggroTargetID}) || (!${MobCount} && !${AggroTargetID}) || (!${DPSOn} && !${MeleeOn})) /return
                DEBUGCOMBAT CheckForCombat: Assist/Combat Begin ${FromWhere}
                /if (${IAmABard} && ${MeleeTwistOn}==2 && !${DPSTwisting}) /call DoBardStuff
                /varset EngageWaitTimer ${WaitTime}
                /if (!${IAmMA}) {
                    |/varset EngageWaitTimer 200
                    /while (1) {
                        | If I am not off tank or the MainAssist is alive then just call assist.
                        /if (${Role.NotEqual[offtank]} || ${Spawn[=${MainAssist}].ID}) {
                            /call Assist
                            | if MA is down and I am offtank make me MA.
                            /if (${Macro.Return.Equal[switch]}) {
                                /switchma ${Me} tank 0
                                /break
                            }
                        } else {
                            | I am Off Tank and MainAssist is dead.
                            /switchma ${Me} tank 0
                            /break
                        }
                        /if (${HealsOn} && ${AggroTargetID}) /call CheckHealth CheckForCombat1
                        /if (${MyTargetID} || ${Role.NotEqual[assist]} || !${EngageWaitTimer} || !${AggroTargetID}) /break
                    }
                    /if (${LOSBeforeCombat} && ${MyTargetID} && ${AggroTargetID} && !${Spawn[${MyTargetID}].LineOfSight}) /call GetCombatPosition 0
                } else {
                    |I am MainAssist
                    |Need to call WaitForMob from here and remove it from the Pull routine.
                    /if (!${Select[${Role},pullertank,pullerpettank,hunter,hunterpettank]}) {
                        /if (${AggroTargetID}) {
                            /while (1) {
                                /if (!${AggroTargetID} || ${Spawn[${AggroTargetID}].Type.Equal[Corpse]}) /break
                                /if (${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]}>${MeleeDistance}) {
                                    /varset MobCount ${SpawnCount[xtarhater radius ${MeleeDistance} zradius ${MaxZRange}]}
                                } else {
                                    /varset MobCount ${SpawnCount[xtarhater loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange}]}
                                }
                                /if (!${MobCount} && ${EngageWaitTimer}) /continue
                                /break
                            }
                        }
                    }
                    /call GetCombatTarget
                }
                /call Combat
                | Check if you FD'd to loose aggro and never stood back up.
                /if (${Me.Feigning} || ${Me.Invis}) /call FeignAggroCheck
                DEBUGCOMBAT  CheckForCombat: Assist/Combat End ${FromWhere}
                /if (${ChainPull}==2) /return
            }
            /if (${MezOn}) {
                /call MezCheck CheckForCombat
            }
            | Check to see if you are a healer and DPS is off, or DPS is on but the mob is not in LOS
            /while (${SkipCombat}==1 || (${DPSOn} && ${HealsOn} && ${MyTargetID} && ${Spawn[${MyTargetID}].LineOfSight}==FALSE)) {
                DEBUGCOMBAT CheckForCombat ${SkipCombat} ${Spawn[${MyTargetID}].LineOfSight} ${Spawn[${MyTargetID}].ID} ${MyTargetID}
                /if (${IAmABard} && ${MeleeTwistOn}==2 && !${DPSTwisting}) /call DoBardStuff
                /while (1) {
                    /varset EventFlag 0
                    /doevents
                    /if (!${EventFlag}) /break
                }
                /if (${AggroTargetID} || ${CalledTargetID}) {
                    /call CombatTargetCheck ${If[${SkipCombat},0,1]}
                    /if (!${AggroTargetID}) /continue
                    /if (${AggroOn}) {
                        /call AggroCheck
                        | Check if you FD'd to loose aggro and never stood back up.
                        /if (${Me.Feigning} || ${Me.Invis}) /call FeignAggroCheck
                    }
                    /if (!${CombatStart} && ${BeforeArray[1].NotEqual[null]}) {
                        /call BeforeAttack ${MyTargetID} 1
                        /varset CombatStart 1
                    }
                    /if (${CuresOn}) {
                        /call CheckCures CheckForCombat
                    } else /if (${HealsOn}) {
                        /call CheckHealth CheckForCombat2
                    }
                    /if (${AutoRezOn}) /call RezCheck group
                    /if (!${NamedCheck} && (${BurnAllNamed} || ${GMailEvents.Find[named]})) /call NamedWatch ${SkipCombat}
                    /call CastMana CheckForCombat
                    /call WriteDebuffs
                    /if (${MyTargetID} && (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID})) /call CombatReset 0 CheckForCombat0
                    /if (${WhoToChase.NotEqual[${Me}]} && ${ChaseAssist}) /call DoWeChase
                } else {
                    /if (${Role.NotEqual[manual]} && ${CombatStart}) /call CombatReset 0 CheckForCombat1
                    /return
                }
            }
            /call CheckForAdds CheckForCombat
            /if (${Select[${Role},tank,pullertank]}) {
                | If tank is assisting puller and in chase mode
                /if (${WhoToChase.NotEqual[${Me}]} && ${ChaseAssist}) /call DoWeChase
                /if (${ReturnToCamp} && ((!${MobCount} && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]}>15) || (${MobCount}==1 && ${AggroTargetID} && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]}>75))) /call DoWeMove 1 checkforcombat
                /if (${MobCount} && ${AggroTargetID}) /continue
                /if (${BuffsOn}) {
                    /for GlobalIndex 1 to ${BuffsSize}
                        /if (${Buffs[${GlobalIndex}].Arg[2,|].NotEqual[end]}) /continue
                        /if (${Me.PctEndurance}<=${Buffs[${GlobalIndex}].Arg[3,|]} && (${Me.CombatAbilityReady[${Buffs[${GlobalIndex}].Arg[1,|]}]} || ${Me.AltAbilityReady[${Buffs[${GlobalIndex}].Arg[1,|]}]})) /call CheckEndurance "${Buffs[${GlobalIndex}].Arg[1,|]}" ${Buffs[${GlobalIndex}].Arg[3,|]} ${Buffs[${GlobalIndex}].Arg[4,|]}
                    /next GlobalIndex
                }
                DEBUGCOMBAT CheckForCombat MobCount: ${MobCount} AggroTargetID: ${AggroTargetID} ChainPull: ${ChainPull} ${SkipCombat}
                /if (${TankTimer}) /continue
            } else /if (${Role.NotEqual[manual]} ) {
                /if (${MyTargetID} && (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID})) /call CombatReset 0 CheckForCombat2
            }
            /call MobRadar los ${MeleeDistance} CheckForCombat
            DEBUGCOMBAT CheckForCombat MobCount: ${MobCount} AggroTargetID: ${AggroTargetID} ChainPull: ${ChainPull} ${SkipCombat} ${MezMobFlag}
            /if ((!${AggroTargetID} && (!${MezMobFlag} || !${MobCount}) && !${ChainPull}) || (${MobCount}<2 && ${ChainPull})) /break
            | if I am in melee distance of camp and there are no mobs in melee distance then we need to return to camp.
            | even if there are mobs in XTarget that doesn't mean we should NOT return to camp.
            /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]}>${CampRadius} && !${SpawnCount[xtarhater loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance}]}) /call DoWeMove 1 checkforcombat
        }
        /if (${MobCount}==1 && ${ChainPull}==2) /return
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} > 15) {
            /if (!${IAmMA}) /delay ${Math.Calc[${Math.Rand[1]}+1]}s
            /if (${MobCount}<=0) /call DoWeMove 0 checkforcombat
        } else /if (${Select[${Role},hunter,hunterpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${Math.Calc[${MaxRadius}*.95]}) {
            DEBUGPULL PullHunter Returning hunter to camp
            /echo ${Role}: Reached edge of ${MaxRadius} hunting radius. Trying to return to camp.
            /call FindMobOnReturn
        }
        DEBUGCOMBAT CheckForCombat leave.
    /return
| -------------------------------------------------------------------------------------
| SUB: GetCombatPosition - move to LOS of Mob
| -------------------------------------------------------------------------------------
    Sub GetCombatPosition(int moveToTarget)
        DEBUGCOMBAT GetCombatPosition Enter - ${Spawn[${MyTargetID}].Distance3D} - ${MeleeDistance}
        /declare GMPTimer timer local 0
        /declare moveToAllow int local 1
        
        /if (${DPSPaused}) {
            /varset moveToAllow 0
        } else /if (!${moveToTarget}) {
            /if (${Spawn[${MyTargetID}].Distance3D}>${MeleeDistance}) {
                /varset moveToAllow 0
            } else /if (${Spawn[${MyTargetID}].PctHPs}>${AssistAt}) {
                /varset moveToAllow 0
            }
        }
        
        /if (${moveToAllow}) {
            /varset GMPTimer 50
            /if (${PullMoveUse.Equal[nav]}) {
                /nav id ${MyTargetID}
                /while (${GMPTimer}) {
                    /if (${Spawn[${MyTargetID}].Distance3D}<${MeleeDistance} && ${Spawn[${MyTargetID}].LineOfSight}) {
                        /nav stop
                        /break
                    }
                    /delay 1
                }
                /if (${Navigation.Active}) /nav stop
            } else {
                /moveto id ${MyTargetID}
                /while (${GMPTimer}) {
                    /if (${Spawn[${MyTargetID}].Distance3D}<${MeleeDistance} && ${Spawn[${MyTargetID}].LineOfSight}) {
                        /moveto off
                        /break
                    }
                    /delay 1
                }
                /if (${MoveTo.Moving}) /moveto off
            }
        } else {
            /if (${Spawn[${MyTargetID}].Distance3D}>${MeleeDistance} || ${Spawn[${MyTargetID}].PctHPs}>${AssistAt}) {
                /if (!${SpamTimer3}) {
                    /echo Get Combat Position Failed. Target is too far away or Not ready to attack.
                    /varset SpamTimer3 50
                }
            }
        }
        DEBUGCOMBAT GetCombatPosition Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Assist - Get Main Tank's target
| -------------------------------------------------------------------------------------
    Sub Assist(FromWhere)
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (!${MeleeOn} && !${DPSOn} && !${MezOn}) /return
        /if (${DPSPaused}) /return
        /if (${Me.Hovering}) /return
        /if (${Pulled} && ${MyTargetID} && ${IAmMA}) /return
        DEBUGCOMBAT Assist Enter
        /declare TempTargetID int local
        /doevents
        /call MobRadar los ${MeleeDistance} Assist
        | Normal assist check
        DEBUGCOMBAT Assist0: ${Me} ${MainAssist} ${IAmMA} ${Spawn[=${MainAssist}].Distance} ${MobCount} ${AggroTargetID} ${Target.ID} ${MyTargetID} ${Me.Combat}
        /if (${MobCount} || ${AggroTargetID}) {
            /if (${Spawn[=${MainAssist}].ID}) {
                /if (${Spawn[=${MainAssist}].Distance}<200) {
                    DEBUGCOMBAT Assist1: ${Group.MainAssist.ID} ${Spawn[=${MainAssist}].ID} ${Me.GroupAssistTarget.ID} ${Me.XTarget[${XTSlot}].ID} ${Me.XTarget[${XTSlot2}].ID}
                    /if (${Group.MainAssist.ID} && ${Group.MainAssist.ID}==${Spawn[=${MainAssist}].ID}) {
                        /if (${Bool[${Me.GroupAssistTarget.ID}]}==TRUE) {
                            /target id ${Me.GroupAssistTarget.ID}
                            /delay 10 ${Me.GroupAssistTarget.ID}==${Target.ID}
                        } else /if (${Target.ID}) {
                            /squelch /target clear
                            /delay 10 !${Target.ID}
                            /varset MyTargetID 0
                        }
                    } else {
                        /assist ${MainAssist}
                        /delay 5s ${Me.AssistComplete}==TRUE
                        /if (${XTarAutoSet} && !${Group.Member[${MainAssist}].Index} && !${IAmMA} && !${Me.XTarget[${XTSlot}].ID} && ${Target.Type.NotEqual[PC]}) /xtarget set ${XTSlot} currenttarget
                    }
                | If the tank is dead and aggro mob in camp target 1st mob on autohater in xtarget
                } else /if (${Role.Equal[offtank]}) {
                    /return switch
                } else /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<=${MeleeDistance}) {
                    /squelch /target id ${AggroTargetID}
                    /delay 10
                }
            }
        }
        DEBUGCOMBAT Assist: validatetarget ID:${Target.ID}
        /if (!${Target.ID}) {
            DEBUGCOMBAT Assist: Validate Target - No target return
            /return
        }
        /varset TempTargetID ${Target.ID}
        /call ValidateTarget
        | If target is not valid return
        DEBUGCOMBAT Assist Target:${Target.CleanName} ValidTarget:${ValidTarget} Marco Return:${Macro.Return}
        /if (${ValidTarget}==0) {
            /varset MyTargetID 0
            /varset MyTargetName
            /return
        } else {
            /if (${Target.ID}!=${TempTargetID}) {
               /squelch /target clear
               /delay 10 !${Target.ID}
               /target id ${TempTargetID}
               /delay 10 ${Target.ID}
            }
            /if (${XTarAutoSet} && !${Group.Member[${MainAssist}].Index} && !${IAmMA} && !${Me.XTarget[${XTSlot}].ID} && ${Target.Type.NotEqual[PC]}) /xtarget set ${XTSlot} currenttarget
            /varset MyTargetID ${Target.ID}
            /varset MyTargetName ${Target.CleanName}
            /varset LastTargetID ${MyTargetID}
        }
        DEBUGCOMBAT Assist MyTargetName:${MyTargetName} ID:${MyTargetID} !${IAmMA}
        DEBUGCOMBAT Assist Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: GetCombatTarget - Main Tank selects target to kill.
| -------------------------------------------------------------------------------------
    Sub GetCombatTarget
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (!${MeleeOn} && !${DPSOn} && !${MezOn}) /return
        /if (${DPSPaused}) /return
        /if (${Me.Hovering}) /return
        /if (${Pulled} && ${MyTargetID} && ${IAmMA}) /return
        DEBUGCOMBAT GetCombatTarget Enter
        /declare j int local
        /declare n int local
        /declare HighestMobID  int local 0
        /declare ClosestMobID  int local 0
        /declare MostHurtMobID int local 0
        /declare BlurredMobID  int local 0
        /declare TempTargetID  int local
        /doevents
        /if (${AggroTargetID2} && (!${Spawn[${AggroTargetID2}].ID} || ${Spawn[${AggroTargetID2}].Type.Equal[corpse]})) /varset AggroTargetID2 0
        /call MobRadar los ${MeleeDistance} GetCombatTarget
        | Normal assist check
        DEBUGCOMBAT GetCombatTarget0: ${Me} ${MainAssist} ${Spawn[=${MainAssist}].Distance} ${MobCount} ${AggroTargetID} ${Target.ID} ${MyTargetID} ${Me.Combat}
        /if (${IAmMA} || (!${Spawn[=${MainAssist}].ID} && ${Role.Equal[offtank]})) {
            DEBUGCOMBAT GetCombatTarget2: MainAssist.Equal[${Me}] is ${IAmMA} OR my role is ${Role} MobCount = ${MobCount}
            /if (${Target.CleanName.Equal[${Me}]} && (${MobCount} || ${AggroTargetID})) /squelch /target clear
            | I am tank with a single mob wait for it then validate and attack.
            /if (${MobCount}==1 && (!${XTSlot2} || (${XTSlot2} && !${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID}) {
                DEBUGCOMBAT GetCombatTarget: ${MobCount}==1 && ${AggroTargetID}
                /squelch /target id ${AggroTargetID}
                /delay 10 ${Target.ID}==${AggroTargetID}
                DEBUGCOMBAT GetCombatTarget: Single target: ${AggroTargetID} ${Spawn[${AggroTargetID}].CleanName}
            } else /if ((${MobCount}>=2 || (${XTSlot2} && ${Me.XTarget[${XTSlot2}].ID})) && ${AggroTargetID}) {
                | More than one mob
                | Check if named incoming an target if true else assign closest target.
                /if (${Spawn[xtarhater named].ID}) {
                    /varset TempTargetID ${Spawn[xtarhater named].ID}
                    /squelch /target id ${TempTargetID}
                    /delay 10 ${Target.ID}==${TempTargetID}
                } else /if (${Alert[4].Size} && ${Spawn[xtarhater alert 4].ID} && ${Spawn[xtarhater alert 4].Type.NotEqual[Corpse]}) {
                    /varset TempTargetID ${NearestSpawn[1, xtarhater alert 4].ID}
                    /call BroadCast y "Grabbing MEZ Immune -> ${Spawn[${TempTargetID}].Name} <- ID:${Spawn[${TempTargetID}].ID} "
                    /squelch /target id ${TempTargetID}
                    /delay 10 ${Target.ID}==${TempTargetID}
                } else {
                    /varset j ${SpawnCount[xtarhater]}
                    /if (${j}) {
                        /varset TempTargetID ${NearestSpawn[1, xtarhater].ID}
                        /varset ClosestMobID ${TempTargetID}
                        /varset HighestMobID ${TempTargetID}
                        /varset MostHurtMobID ${TempTargetID}
                        /for n 1 to ${j}
                            /varset TempTargetID ${NearestSpawn[${n}, xtarhater].ID}
                            /if (${Spawn[${TempTargetID}].PctHPs}<${Spawn[${MostHurtMobID}].PctHPs}) /varset MostHurtMobID ${TempTargetID}
                            /if (${Spawn[${TempTargetID}].Level}>${Spawn[${HighestMobID}].Level}) /varset HighestMobID ${TempTargetID}
                        /next n
                        | Don't need to target mob on incoming and out of meleedistance'
                        /varset TempTargetID ${ClosestMobID}
                        /if (${ReturnToCamp}) {
                            /if (${MostHurtMobID} && ${ClosestMobID}!=${MostHurtMobID} && ${Math.Distance[${Spawn[${MostHurtMobID}].Y},${Spawn[${MostHurtMobID}].X}:${CampYLoc},${CampXLoc}]}<=${MeleeDistance}) /varset TempTargetID ${MostHurtMobID}
                            /if (${TempTargetID}!=${HighestMobID}) {
                                /if (${Spawn[${TempTargetID}].Level}<${Spawn[${HighestMobID}].Level} && ${Select[${Spawn[${TempTargetID}].Animation},26,32,71,72,110,111]} && ${Math.Distance[${Spawn[${HighestMobID}].Y},${Spawn[${HighestMobID}].X}:${CampYLoc},${CampXLoc}]}<=${MeleeDistance}) /varset TempTargetID ${HighestMobID}
                            }
                            /if (${Target.ID}!=${TempTargetID} && ${Math.Distance[${Spawn[${TempTargetID}].Y},${Spawn[${TempTargetID}].X}:${CampYLoc},${CampXLoc}]}<=${MeleeDistance}) {
                                /squelch /target id ${TempTargetID}
                                /delay 10 ${Target.ID}==${TempTargetID}
                            }
                        } else {
                            /if (${MostHurtMobID} && ${ClosestMobID}!=${MostHurtMobID} && ${Spawn[${MostHurtMobID}].Distance}<=${MeleeDistance}) /varset TempTargetID ${MostHurtMobID}
                            /if (${TempTargetID}!=${HighestMobID}) {
                                /if (${Spawn[${TempTargetID}].Level}<${Spawn[${HighestMobID}].Level} && ${Select[${Spawn[${TempTargetID}].Animation},26,32,71,72,110,111]} && ${Math.Distance[${Spawn[${HighestMobID}].Y},${Spawn[${HighestMobID}].X}:${CampYLoc},${CampXLoc}]}<=${MeleeDistance}) /varset TempTargetID ${HighestMobID}
                            }
                            /if (${Target.ID}!=${TempTargetID} && ${Spawn[${TempTargetID}].Distance}<=${MeleeDistance}) {
                                /squelch /target id ${TempTargetID}
                                /delay 10 ${Target.ID}==${TempTargetID}
                            }
                        }
                    }
                }
                DEBUGCOMBAT ClasestMobID: ${ClosestMobID} Distance: ${Math.Distance[${Spawn[${ClosestMobID}].Y},${Spawn[${ClosestMobID}].X}:${CampYLoc},${CampXLoc}]} XTarget[${XTSlot2}] ID: ${Me.XTarget[${XTSlot2}].ID} Distance: ${Math.Distance[${Me.XTarget[${XTSlot2}].Y},${Me.XTarget[${XTSlot2}].X}:${CampYLoc},${CampXLoc}]} AggroTargetID: ${AggroTargetID} MostHurtID: ${MostHurtMobID}
            } else /if (!${AggroTargetID} && ${MobCount} && ${MezMobFlag}==1) {
                | Check for memblurred mobs in camp when nothing left on xtarget. Check only for 5 secs after last mob.
                DEBUGCOMBAT GetCombatTarget3: ${AggroTargetID} ${MobCount} ${MezMobFlag}
                /varset BlurredMobID ${NearestSpawn[1,npc targetable los radius ${MeleeDistance} zradius 50 noalert 3].ID}
                DEBUGCOMBAT GetCombatTarget4: ${BlurredMobID} ${Math.Distance[${Spawn[${BlurredMobID}].Y},${Spawn[${BlurredMobID}].X}:${CampYLoc},${CampXLoc}]} ${MeleeDistance}
                /if (${BlurredMobID} && ${Math.Distance[${Spawn[${BlurredMobID}].Y},${Spawn[${BlurredMobID}].X}:${CampYLoc},${CampXLoc}]}<${MeleeDistance}) {
                    /squelch /target ID ${BlurredMobID}
                    /varset MezMobFlag 0
                    /delay 30 ${Target.ID}==${BlurredMobID} && ${Target.BuffsPopulated}
                    /if (${Target.Mezzed.ID}) {
                        /call BroadCast y "Found Mezzed Mob: ${Spawn[${BlurredMobID}].CleanName} <- ID:${BlurredMobID}"
                        /echo MEZ >> Found a Mezzed mob in Camp. <<
                        /varset AggroTargetID2 ${BlurredMobID}
                        /varset MyTargetID ${Target.ID}
                        /varset MyTargetName ${Target.CleanName}
                        /varset LastTargetID ${MyTargetID}
                    } else {
                        /if (${Target.ID}) /squelch /alert add 3 id ${Target.ID}
                    }
                    /return
                }
                /varset MezMobFlag 0
            }
        }
        DEBUGCOMBAT GetCombatTarget: validatetarget ID: ${Target.ID}
        /if (!${Target.ID}) {
            DEBUGCOMBAT GetCombatTarget: Validate Target - No target return
            /return
        }
        /varset TempTargetID ${Target.ID}
        /call ValidateTarget
        | If target is not valid return
        DEBUGCOMBAT GetCombatTarget Target:${Target.CleanName} ValidTarget:${ValidTarget} Marco Return:${Macro.Return}
        /if (${ValidTarget}==0) {
            /varset MyTargetID 0
            /varset MyTargetName
            /return
        } else {
            /if (${Target.ID}!=${TempTargetID}) {
               /squelch /target clear
               /delay 10 !${Target.ID}
               /target id ${TempTargetID}
               /delay 10 ${Target.ID}
            }
           /varset MyTargetID ${Target.ID}
           /varset MyTargetName ${Target.CleanName}
           /varset LastTargetID ${MyTargetID}
        }
        DEBUGCOMBAT GetCombatTarget MyTargetName:${MyTargetName} ID:${MyTargetID}
        DEBUGCOMBAT GetCombatTarget Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Validate Target Combined Spawn and Target
| -------------------------------------------------------------------------------------
    Sub ValidateTarget(int SpawnID)
        DEBUGCOMBAT ValidateTarget Enter Target Name:${Target.CleanName} ID:${Target.ID} Spawn Name: ${Spawn[${SpawnID}].CleanName} ID:${SpawnID}
        /declare j int local
        /declare PullValid int local 0
        /declare MobID int local 0
        /declare MobName string local
        /declare MobNameCheck string local
        /declare MobType string local
        /declare MeleeDistanceCheck int local ${MeleeDistance}
        /varset ValidTarget 0
        /if (${SpawnID}) {
           /varset MobID ${Spawn[${SpawnID}].ID}
           /varset MobName ${Spawn[${SpawnID}].CleanName}
           /varset MobType ${Spawn[${SpawnID}].Type}
        } else {
           /varset MobID ${Target.ID}
           /varset MobName ${Target.CleanName}
           /varset MobType ${Target.Type}
        }
        /if (!${MobID}) /return NoTarget
        DEBUGCOMBAT ValidateTarget Validate 1
        /if (${Select[${MobType},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,TRIGGER,TRAP,TIMER,MOUNT,Mercenary]}) /return BadTargetType
        DEBUGCOMBAT ValidateTarget Validate 2
        | If mob found on ignore and not on xtarget skip
        /if (${MobsToIgnore.Find[${MobName}]}) {
            /if (${Select[${MobID},XTCHECK]}==0) /return MobOnIgnoreList
        }
        /if (${MobsToIgnoreByID.Find[${MobID}|]}) /return MobOnIgnoreListByID
        | Check if target is somewhere on my extended target.
        /if (${Select[${Role},tank]} && ${MobCount}<=${XSlotTotal} && ${Spawn[${MainAssist} ${MainAssistType} group].ID}) {
            /if (${SpawnCount[id ${MobID} xtarhater]}==0) /return NotOnXTarget
        }
        /if (${Spawn[id ${MobID}].MaxRangeTo}>${MeleeDistance}) /varcalc MeleeDistanceCheck ${Spawn[id ${MobID}].MaxRangeTo}+5
        /if (${ReturnToCamp} && ${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${CampYLoc},${CampXLoc}]}>${MeleeDistanceCheck} && !${Pulling} && ${Select[${Role},tank,pullertank,pettank,pullerpettank]}) /return OutofCampRadius
        DEBUGCOMBAT ValidateTarget Validate 3
        /if (${MobName.Find[eye of]} && ${SpawnCount[pc ${MobName.Right[${Math.Calc[${MobName.Length}-7]}]}]}) /return Spell-Eye-PC
        /if (${MobType.Equal[Pet]} && ${Spawn[${MobID}].Master.Type.Equal[PC]}) /return PET-PC
        /if (${Target.ID}==${MobID} && ${Target.Charmed.ID}) /return Target-Charmed
        /if (!${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) /return PC
        | This prevents characters on the Zek server from attacking PC targets in their group
        /if (${Select[${EverQuest.Server},zek]} && ${Select[${MobType},PC]}) {
            /if (${Spawn[id ${MobID} group].ID}>0) /return GroupMember
            /if (${MobID}==${Spawn[=${MainAssist}].ID}) /return MA
        }
        DEBUGCOMBAT ValidateTarget Validate 4
        | Only valid when pulling
        /if (${Pulling} && !${Pulled}) {
            /if (${PullIgnore1.Find[${MobID}|]}) /return MobOnPullIgnoreListByID
            /if (${Select[${PullMoveUse},los,nav]}>0) {
                /if (${Math.Distance[${Spawn[${MobID}].Y},${Spawn[${MobID}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius} && ${Spawn[${MobID}].Distance3D}>${PullRange}) /return OutofRadius
                /if (${PullMoveUse.Equal[los]} && ${Select[${Role},puller,pullertank,pullerpettank]} && !${Spawn[${MobID}].LineOfSight}) /return NoLOS
            }
            /if (${Spawn[${MobID}].PctHPs}<=99) /return PullNotFullHealth
            /if (${SpawnCount[notid ${Me.ID} loc ${Spawn[${MobID}].X} ${Spawn[${MobID}].Y} radius 30 pc nogroup]}>0) /return PCNear
            /if (${Spawn[${MobID}].Level}<${PullMin} || ${Spawn[${MobID}].Level}>${PullMax}) /return BadLevel
            /if (${Window[TargetOfTargetWindow].Open} && ${Target.ID}==${MobID}) {
            | - If mob I'm pulling is aggroed already by non damaging spell by someone else.
               /delay 10 ${Target.ID}==${MobID}
               /if (${Me.TargetOfTarget.Type.Equal[PC]} && ${Me.TargetOfTarget.Name.NotEqual[${Me}]} && !${Group.Member[${Me.TargetOfTarget.Name}].Index}) /return PullToTTNotPuller
               /if (${Me.TargetOfTarget.Type.Equal[PET]} && ${Me.TargetOfTarget.Name.NotEqual[${Me.Pet.CleanName}]}) /return PullToTTNotMyPet
               /if (${Me.TargetOfTarget.Type.Equal[mercenary]} && !${Group.Member[${Me.TargetOfTarget.Name}].Index}) /return PullToTNotMyMerc
            }
            /if (${DebugPull} && ${MobsToPull.NotEqual[all]}) /echo ValidateTarget ${MobsToPull}
            /if (${MobsToPull.Equal[all]}) {
                /varset PullValid 1
            } else {
                /for j 1 to 25
                    /varset MobNameCheck ${MobsToPull.Arg[${j},,]}
                    /if (${MobNameCheck.Find[*]}) {
                        /varset MobNameCheck ${MobNameCheck.Replace[*,]}
                    } else /if (${MobNameCheck.Find[#]}) {
                        /varset MobNameCheck ${MobNameCheck.Replace[#,]}
                    }
                    DEBUGPULL ValidateTarget ${j} ${MobsToPull.Arg[${j},,]} ${MobName.Find[${MobNameCheck}]}
                    /if (${MobName.Find[${MobNameCheck}]}) {
                        /varset PullValid 1
                        /break
                    }
                /next j
            }
            /if (!${PullValid}) /return PullMobNotonList
        }
        /varset ValidTarget 1
        DEBUGCOMBAT ValidateTarget Leave
    /return ${ValidTarget}
| -------------------------------------------------------------------------------------
| SUB: Combat
| -------------------------------------------------------------------------------------
    Sub Combat
        /doevents
        DEBUGCOMBAT Role: ${Role} Camp Distance: ${Math.Distance[${CampYLoc},${CampXLoc}]} ${CampRadius} Pulling: ${Pulling}  ${MyTargetID} ${Target.ID} ${Target.LineOfSight} ${DPSPaused}
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius} && ${Pulling}) /return
        /if (!${MyTargetID} || !${Target.ID}) /return
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        |/if (!${Target.LineOfSight}) /return
        /if (!${Target.LineOfSight} && !${Role.Find[hunter]}) /return
        
        /if (${DPSPaused}) /return
        | Check if mob mezzed
        /if (${Target.Mezzed.ID}) {
            /if (${Spawn[=${MainAssist}].ID} && !${IAmMA} && ${Spawn[${MyTargetID}].PctHPs}<=${AssistAt}) {
                /echo Mob is mezzed ->> ${Target.CleanName} <<- I am not going to wake it since I am on assist.
                /delay 10
                /return
            }
        }
        /if (${Select[${Role},tank,pullertank]}==0 && (${Me.Song[Rallying Call].ID} || ${Me.Song[Rallying Solo].ID})) /return
        DEBUGCOMBAT Combat Enter
        /declare CombatRadius int   local ${If[${Spawn[id ${MyTargetID}].MaxRangeTo}>${MeleeDistance},${Math.Calc[${Spawn[id ${MyTargetID}].MaxRangeTo}+5]},${MeleeDistance}]}
        /declare SpamTankWait int   local 1
        /declare navTimer     timer local 0
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /if (${CuresOn}) {
            /call CheckCures Combat
        } else /if (${HealsOn}) {
            /if (!${LastHealCheck}) {
                /call CheckHealth Combat1
                /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
            }
        }
        /if (${ChaseAssist}) /call DoWeChase
        /if (${MezOn}) {
            /call MezCheck Combat
        }
        | Check Target Hps and type NPC or NPC Pet
        DEBUGCOMBAT Combat ${Spawn[${MyTargetID}].Name} PctHPs = ${Spawn[${MyTargetID}].PctHPs} AssistAt=${AssistAt} Distance = ${Spawn[${MyTargetID}].Distance} CombatRadius = ${CombatRadius}
        /if (${DPSMeter}) {
            /if (!${DPSAdv.MyStatus}) /DPSAdv mystart
        }
        | PullerPetTank and PetTank send in pet if mob in range
        /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && ${Spawn[${MyTargetID}].Distance}<${PetAttackRange}) /call CombatPet
        /if (${AggroOn} && !${IAmMA} && ${Select[${Role},Tank]} && ${Spawn[${MyTargetID}].Distance}>${CombatRadius}) /call AggroCheck
        /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]} && ${Spawn[${MyTargetID}].PctHPs}<=${AssistAt} && (${Spawn[${MyTargetID}].Distance}<${CombatRadius} || (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CombatRadius} && ${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius}))) {
            /if (!${CombatStart}) {
                DEBUGCOMBAT Combat Setting CombatStart to 1
                /if (${Cursor.ID}) /call CheckCursor Combat 0
                /varset MercAssisting 0
                /varset CombatStart 1
                /echo  ATTACKING -> ${Spawn[${MyTargetID}].CleanName} <-
                /if (${IAmABard}) /call DoBardStuff
                /if (${Select[${Role},Tank,PullerTank,Hunter]}) /call BroadCast y "TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
                /if (${Select[${Role},petTank,pullerpettank,hunterpettank]}) /call BroadCast y "${Me.Pet.CleanName} is TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
                | Moloing as as puller turn off puller tag in group so tank merc attacks and doesn't wait for me to get 2 feet near them.
                /if (${Group}==1 && ${Select[${Role},puller]} && ${Group.Puller.Name.Equal[${Me}]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<${CampRadius}) /call AssignGroupRole unset "${Me.CleanName}" 3
                /if (!${Spawn[${MyTargetID}].LineOfSight} && ${Role.Find[hunter]}) /call GetCombatPosition 1
            }
            /if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID})) /face ${If[${FaceMobOn}==1,fast nolook,nolook]}
            /if (!${Me.FeetWet}) /look 0
            /if (!${Attacking}) {
                /if (${MeleeOn}) {
                    /varset Attacking 1
                    /if (${Me.Sitting}) /stand
                    /if (${AutoFireOn}!=1) {
                        DEBUGCOMBAT Combat Attack On
                        | Speed up tanks attacking inc mobs MQ2Melee /killthis can cause a delay
                        /if (${Select[${Role},tank,pullertank,hunter]}) {
                            /if (${Me.Skill[Taunt]} && ${Me.AbilityReady[Taunt]}) /doability Taunt
                        }
                        /if (!${Me.Combat} && ${BeforeArray[1].NotEqual[null]}) /call BeforeAttack ${MyTargetID} 1
                        /if (${PetCombatOn} && ${Me.Pet.ID}) {
                            /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && !${Pet.Combat}) /call CombatPet
                        }
                        | Move to mob Attack on and Stick handled in CheckStick
                        /call CheckStick 0 1
                        | Move closer if Z distance more than 4 due to levitation
                        /call ZAxisCheck ${ZDist} 4.1
                    } else {
                        /if (!${Me.Combat} && ${BeforeArray[1].NotEqual[null]}) /call BeforeAttack ${MyTargetID} 1
                    }
                } else {
                    /if (${Stick.Active}) /stick off
                    /if (${PetCombatOn} && ${Me.Pet.ID}) {
                        /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && !${Pet.Combat}) {
                            /call CombatPet
                            /varset Attacking 1
                        }
                    }
                }
            }
            /varset  MyExp ${Me.PctExp}
            /varset  MyAAExp ${Me.PctAAExp}
            | Turn on check for mez mob in camp that has been mem blurred if i am a tank type
            /if (${Select[${Role},tank,pullertank,pettank,pullerpettank]}) /varset MezMobFlag 1
            /while (1) {
                DEBUGCOMBAT Attack 1
                /while (1) {
                    /varset EventFlag 0
                    /doevents
                    /if (!${EventFlag}) /break
                }
                /if (${Role.Equal[offtank]} && !${Spawn[=${MainAssist}].ID}) /switchma ${Me} tank 0
                /if (${MercOn} && ${MercAssisting}!=${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
                /if (${AutoFireOn}!=1) {
                    /if (${MeleeOn}) {
                        /if (${Spawn[${MyTargetID}].Distance3D}>${Spawn[${MyTargetID}].MaxRangeTo} && !${Stick.Active}) /call CheckStick 0 ${If[${UseMQ2Melee},0,1]}
                    }
                } else {
                    | This is where we would add our call to the routine to position us for Autofire.
                    /if (${CombatStart} && !${Me.AutoFire}) {
                        /if (${Target.ID}==${MyTargetID} && !${Bool[${Target.Mezzed.ID}]}) {
                            /if (${Me.Sitting}) /stand
                            /autofire
                        }
                    }
                }
                /if (${MezOn}) {
                    /call MezCheck Combat
                }
                /if (${AEOn}) /call AECheck ${AEDisplayMobInfo}
                /if (${AggroOn}) /call AggroCheck
                /if (${CuresOn}) {
                    /call CheckCures Combat
                } else /if (${HealsOn}) {
                    /if (!${LastHealCheck}) {
                        /call CheckHealth Combat2
                        /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
                    }
                } else /if (${AutoRezOn}) {
                    /call RezCheck group
                }
                /if (!${NamedCheck} && (${BurnAllNamed} || ${GMailEvents.Find[named]})) /call NamedWatch 0
                /if (${Role.NotEqual[puller]} || !${ChainPull}) {
                    /if (${DebuffAllOn}) {
                        DEBUGCOMBAT Attack 2
                        | Debuff stuff
                        /call DoDebuffStuff ${MyTargetID}
                    }
                    |When returning the mob you were started on could be dead, so don't keep trying to kill a corpse.
                    /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) {
                        /call CombatReset 0 combat
                        /break
                    }
                    /if (${DPSOn}) {
                        /if (!${MeleeOn} && !${AggroOffTimer} && ${Me.Invis}) /makemevisible
                        /call CombatCast
                        /if (${Macro.Return.Equal[tcnc]}) /continue
                    } else {
                        /if (${MashArray.Size}>0 && ${MashArray[1].NotEqual[null]}) /call MashButtons
                    }
                }
                DEBUGCOMBAT Attack 3
                |moved heal checking from CastMana to before calling it.
                /if (${CuresOn}) {
                    /call CheckCures Combat
                } else /if (${HealsOn}) {
                    /if (!${LastHealCheck}) {
                        /call CheckHealth Combat2
                        /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
                    }
                } else /if (${AutoRezOn}) {
                    /call RezCheck group
                }
                /call CastMana combat
                /call WriteDebuffs
                /if (${IAmABard}) /call DoBardStuff
                /call CombatTargetCheck 1
                /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]} && !${DPSPaused}) {
                    /if (${AutoFireOn}!=1) {
                        /if (${Attacking}) {
                            /if (${MeleeOn}) {
                                /if (${Target.PctHPs}<=${AssistAt} && ${Target.Distance}<${CombatRadius}) {
                                    /if (!${TargetSwitchingOn} && ${Target.ID}!=${MyTargetID}) {
                                        /squelch /target id ${MyTargetID}
                                        /delay 10 ${Target.ID}==${MyTargetID}
                                    }
                                    /if (!${Me.Combat}) {
                                        /if (${Me.Sitting}) /stand
                                        /call CheckStick 0 1
                                    } else {
                                        /if (!${Stick.Active}) /call CheckStick 1 0
                                    }
                                } else /if (!${Me.Combat} && ${IAmMA}) {
                                    /if (${DebugCombat}) {
                                        /beep
                                        /echo \atIm in the :Attack loop but attack is not on Attacking=${Attacking} MeleeOn=${MeleeOn} Target.PctHPs=${Target.PctHPs} Math.Calc[AssistAt-5]=${Math.Calc[${AssistAt}-5]} Target.Distance=${Target.Distance} CombatRadius=${CombatRadius} AutoFireOn=${AutoFireOn}
                                    }
                                    /if (${Target.ID} && ${Select[${Me.State},stand,mount]}) /squelch /attack on
                                }
                            } 
                        }
                    } else /if (${AutoFireOn}==1) {
                        /if (${CombatStart} && !${Me.AutoFire}) {
                            /if (${Target.ID}==${MyTargetID} && !${Bool[${Target.Mezzed.ID}]}) {
                                /if (${Me.Sitting}) /stand
                                /autofire
                            }
                        }
                    }
                    /if (${PetCombatOn} && ${Me.Pet.ID}) {
                        /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && !${Pet.Combat}) {
                            /call CombatPet
                        }
                    }
                    | Chain Pulling Check Here
                    /if (${Role.Equal[puller]} && ${ChainPull}) {
                        /call ChainPullNextMob ${SpamTankWait}
                        /if (${Macro.Return.Equal[1]}) {
                            /return
                        } else /if (${Macro.Return.Equal[W]}) {
                            /varset SpamTankWait 0
                        }
                        /if (${DebuffAllOn}) /call DebuffCast ${MyTargetID} 1
                        /if (${DPSOn}) {
                            /if (!${MeleeOn} && !${AggroOffTimer} && ${Me.Invis}) /makemevisible
                            /call CombatCast
                            /if (${Macro.Return.Equal[tcnc]}) /continue
                        } else {
                            /if (${MashArray.Size}>0 && ${MashArray[1].NotEqual[null]}) /call MashButtons
                        }
                    } else {
                        DEBUGCHAINPULL Chain Pull Failed 0: ${Role} ${ChainPull}
                    }
                } else {
                    | We have a corpse targeted if we get here.
                    /if (${DPSPaused} || !${TargetSwitchingOn}) {
                        /call CombatReset 0 combat
                        /break
                    } else {
                        | Target Switching must be enabled to get here.
                        DEBUGCOMBAT Attack 4 ${MyTargetID} ${Target.ID} ${TargetSwitchingOn}
                        /if (${IAmMA}) {
                            /if (${Target.ID} && ${Target.ID}!=${MyTargetID}) {
                                /if (${MyTargetID}) /varset LastTargetID ${MyTargetID}
                                /varset MyTargetID 0
                                /call CombatTargetCheck 1
                                /if (!${MyTargetID}) {
                                    /varset MyTargetID ${LastTargetID}
                                    /call CombatReset 0 combat
                                    /break
                                }
                                /continue
                            } else {
                                /call CombatReset 0 combat
                                /break
                            }
                        } else {
                            /call CombatReset 0 combat
                            /break
                        }
                    }
                    /if (${Defined[ParseDPS]}) {
                        /if (!${ParseDPS}) /break
                    }
                }
                /if (${Me.Feigning} || ${Me.Invis}) {
                    /call FeignAggroCheck
                    /delay 5
                    /if (${Me.Feigning} || ${Me.Invis}) /break
                }
            }
        } else /if (${Spawn[${MyTargetID}].Distance}<${CombatRadius} || (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CombatRadius} && ${Math.Distance[${Target.Y},${Target.X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=${CampRadius})) {
            /if (${DPSOn} || ${MeleeOn} || ${PetOn}) /call CombatTargetCheck 1
            /if (${PetOn} && ${PetCombatOn}) {
                /if (${MezOn}) /call MezCheck Combat
                /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && !${Pet.Combat}) /call CombatPet
            } else {
                /if (${MezOn}) /call MezCheck Combat
                /if (${IAmABard} && ${MeleeTwistOn}==2 && !${DPSTwisting}) /call DoBardStuff
                /if (${DebuffAllOn}==2 && ${MyTargetID} && ${AggroTargetID}) /call DoDebuffStuff ${MyTargetID}
            }
            /if (!${Me.Combat} && ${BeforeArray[1].NotEqual[null]}) /call BeforeAttack ${MyTargetID} 2
        }
        DEBUGCOMBAT Combat Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CombatTargetCheck
| -------------------------------------------------------------------------------------
    Sub CombatTargetCheck(int SetTarget)
        | If mob is dead return
        DEBUGCOMBAT CombatTargetCheck1 ${MyTargetID} ${Spawn[${MyTargetID}].Type} ${CalledTargetID} ${TargetSwitchingOn}
        /if (${IAmMA}) {
            /if (${TargetSwitchingOn} && ${Target.ID} && ${Spawn[${Target.ID}].Type.Equal[Corpse]}) /return
        } else {
            /if (${TargetSwitchingOn}) /return
        }
        /if (${DPSPaused} && ${SetTarget}!=2) /return
        /if (${MyTargetID} && (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID})) {
            /varset LastTargetID ${MyTargetID}
            /varset MyTargetID 0
            |/return
        }
        /declare CMyTargetID int Local ${MyTargetID}
        | Check target matches MA if group mainassist assigned and MA is in group
        /if (${Spawn[=${MainAssist}].ID} && ${Group.MainAssist.ID} && ${Spawn[=${MainAssist}].ID}==${Group.MainAssist.ID}) {
            |/if (${Group.MainAssist.ID}!=${Me.ID}) {
            /if (!${IAmMA}) {
                /if (${Target.ID}!=${Me.GroupAssistTarget.ID}) {
                    /if (${MyTargetID}!=${Me.GroupAssistTarget.ID} && ${Spawn[id ${Me.GroupAssistTarget.ID} npc].ID}) {
                        /if (${MyTargetID}) /echo My target does not match MA's. Switching to new target.
                        /varset MyTargetID ${Me.GroupAssistTarget.ID}
                    }
                }
            } else {
                /if (${Target.ID} && ${Target.ID}!=${MyTargetID}) {
                    /if (${TargetSwitchingOn}) {
                        /if (!${Select[${Target.Type},pc,mercenary,pet]} || (${Target.Type.Equal[pet]} && ${Target.Master.Type.NotEqual[pc]})) {
                            /echo I am MA, and I switched to new Target.
                            /varset MyTargetID ${Target.ID}
                            /varset MyTargetName ${Target.CleanName}
                            /if (${Select[${Role},Tank,PullerTank,Hunter]}) {
                                /call BroadCast y "TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
                            } else /if (${Select[${Role},petTank,pullerpettank,hunterpettank]}) {
                                /call BroadCast y "${Me.Pet.CleanName} is TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
                            }
                        }
                    } else {
                        /target id ${MyTargetID}
                        /delay 10 ${Target.ID}==${MyTargetID}
                    }
                }
            }
            /varset CalledTargetID 0
            /doevents AttackCalled flush
        } else {
            /if (!${CalledTargetID}) {
                /while (1) {
                    /varset EventFlag 0
                    /doevents AttackCalled
                    /if (!${EventFlag}) /break
                }
            }
            /if (${CalledTargetID} && ${CalledTargetID}!=${MyTargetID}) {
                /varset MyTargetID ${CalledTargetID}
                /varset CalledTargetID 0
            }
        }
        /if (${CMyTargetID}!=${MyTargetID} && ${Target.ID}!=${MyTargetID} && ${Spawn[${MyTargetID}].ID}) {
            /if (${XTarAutoSet} && !${Group.Member[${MainAssist}].Index} && !${IAmMA}) {
                /if (${Spawn[${MyTargetID}].Type.NotEqual[PC]}) {
                    /squelch /target id ${MyTargetID}
                    /delay 10 ${Target.ID}==${MyTargetID}
                    /if (!${Me.XTarget[${XTSlot}].ID} || (${Me.XTarget[${XTSlot}].ID}!=${MyTargetID})) /xtarget set ${XTSlot} currenttarget
                }
            } else {
                /if (${SetTarget}) {
                    /squelch /target id ${MyTargetID}
                    /delay 10 ${Target.ID}==${MyTargetID}
                }
            }
            /varset MyTargetName ${Spawn[${MyTargetID}].CleanName}
            /varset LastTargetID ${MyTargetID}
        }
        DEBUGCOMBAT CombatTargetCheck2 ${MyTargetID} ${LastTargetID} ${Spawn[${MyTargetID}].Type} ${CalledTargetID}
    /return
| -------------------------------------------------------------------------------------
| SUB: CombatTargetCheck1
| -------------------------------------------------------------------------------------
    Sub CombatTargetCheck1(int SetTarget)
        | If mob is dead return
        /if (${MyTargetID} && (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID})) /return
        /if (${DPSPaused}) /return
        /declare CMyTargetID int Local ${MyTargetID}
        /declare i_GATID int local ${Int[${Me.GroupAssistTarget.ID}]}
        /if (!${IAmMA}) {
            | Check target matches MA if group mainassist assigned and MA is in group
            /if (${Spawn[=${MainAssist}].ID} && ${Group.MainAssist.ID} && ${Spawn[=${MainAssist}].ID}==${Group.MainAssist.ID}) {
                |/if (${Target.ID}!=${Me.GroupAssistTarget.ID} && ${Group.MainAssist.ID}!=${Me.ID}) {
                |/if (${Group.MainAssist.ID}!=${Me.ID}) {
                    |/if (${Target.ID}!=${i_GATID}) {
                    |/if (${Target.ID}!=${Me.GroupAssistTarget.ID} && ${MyTargetID}!=${Me.GroupAssistTarget.ID} && ${Spawn[id ${Me.GroupAssistTarget.ID} npc].ID}) {
                    /if (${Target.ID}!=${i_GATID} && ${MyTargetID}!=${i_GATID}) {
                        /if (${Spawn[id ${i_GATID}].Type.Equal[npc]} || (${Spawn[id ${i_GATID}].Type.Equal[pet]} && ${Spawn[id ${i_GATID}].Master.Type.Equal[npc]})) {
                            /if (${MyTargetID}) /echo My target does not match MA's. Switching to new target.
                            /varset MyTargetID ${i_GATID}
                        }
                    }
                    |}
                |} else /if (${TargetSwitchingOn} && ${Group.MainAssist.ID}==${Me.ID} && ${Target.ID} && ${Target.ID}!=${MyTargetID} && !${Select[${Target.Type},pc,mercenary]} && (${Target.Type.Equal[pet]} && ${Target.Master.Type.NotEqual[pc]}))) {
                |} else /if (${TargetSwitchingOn} && ${Target.ID} && ${Target.ID}!=${MyTargetID} && (!${Select[${Target.Type},pc,mercenary,pet]} || (${Target.Type.Equal[pet]} && ${Target.Master.Type.NotEqual[pc]}))) {
            } else /if (${CalledTargetID} && ${CalledTargetID}!=${MyTargetID}) {
                /varset MyTargetID ${CalledTargetID}
                /varset CalledTargetID 0
            }
        } else {
        |    /if (${TargetSwitchingOn} && ${Target.ID} && ${Target.ID}!=${MyTargetID} && (!${Select[${Target.Type},pc,mercenary,pet]} || (${Target.Type.Equal[pet]} && ${Target.Master.Type.NotEqual[pc]}))) {
        |        /echo I am MA, and I switched to new Target.
        |        /varset MyTargetID ${Target.ID}
        |        /if (${Select[${Role},Tank,PullerTank,Hunter]}) {
        |            /call BroadCast y "TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
        |        } else /if (${Select[${Role},petTank,pullerpettank,hunterpettank]}) {
        |            /call BroadCast y "${Me.Pet.CleanName} is TANKING-> ${Spawn[${MyTargetID}].CleanName} <- ID:${MyTargetID}"
        |        }
        |    }
        }
        /if (${CMyTargetID}!=${MyTargetID} && ${Target.ID}!=${MyTargetID} && ${Spawn[${MyTargetID}].ID}) {
            /if (${SetTarget}) {
                /squelch /target id ${MyTargetID}
                /delay 10 ${Target.ID}==${MyTargetID}
                /if (${Me.Pet.ID} && ${Me.Pet.Combat}) {
                    /pet attack
                    /delay 5
                    /pet swarm
                }
            }
            /varset MyTargetName ${Spawn[${MyTargetID}].CleanName}
            /if (${XTarAutoSet} && !${Group.Member[${MainAssist}].Index} && !${IAmMA} && ${Target.Type.NotEqual[PC]}) {
                /if (!${Me.XTarget[${XTSlot}].ID} || (${Me.XTarget[${XTSlot}].ID}!=${MyTargetID})) /xtarget set ${XTSlot} currenttarget
            }
        }
    /return    

| -------------------------------------------------------------------------------------
| SUB: Check Before Cast
| -------------------------------------------------------------------------------------
    Sub CheckBeforeCast(SentFrom)
        /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && ${Raid.Members}==0 && ${SentFrom.Equal[CombatCast]}) /call GroupEscape
        /if (${MezOn} && ${SentFrom.Equal[CombatCast]}) {
            /call MezCheck CheckBeforeCombat
        }
        /if (${CuresOn}) {
            /call CheckCures CheckBeforeCast
        } else /if (${HealsOn}) {
            /if (!${LastHealCheck}) {
                /call CheckHealth CheckBeforeCast
                /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
            }
        } else /if (${AutoRezOn}) {
            /call RezCheck
        }
        /if (${AggroTargetID}) {
            /if (${Cursor.ID}) /call CheckCursor CombatCast 0
            /if (${MercOn} && ${MercAssisting}!=${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
            /if (${AEOn}) /call AECheck ${AEDisplayMobInfo}
            /if (${AggroOn}) /call AggroCheck
            /if (${Spawn[${MyTargetID}].PctHPs}<=${PetAssistAt} && !${Pet.Combat}) /call CombatPet
        } else {
            /doevents
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: Combat Cast
| -------------------------------------------------------------------------------------
    Sub CombatCast
        DEBUGCOMBAT CombatCast Enter
        /declare i           int      local 0
        /declare DPSStart    int      local ${Math.Calc[${DebuffCount}+1]}
        /if (${DPSStart}>${DPS.Size}) /return
        /declare DPSAt       int      local ${AssistAt}
        /declare DPSTargetID int      local 0
        /declare DPSItem     string   local
        /declare DPSPart1    string   local
        /declare DPSPart2    string   local
        /declare DPSPart3    string   local
        /declare DPSPart4    string   local
        /declare DPSPart5    string   local
        /declare DPSStartID  int      local 0
        /declare WeaveCheck  int      local 0
        /declare CondNo      int      local 0
        /call WriteDebuffs
        | Note about being Invised in this routine:
        | Invis is not broken for Pure casters, that are pure DPS characters. Reason for this is Aggro checking.
        | Some classes Fade, Feign, ect... That after loosing Aggro also become invised by the action, to keep from regaining aggro.
        | If you need your pure DPS caster to break invis. You can add an entry using the mash tag. You will have to use
        | an AA, or an Item that will break the invis.
        /if (${Target.ID} && ${Target.ID}!=${MyTargetID}) /call CombatTargetCheck 1
        /varset DPSStartID ${MyTargetID}
        /for i ${DPSStart} to ${DPS.Size}
            /if (${MezOn}) {
                /call MezCheck CombatCast
            }
            /while (1) {
                /varset EventFlag 0
                /doevents
                /if (!${EventFlag}) /break
            }
            /varset DPSTargetID ${MyTargetID}
            /if (${Spawn[${MyTargetID}].Type.Equal[Corpse]} || !${Spawn[${MyTargetID}].ID} || ${DPSPaused}) {
                DEBUGCOMBAT CombatCast: Return from CombatCast cause my target is a corpse or dead or DPSPaused ${DPSPaused}.
                /return
            }
            DEBUGCOMBAT CombatCast ${DPS[${i}].Arg[1,|]} ${Spell[${DPS[${i}].Arg[1,|]}].RankName} ${DPS[${i}].Arg[1,|]} !${Me.SpellReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AltAbilityReady[${DPS[${i}].Arg[1,|]}]} && !${Me.CombatAbilityReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AbilityReady[${DPS[${i}].Arg[1,|]}]}

            /while (1) {
                | This is the Top of the outer loop that will drop you out just above the /next i before going to the next DPS entry.
                /if (!${Bool[${DPS[${i}].Arg[1,|]}]}) {
                    DEBUGCOMBAT CombatCast: I'm skipping in CombatCast cause there is no spell: DPS${i}
                    /break
                }
                /if (${DPS[${i}].Find[|weave]} || ${DPS[${i}].Find[|mash]} || ${DPS[${i}].Find[|ambush]}) /break
                /if (!${DPS[${i}].Find[command:]} && (!${Me.SpellInCooldown} && !${IAmABard} && !${Me.SpellReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]}) && !${Me.AltAbilityReady[${DPS[${i}].Arg[1,|]}]} && !${Me.CombatAbilityReady[${Spell[${DPS[${i}].Arg[1,|]}].RankName}]} && !${Me.AbilityReady[${DPS[${i}].Arg[1,|]}]} && !${Me.ItemReady[${DPS[${i}].Arg[1,|]}]}) /break
                /if (${Int[${DPS[${i}].Arg[2,|]}]} > 0) {
                    /varset DPSPart1 ${DPS[${i}].Arg[1,|]}
                    /varset DPSPart2 ${DPS[${i}].Arg[2,|]}
                    /if (${Bool[${DPS[${i}].Arg[3,|]}]}) {
                        /varset DPSPart3 ${DPS[${i}].Arg[3,|]}
                    } else {
                        /varset DPSPart3
                    }
                    /if (${Bool[${DPS[${i}].Arg[4,|]}]}) {
                        /varset DPSPart4 ${DPS[${i}].Arg[4,|]}
                    } else {
                        /varset DPSPart4
                    }
                    /if (${Bool[${DPS[${i}].Arg[5,|]}]}) {
                        /varset DPSPart5 ${DPS[${i}].Arg[5,|]}
                    } else {
                        /varset DPSPart5
                    }
                    /if (${DPSOn}==1) {
                        /if (!${IAmMA}) {
                            /varset DPSAt ${DPSPart2}
                        } else {
                            /varset DPSAt ${AssistAt}
                        }
                    } else {
                        /varset DPSAt ${AssistAt}
                    }
                } else {
                    /break
                }
                /if (${ConOn} && ${DPS[${i}].Find[|cond]}) {
                    /varset CondNo ${DPS[${i}].Mid[${Math.Calc[${DPS[${i}].Find[|cond]}+5]},3]}
                } else {
                    /varset CondNo 0
                }
                DEBUGCOMBAT DPS${i}:${DPSPart1} ConOn: ${ConOn}  CondNo: ${CondNo}  Parsed:
                /if (${Target.Mezzed.ID} && !${IAmMA} && ${Spell[${DPSPart1}].Category.NotEqual[Utility Detrimental]}) {
                    DEBUGCOMBAT Skipping spell in CombatCast because target is mezzed and I'm not mainassist and it will wake up the mob.
                    /break
                }
                /if (${Select[${DPSPart3},Me,MA,maonce]}==0 && ${DPSTimer${i}} && (${Me.CombatAbility[${DPSPart1}]} || ${Me.Skill[${DPSPart1}]})) /break
                /call CheckBeforeCast CombatCast
                DEBUGCOMBAT CombatCast 0:${DPS[${i}]} 1:${DPSPart1} 2:${DPSPart2} 3:${DPSPart3} 4:${DPSPart4} 5:${DPSPart5} 6:${DPSAt} 7:${Spawn[${MyTargetID}].PctHPs} 8:${DPSSkip} 9:${DPSAt}
                /if (!${AggroTargetID}) /return
                | Check if self combat buff is active
                /if (${DPSPart3.Equal[Me]} && (${Me.Buff[${DPSPart1}].ID} || ${Me.Song[${DPSPart1}].ID})) /break
                /if (${Me.Class.Name.Equal[Cleric]} && ${DPSPart1.Find[Hammer]} && ${Me.Pet.ID}) /break
                /if (${Me.Class.Name.Equal[Wizard]} && ${Me.Pet.ID} && (${DPSPart1.Find[sword]} || ${DPSPart1.Find[blade]})) /break
                /if (${ABTimer${i}} || ${DPSTimer${i}} || ${FDTimer${i}}) /break
                /if (${Spawn[${MyTargetID}].PctHPs}<=${DPSSkip} || (${DPSOn}==1 && ${Spawn[${MyTargetID}].PctHPs}>${DPSAt})) /break
                /if (${DPSPart3.Equal[MA]} || ${DPSPart3.Equal[maonce]}) {
                    /if (${Role.Find[pettank]}) {
                        /varset DPSTargetID ${Me.Pet.ID}
                    } else {
                        /varset DPSTargetID ${Spawn[=${MainAssist}].ID}
                    }
                } else /if (${DPSPart3.Equal[Me]} || ${DPSPart3.Equal[Feign]}) {
                    /varset DPSTargetID ${Me.ID}
                }
                DEBUGCOMBAT CombatCast  DPSTarget: ${DPSTargetID} ${Spawn[${DPSTargetID}]} End: ${DPSSkip} ${Spawn[${DPSTargetID}].PctHPs} Start: ${DPSAt} Target: ${Target.ID} Timer: ${DPSTimer${i}} DPSOn: ${DPSOn}
                /if (${Select[${DPSPart3},Me,MA]} && ${Me.Combat} && !${IAmMA}) {
                    /attack off
                    /delay 10 !${Me.Combat}
                }
                | Only cast spells with weave tag during global cooldown
                /if (${Me.SpellInCooldown} && !${IAmABard}) {
                    /if (${WeaveArray.Size}>0 && ${WeaveArray[1].NotEqual[null]}) {
                        /call CastWeave ${MyTargetID}
                        /varset WeaveCheck 1
                    }
                    /if (${Me.Gem[${DPSPart1}]} && ${Spawn[${MyTargetID}].ID}) {
                        DEBUGCOMBAT CombatCast Spell in Cool Down DPSOn: ${DPSOn}
                        /if (${DPSOn}==2) {
                            /while (${Me.SpellInCooldown}) {
                                /delay 2
                            }
                        } else {
                            /break
                        }
                    }
                }
                /if (${IAmMA} && ${TargetSwitchingOn} && ${Target.ID} && ${Target.ID}!=${MyTargetID}) {
                    /call CombatTargetCheck 1
                    /if (${DPSStartID}!=${MyTargetID}) /return
                }
                /call CastWhat "${DPSPart1}" ${DPSTargetID} DPS ${CondNo} 0
                DEBUGCOMBAT CombatCast MacroReturn: ${Macro.Return}
                /if (${MeleeOn} && !${Me.Combat} && ${Target.ID}==${MyTargetID}) /squelch /attack on
                /if (${Macro.Return.Equal[CAST_COND_FAILED]}) /break
                /varset MacroReturn ${Macro.Return}
                /varset LastDPSCast ${DPSPart1}
                /doevents
                /if (${MacroReturn.Equal[CAST_SUCCESS]}) {
                    /if (${Spawn[${MyTargetID}].ID}) /echo ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} <<
                    | Set timer for spells labeled once 5m
                    /if (${DPSPart3.Length} && (${DPSPart3.Equal[once]} || ${DPSPart3.Equal[maonce]})) {
                        /varset DPSTimer${i} 5m
                    | Timers for items
                    } else /if (${FindItemCount[=${DPSPart1}]}) {
                        /varcalc DPSTimer${i} ${FindItem[=${DPSPart1}].Spell.Duration.TotalSeconds}*10
                    | FD to lose aggro
                    } else /if (${Select[${Me.Class.ShortName},BST,MNK,NEC,SHD]} && ${DPSPart3.Equal[Feign]}) {
                        /delay 30 ${Me.State.Equal[FEIGN]}
                        /varset FDTimer${i} 60s
                        /delay 10s ${Me.State.NotEqual[FEIGN]}
                        /if (${Me.State.Equal[FEIGN]} && !${Me.Sitting}) /stand
                    | Timers for spells
                    } else /if (${Me.Book[${DPSPart1}]}) {
                        | - Attack Buff Timers are seperate. DPS timers are cleared after every fight.
                        /if (${Select[${DPSTargetID},${Me.ID},${Spawn[=${MainAssist}].ID}]}) {
                            /varcalc ABTimer${i} ${Spell[${DPSPart1}].MyDuration.TotalSeconds}*10
                            DEBUGCOMBAT CombatCast Spell: ${DPSPart1} Timer: ABTimer${i} ${ABTimer${i}}
                        | - Custom timer for counterbias
                        } else /if (${Me.Class.Name.Equal[Shaman]} && ${DPSPart1.Find[counterbias]}) {
                            /varset DPSTimer${i} 1.5m
                        | Custom timer for Chanter suffocation
                        } else /if (${Me.Class.Name.Equal[enchanter]} && ${DPSPart1.Find[suffocation]}) {
                            /varset DPSTimer${i} 1m
                        | Custom timer for Beastlord Feralgia Timer
                        } else /if (${Me.Class.Name.Equal[Beastlord]} && ${DPSPart1.Find[feralgia]}) {
                            /varset DPSTimer${i} 1.5m
                        | Regular spells
                        } else /if (${Spell[${DPSPart1}].Duration.TotalSeconds}>0) {
                            /varcalc DPSTimer${i} ${Spell[${DPSPart1}].Duration.TotalSeconds}*10
                        | Spells with no timers assign DPS interval
                        } else {
                            /varset DPSTimer${i} ${DPSInterval}s
                        }
                    | AA timers
                    } else /if (${Me.AltAbility[${DPSPart1}]}) {
                        /if (${Me.AltAbility[${DPSPart1}].Spell.Duration.TotalSeconds}) {
                            /varcalc DPSTimer${i} ${Me.AltAbility[${DPSPart1}].Spell.Duration.TotalSeconds}*10
                        } else /if (${Me.AltAbility[${DPSPart1}].Spell.Trigger.Duration.TotalSeconds}) {
                            /varcalc DPSTimer${i} ${Me.AltAbility[${DPSPart1}].Spell.Trigger.Duration.TotalSeconds}*10
                        }
                    | Disc Timers
                    } else /if (${Spell[${DPSPart1}].Duration}>0 && ${Me.CombatAbility[${DPSPart1}]}) {
                        /varcalc DPSTimer${i} ${Spell[${DPSPart1}].Duration.TotalSeconds}*10
                    | AA and disc with no timers assign DPS interval
                    } else {
                        /varset DPSTimer${i} ${DPSInterval}s
                    }
                } else /if (${MacroReturn.Left[13].Equal[CAST_RESISTED]}) {
                    |/echo ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} << - RESISTED
                    /echo ** ${Spawn[${DPSTargetID}].CleanName} - RESISTED - ${LastResisted}
                    /if (${DPSPart3.Length} && (${DPSPart3.Equal[once]} || ${DPSPart3.Equal[maonce]})) {
                        /varset DPSTimer${i} 5m
                    }
                } else /if (${MacroReturn.Equal[CAST_TAKEHOLD]}) {
                    /echo ** ${DPSPart1} on >> ${Spawn[${DPSTargetID}].CleanName} << - DID NOT TAKE HOLD
                    /varset DPSTimer${i} 5m
                }
                /break
            }
            | This is the Bottom of the Outer Loop. Add additional checks needed before /next i entry.
            DEBUGCOMBAT CombatCast ${DPS[${i}].Arg[1,|]} ${Macro.Return} DPSTimer${i} ${DPSTimer${i}}
            /call CombatTargetCheck 1
            /if (${DPSStartID}!=${MyTargetID}) {
                /if (${IAmMA} && ${TargetSwitchingOn}) {
                    /return
                } else /if (${MeleeOn} && !${Me.Combat}) {
                    |Target Change Not in Combat
                    /return tcnc
                }
            }
            /if (${WeaveArray.Size}>0 && ${WeaveArray[1].NotEqual[null]} && (${Me.SpellInCooldown} || !${WeaveCheck})) /call CastWeave ${MyTargetID}
            /if (${MashArray.Size}>0 && ${MashArray[1].NotEqual[null]}) /call MashButtons
            /varset WeaveCheck 0
        /next i
        DEBUGCOMBAT CombatCast: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckStick
| -------------------------------------------------------------------------------------
    Sub CheckStick(int p_Flag1, int p_UseAttack)
        /declare _CampXLoc               int         local       ${CampXLoc}
        /declare _CampYLoc               int         local       ${CampYLoc}
        /declare _CampZLoc               int         local       ${CampZLoc}
        /declare navTimer timer local 0
        DEBUGCOMBAT CheckStick: Enter.
        DEBUGCOMBAT CheckStick0: 1:${Stick.Active} 2:!${IAmMA} 3:${MoveUtils.Aggro} 4:${StickHow} 5:${Me.FeetWet} 6:${ChaseAssist}
        
        /if (${ChaseAssist} || !${ReturnToCamp}) {
            /varset _CampXLoc ${Spawn[=${MainAssist}].X}
            /varset _CampYLoc ${Spawn[=${MainAssist}].Y}
            /varset _CampZLoc ${Spawn[=${MainAssist}].Z}
        }

        /if (${MeleeDistance}>${CampRadius}) {
            DEBUGCOMBAT CheckStick1: ${CampRadius} ${MeleeDistance} CFT: ${Math.Distance[${_CampYLoc},${_CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]} CFMA: ${Math.Distance[${_CampYLoc},${_CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]} TFMA: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}
            | Is Mob to far from camp?
            /if (${Math.Distance[${_CampYLoc},${_CampXLoc}:${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}]}>${MeleeDistance}) {
                | Is MA/Tank to far from camp?
                /if (${Math.Distance[${_CampYLoc},${_CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>${MeleeDistance}) {
                    /return
                } else {
                    | The Ma/Tank is close enough to engage, but is the Mob still to far from the tank?
                    /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>${CampRadius}) /return
                }
            }
            DEBUGCOMBAT CheckStick2: ${Spawn[id ${MyTargetID}].MaxRangeTo.Int} ${Spawn[id ${MyTargetID}].Distance}
            /if (${Spawn[id ${MyTargetID}].MaxRangeTo.Int}<${Spawn[id ${MyTargetID}].Distance}) {
                /if (${PullMoveUse.Equal[nav]}) {
                    /nav id ${MyTargetID}
                    /varset navTimer 30
                    /while (${navTimer}) {
                        /if (${Spawn[id ${MyTargetID}].MaxRangeTo.Int}>=${Spawn[id ${MyTargetID}].Distance}) {
                            /nav stop
                            /break
                        }
                    }
                    /if (${Navigation.Active}) /nav stop
                |}
                } else {
                    /moveto dist ${Spawn[id ${MyTargetID}].MaxRangeTo}
                }
            }
        }
        DEBUGCOMBAT CheckStick3: ${p_Flag1} ${p_UseAttack} ${Me.Combat} ${Me.State} ${UseMQ2Melee}
        /if (${p_UseAttack}) {
            /if (${UseMQ2Melee}) {
                /killthis
                /return
            } else {
                /if (!${Me.Combat} && ${Target.ID} && ${Select[${Me.State},stand,mount]}) /squelch /attack on
            }
        }
        
        /if (${MeleeDistance}>${CampRadius}) {
            /if (!${Select[${StickHow},0,I]}) {
                /if (!${p_Flag1}) {
                    /if (${Me.FeetWet}) {
                        /stick ${Math.Calc[${Spawn[id ${MyTargetID}].MaxRangeTo}-3]} id ${MyTargetID} ${StickHow} uw
                    } else {
                        /stick ${Spawn[id ${MyTargetID}].MaxRangeTo} id ${MyTargetID} ${StickHow}
                    }
                } else /if (${p_Flag1}==1) {
                    /if (${Target.ID} && ${Me.TargetOfTarget.ID}!=${Me.ID}) {
                        /if (${Me.FeetWet}) {
                            /stick id ${MyTargetID} ${StickHow} uw
                        } else {
                            /stick id ${MyTargetID} ${StickHow}
                        }
                    }
                }
            } else /if (${StickHow.NotEqual[I]}) {
                /if (!${p_Flag1}) {
                    /if (${Me.FeetWet}) {
                        /stick ${Math.Calc[${Spawn[id ${MyTargetID}].MaxRangeTo}-3]} id ${MyTargetID} uw
                    } else {
                        /stick ${Spawn[id ${MyTargetID}].MaxRangeTo} id ${MyTargetID}
                    }
                } else /if (${p_Flag1}==1) {
                    /if (${Target.ID} && ${Me.TargetOfTarget.ID}!=${Me.ID}) {
                        /if (${Me.FeetWet}) {
                            /stick id ${MyTargetID} uw
                        } else {
                            /stick id ${MyTargetID}
                        }
                    }
                }
            }
        }
        DEBUGCOMBAT CheckStick: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Mash Buttons
| -------------------------------------------------------------------------------------
    Sub MashButtons(TarID)
        /if (${DPSOn}==0) /return
        /if (!${Select[${Me.State},stand,mount]}) /return
        /declare i int local
        /declare MashThis string local
        /declare MashThisArg3 string local
        /declare MashThisArg4 string local
        /if (${TargetSwitchingOn}) {
            /if (${IAmMA} && ${Target.ID} && ${Target.ID}!=${MyTargetID}) /call CombatTargetCheck 1
        } else /if (${Target.ID}!=${MyTargetID}) {
            /target id ${MyTargetID}
            /delay 10 ${Target.ID}==${MyTargetID}
        }
        /for i 1 to ${MashArray.Size}
            /varset MashThis ${MashArray[${i}].Arg[1,|]}
            /if (!${Bool[${MashThis}]} || !${Target.ID} || ${Target.Type.Equal[corpse]}) /return
            /if (!${ConOn} || !${MashArray[${i}].Find[|cond]} || ${If[${Cond[${MashArray[${i}].Mid[${Math.Calc[${MashArray[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
                /if (${FindItem[=${MashThis}].ID} && ${Me.ItemReady[${MashThis}]}) {
                    /useitem "${MashThis}"
                    /delay 2
                    /echo ## Mashing >> ${MashThis} <<
                } else /if (${Me.AltAbility[${MashThis}]} && ${Me.AltAbilityReady[${MashThis}]} && ${Me.AltAbility[${MashThis}].Type}!=5 && ${MashThis.NotEqual[twincast]})  {
                    /alt act ${Me.AltAbility[${MashThis}].ID}
                    /delay 2
                    /if (!${Me.AltAbilityReady[${MashThis}]}) /echo ## Mashing >> ${MashThis} <<
                } else /if (${Me.CombatAbility[${MashThis}]} && !${Me.CombatAbilityTimer[${MashThis}]} && ${Me.CombatAbilityReady[${MashThis}]} && ${Spell[${MashThis}].EnduranceCost}<${Me.Endurance}) {
                    /disc ${Me.CombatAbility[${Me.CombatAbility[${MashThis}]}].ID}
                    /delay 2
                   /if (!${Me.CombatAbilityReady[${MashThis}]}) /echo ## Mashing >> ${MashThis} <<
                } else /if (${Me.Skill[${MashThis}]} && ${Me.AbilityReady[${MashThis}]}) {
                    /doability "${MashThis}"
                    /delay 2
                    /if (!${Me.AbilityReady[${MashThis}]}) /echo ## Mashing >> ${MashThis} <<
                }
            }
        /next i
    /return 0
| -------------------------------------------------------------------------------------
| SUB: BeforeAttack
| -------------------------------------------------------------------------------------
    Sub BeforeAttack(TarID, int CondCheck)
        DEBUGCOMBAT BeforeAttack: Enter
        /declare i int local
        /declare UseThis string local
        /declare UseThisArg3 string local
        /declare UseThisArg4 string local
        /for i 1 to ${BeforeArray.Size}
            /varset UseThis ${BeforeArray[${i}].Arg[1,|]}
            /if (!${Bool[${UseThis}]} || !${Target.ID}) /return
            /if (!${BeforeArray[${i}].Find[|cond]} && ${CondCheck}==2) /continue
            /if (!${ConOn} || !${BeforeArray[${i}].Find[|cond]} || ${If[${Cond[${BeforeArray[${i}].Mid[${Math.Calc[${BeforeArray[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
                /if (${FindItem[=${UseThis}].ID} && ${Me.ItemReady[${UseThis}]}) {
                    /useitem "${UseThis}"
                    /echo ## Before Attack >> ${UseThis} <<
                } else /if (${Me.AltAbility[${UseThis}]} && ${Me.AltAbilityReady[${UseThis}]} && ${Me.AltAbility[${UseThis}].Type}!=5 && ${UseThis.NotEqual[twincast]})  {
                    /alt act ${Me.AltAbility[${UseThis}].ID}
                    /echo ## Before Attack >> ${UseThis} <<
                } else /if (${Me.CombatAbility[${UseThis}]} && !${Me.CombatAbilityTimer[${UseThis}]} && ${Me.CombatAbilityReady[${UseThis}]} && ${Spell[${UseThis}].EnduranceCost}<${Me.Endurance}) {
                    /disc ${Me.CombatAbility[${Me.CombatAbility[${UseThis}]}].ID}
                    /echo ## Before Attack >> ${UseThis} <<
                } else /if (${Me.Skill[${UseThis}]} && ${Me.AbilityReady[${UseThis}]}) {
                    /doability "${UseThis}"
                    /echo ## Before Attack >> ${UseThis} <<
                } else /if (${UseThis.Find[command:]}) {
                    /call CastCommand "${UseThis}" ${MyTargetID} 0
                }
                /delay 3
            }
        /next i
        DEBUGCOMBAT BeforeAttack: Leave
    /return 0
| -------------------------------------------------------------------------------------
| SUB: CombatPet
| -------------------------------------------------------------------------------------
    Sub CombatPet
        /declare i_TargetID int local 0
        DEBUGCOMBAT CombatPet: Enter - ${Me.Pet.ID} - ${Pet.Combat} - ${DPSPaused} - ${PetAttackRange}
        /if (!${Me.Pet.ID} || ${Pet.Combat} || ${DPSPaused} || !${PetCombatOn}) /return
        /if (${DPSMeter}) {
            /if (!${DPSAdv.MyStatus}) /DPSAdv mystart
        }
        /if (${Target.ID}) /varset i_TargetID ${Target.ID}
        /call CombatTargetCheck 1
        /if (${Pulling}) {
            /if (${Me.AltAbility[Summon Companion]}) {
                /if (${Me.AltAbilityReady[Summon Companion]}) {
                    /if (${Me.Pet.Distance}>79.00) {
                        /echo Pet! Get over here!
                        /call CastAA "Summon Companion" ${Me.Pet.ID} CombatPet
                    }
                }
            }
        }
        /if (${i_TargetID}!=${Target.ID}) {
            /delay 20 ${Target.BuffsPopulated}
        }
        /if (${Target.Mezzed.ID}) {
            /if (${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${PetBreakMezSpell.NotEqual[null]}) /call BreakMez
        }
        /if (!${Target.Mezzed.ID}) {
            /if (${Select[${Role},pettank,pullerpettank]}) {
                /if (${ReturnToCamp}) {
                    /if (${Me.Pet.Stance.NotEqual[FOLLOW]}) {
                        /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} || ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) {
                            /pet follow
                        } else /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius} && ${Spawn[${MyTargetID}].Distance3D}>${PetAttackRange}) {
                            /pet follow
                        }
                    }
                    /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius} && ${Spawn[${MyTargetID}].Distance3D}<${PetAttackRange}) {
                        /pet attack
                        /delay 5
                        /pet swarm
                    }
                } else {
                    /if (${Spawn[${MyTargetID}].Distance3D}<${PetAttackRange}) {
                        /pet attack
                        /delay 5
                        /pet swarm
                    } else {
                        /if (${Me.Pet.Stance.NotEqual[FOLLOW]}) /pet follow
                    }
                }
            } else {
                /if (${Spawn[${MyTargetID}].Distance3D}<${PetAttackRange}) {
                    /pet attack
                    /delay 5
                    /pet swarm
                } else {
                    /if (${Me.Pet.Stance.NotEqual[FOLLOW]}) /pet follow
                }
            }
            | Set timer to check if pet is attacking every 3s
            /varset PetAttack 30
        }
        DEBUGCOMBAT CombatPet: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: BreakMez - Written by Trehuggindruid for KissAssist
| -------------------------------------------------------------------------------------
    Sub BreakMez
        /if (${PetBreakMezSpell.Equal[null]}) /return
        DEBUGCOMBAT BreakMez: Enter
        /declare PetBreakMezTargetID int local ${MyTargetID}
        /echo ATTEMPTING TO BREAK MEZ ON: (${Target.CleanName}) ID:(${PetBreakMezTargetID})
        /while (${Target.Mezzed.ID}) {
            DEBUGCOMBAT Break Mez with: - ${PetBreakMezSpell}
            /call CastWhat "${PetBreakMezSpell}" ${PetBreakMezTargetID} BreakMez 0 0
            |--- DO NOT CHANGE THIS CONDITION!!!!!!
            /if (${Target.Mezzed.ID}) {
                DEBUGCOMBAT Mez NOT broken, trying again!
            }
        }
        /varset PetAttack 0
        /echo + Mez broken !
        |/if (${Me.Pet.ID} && !${Me.Pet.Combat}) /pet attack
        DEBUGCOMBAT BreakMez: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CombatReset
| -------------------------------------------------------------------------------------
    Sub CombatReset(int SFlag, string CalledFrom)
        DEBUGCOMBAT CombatReset: Enter ${SFlag} ${CalledFrom}
        /declare DPSCalc string local
        /declare DPSTCalc string local
        /declare DPSMyDam string local
        /declare DPSPCalc string local
        /declare DPSPTCalc string local
        /declare DPSMyPetDam string local
        /declare DPSMeAndPetDam string local
        /declare DPSMPCalc string local
        /declare DPSMPTCalc string local
        /declare i int local
        /declare j int local
        /if (!${MyTargetID} && ${LastTargetID}) /varset MyTargetID ${LastTargetID}
        /if (${MyTargetID} && ${CombatStart} && ${DPSMeter} && !${SFlag}) {
            /echo SLAIN >> ${MyTargetName} <<
            /echo EXP: ${If[${Me.PctExp}<${MyExp},${Math.Calc[100-${MyExp}+${Me.PctExp}]},${Math.Calc[${Me.PctExp}-${MyExp}]}]}% AAEXP: ${If[${Me.PctAAExp}<${MyAAExp},${Math.Calc[100-${MyAAExp}+${Me.PctAAExp}]},${Math.Calc[${Me.PctAAExp}-${MyAAExp}]}]}%
            /popup SLAIN >> ${MyTargetName} << EXP: ${If[${Me.PctExp}<${MyExp},${Math.Calc[100-${MyExp}+${Me.PctExp}]},${Math.Calc[${Me.PctExp}-${MyExp}]}]}% AAEXP: ${If[${Me.PctAAExp}<${MyAAExp},${Math.Calc[100-${MyAAExp}+${Me.PctAAExp}]},${Math.Calc[${Me.PctAAExp}-${MyAAExp}]}]}%
            /if (!${DPSAdv.TimeElapsed} || ${DPSAdv.MyStatus}) {
                /echo DPS Meter: Was a timing error skipping DPS Meter
                /DPSAdv myreset
            } else {
                /echo \aw DPS Meter - \ay Your Total Damage: \at ${DPSAdv.MyDamage.Prettify} - \ay Fight Time: \aw ${DPSAdv.TimeElapsed}s - \ay DPS: \ag ${DPSAdv.MyDPS.Prettify}
                /if (!${DPSAdv.PetDamage}) {
                    /call BroadCast r "${Me}'s DPS: ${DPSAdv.MyDPS.Prettify}"
                } else {
                    /echo \aw DPS Meter - \ay Pet Total Damage: \at ${DPSAdv.PetDamage.Prettify} \ay - Pet DPS: \ag ${DPSAdv.PetDPS.Prettify}
                    /call BroadCast r "${Me}'s DPS: ${DPSAdv.MyDPS.Prettify} + Pet = Total: ${DPSAdv.TotalDPS.Prettify}"
                    /echo \aw DPS Meter - \ay You + Pet Total Damage: \at ${DPSAdv.TotalDamage.Prettify} \ay - DPS: \ag ${DPSAdv.TotalDPS.Prettify}
                }
                /popup Total Damage: ${DPSAdv.TotalDamage.Prettify} - Fight Time: ${DPSAdv.TimeElapsed}s - DPS: ${DPSAdv.TotalDPS.Prettify}
                /if (${Defined[ParseDPS]} || ${DPSWriteOn}) {
                    /ini "Kissassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-${Me.Class}-${Me.Level}" "Total Damage: ${DPSAdv.MyDamage.Prettify} - Fight Time: ${DPSAdv.ElapsedTime}s - DPS: ${DPSAdv.MyDPS.Prettify}"
                    /if (${DPSAdv.PetDamage}) {
                        /ini "Kissassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-MyPet" "My Pet Total Damage: ${DPSAdv.PetDamage.Prettify} - Pet DPS: ${DPSAdv.PetDPS.Prettify}"
                        /ini "Kissassist_DPS" "${MyTargetName}-${MyTargetID} - ${Time.Month}/${Time.Day}/${Time.Year}-${Time.Time12}" "DPS-Combined" "Me + Pet Total Damage: ${DPSAdv.TotalDamage.Prettify} - Combined DPS: ${DPSAdv.TotalDPS.Prettify}"
                    }
                }
            }
        }
        /call MobRadar los ${MeleeDistance} CombatReset
        |/for j 1 to 50
        |    /if (${AddsArray[${j},1].Equal[${MyTargetID}]}) /call RemoveFromArray AddsArray ${j}
        |    /if (${MobCount}==0) /call RemoveFromArray AddsArray ${j}
        |    /if (${MezOn} && ${j}<=13) {
        |        /if (${MezArray[${j},1].Equal[${MyTargetID}]}) {
        |            /call RemoveFromArray MezArray ${j}
        |        } else /if (${MezArray[${j},1].NotEqual[NULL]}) {
        |            /if (!${Spawn[${MezArray[${j},1]}].ID} || ${Spawn[${MezArray[${j},1]}].Type.Equal[Corpse]}) /call RemoveFromArray MezArray ${j}
        |        }
        |    }
        |/next j
        /if (${MezOn}) {
            /for j 1 to ${XSlotTotal}
                /if (${MezArray[${j},1].Equal[${MyTargetID}]}) {
                    /call RemoveFromArray MezArray ${j}
                } else /if (${MezArray[${j},1].NotEqual[NULL]}) {
                    /if (!${Spawn[${MezArray[${j},1]}].ID} || ${Spawn[${MezArray[${j},1]}].Type.Equal[Corpse]}) /call RemoveFromArray MezArray ${j}
                }
            /next j
        
            /if (${MezImmuneIDs.Find[|${MyTargetID}]}) /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MyTargetID},]}
            /varset j 1
            /while (${Bool[${MezImmuneIDs.Arg[${j},|].Length}]}) {
                /if (!${Bool[${Spawn[${MezImmuneIDs.Arg[${j},|]}].ID}]} || ${Spawn[${MezImmuneIDs.Arg[${j},|]}].Type.Equal[corpse]} ) {
                    /varset MezImmuneIDs ${MezImmuneIDs.Replace[|${MezImmuneIDs.Arg[${j},|]},]}
                } else {
                    /varcalc j ${j}+1
                }
            }
            /varset MezMobDone 0
        }
        /if (${MobsToIgnoreByID.NotEqual[null]}) {
            /varset j 1
            /while (${Bool[${MobsToIgnoreByID.Arg[${j},|].Length}]} && ${MobsToIgnoreByID.Arg[${j},|].NotEqual[null]}) {
                /if (!${Bool[${Spawn[${MobsToIgnoreByID.Arg[${j},|]}].ID}]} || ${Spawn[${MobsToIgnoreByID.Arg[${j},|]}].Type.Equal[corpse]} ) {
                    /varset MobsToIgnoreByID ${MobsToIgnoreByID.Replace[|${MobsToIgnoreByID.Arg[${j},|]},]}
                } else {
                    /varcalc j ${j}+1
                }
            }
        }
        /varset CalledTargetID 0
        /varset AggroTargetID2 0
        /if (${Defined[DPSTimeStart${MyTargetID}]}) /deletevar DPSTimeStart${MyTargetID}
        /varset MyTargetID 0
        /varset MyTargetName
        /varset LastTargetID 0
        /varset ValidTarget 0
        /varset MercAssisting 0
        /varset CombatStart 0
        /varset Pulled 0
        /varset NamedCheck 0
        /if (${Role.Find[puller]}) {
            /call PullReset
        } else {
            /moveto dist 10
            /if (${MoveTo.Moving}) /moveto off
            /if (${PullMoveUse.Equal[nav]}) {
                /if (${Navigation.Active}) /nav stop
            }
        }
        /if (${UseMQ2Melee}) /squelch /melee melee=0
        /squelch /attack off
        /if (${Me.AutoFire}) /autofire
        /if (${AutoFireOn}==2) /varset AutoFireOn 1
        /squelch /target clear
        DEBUGCOMBAT CombatReset In Group Check: ${Group.Member[${MainAssist}].Index} !${IAmMA} ${XTSlot}
        /if (${XTarAutoSet} && !${Me.Hovering}) {
            /if (!${Group.Member[${MainAssist}].Index} && !${IAmMA}) /xtarget set ${XTSlot} autohater
        }
        /if (${DPSOn}) {
            /for i 1 to ${DPS.Size}
                /if (${Int[${DPS[${i}].Arg[2,|]}]}<101) {
                    /varset DPSTimer${i} 0
                    /varset FDTimer${i}  0
                }
            /next i
        }
        /if (${Me.Pet.ID}) {
            /varset PetAttack 0
            /pet back off
            /if (${PetHoldOn}) /pet ${PetHold} on
        }
        /if (${DebuffAllOn} && ${DebuffCount}) {
            /varset j 0
            /for i 1 to ${XSlotTotal}
                /if (${Me.XTarget[${i}].ID} && ${Me.XTarget[${i}].TargetType.Equal[Auto Hater]} && ${Me.XTarget[${i}].Type.NotEqual[Corpse]} && ${Me.XTarget[${i}].Distance}<=${MeleeDistance}) /varcalc j ${j}+1
            /next i
            /if (${j}==0) {
                /for i 1 to ${DebuffCount}
                    /varset DBOTimer${i} 0
                    /varset DBOList${i}
                /next i
            }
        }
        /varset Attacking 0
        /varset BurnActive 0
        /varset DPSTarget 0
        /if (${BurnID} && (!${Spawn[id ${BurnID}].ID} || ${Spawn[id ${BurnID}].Type.Equal[corpse]})) {
            /varset BurnCalled 0
            /varset BurnID 0
            /echo Burn Target is Dead. Turning Burn off.
        }
        /if (!${TwistOn} && ${MeleeTwistOn}) /varset DPSTwisting 0
        /if (${LootOn} && !${SFlag}) {
            /delay 10
            /call LootStuff
            /if (${IAmABard}) {
                /call CastBardCheck
            }
        }
        /if (${IAmABard}) /call DoBardStuff
        /if (!${IAmMA} && ${TargetSwitchingOn}) /varset TargetSwitchingOn 0
        /varset TankTimer 30s
        DEBUGCOMBAT CombatReset: Leave
        /varset PetFollowTimer 60s
        /delay 2s ${AggroOffTimer}==0
        /while (1) {
            /varset EventFlag 0
            /doevents Timer
            /if (!${EventFlag}) /break
        }
        /while (1) {
            /varset EventFlag 0
            /doevents 
            /if (!${EventFlag}) /break
        }
        /if (${Stick.Active} && ${Stick.StickTarget}!=${If[${Spawn[=${WhoToChase}].Type.Equal[Pet]},${Spawn[=${WhoToChase}].Master.ID},${Spawn[=${WhoToChase}].ID}]}) /stick off
        /if (${UseMQ2Melee}) /squelch /melee melee=1
        /if (${Select[${Me.Class.ShortName},ROG]}) /call Roguestuff
    /return
| -------------------------------------------------------------------------------------
| SUB: Check for Adds
| -------------------------------------------------------------------------------------
    Sub CheckForAdds(CalledFrom)
        DEBUGN  CheckForAdds: Enter from ${CalledFrom}
        /call MobRadar los ${MeleeDistance} CheckForAdds
        DEBUGN MobCount:${MobCount}
        | If no mobs, in a DMZone or pulling Leave
        /if (${MobCount}<=1)  /return
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Pulling}) /return
        /if (!${DPSOn} && !${MeleeOn}) /return
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius}) /return
        /if (${IAmDead}) /return
        /if (${ChainPull}==2 || ${DPSPaused}) /return
        | If I have a valid living target in camp radius Leave
        /if (!${Target.ID} && ${MyTargetID} && ${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance}<${CampRadius}) {
            /squelch /target id ${MyTargetID}
            /return
        }
        | Spam Adds in camp
        /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<=${CampRadius} && !${MyTargetID} && !${AddSpam}) {
            /popup Add(s) in camp detected
            /if (${IAmMA} || ${Select[${Role},tank,pullertank,pettank,pullerpettank]}) /call BroadCast r "Add(s) in camp detected"
            /if (${Select[${Role},pullertank,pullerpettank]}) /varset Pulled 0
            /varset AddSpam 5s
        }
        | Prevent puller from stalling if adds in camp and still returning from pulling mob.
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Pulled} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>=15) /return
        /if (!${Target.ID} && ${Select[${Role},tank,pullertank,pettank,pullerpettank,hunter,hunterpettank]}) /squelch /target ID ${Spawn[${AggroTargetID}].ID}
        /if (${Target.Type.NotEqual[npc]} && ${MyTargetID}) {
            /if (!${Spawn[${MyTargetID}].ID} || ${Spawn[${MyTargetID}].Type.Equal[corpse]}) {
                /varset LastTargetID ${MyTargetID}
                /varset MyTargetID 0
            }
            /squelch /target clear
            /return
        }
        DEBUGN CheckForAdds: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: AggroCheck
| -------------------------------------------------------------------------------------
    Sub AggroCheck
        /if (!${Me.HaveExpansion[Rain of Fear]} || ${Target.Type.Equal[corpse]} || ${Defined[ParseDPS]}) /return
        DEBUGCOMBAT AggroCheck Enter ${MyTargetID}
        /declare i            int    local
        /declare AggroSpell   string local
        /declare AggroGLT     string local
        /declare AggroPCT     int    local
        /declare AggroTarget  string local
        /declare AggroTID     int    local
        /if (${IAmMA} && ${TargetSwitchingOn} && ${Target.ID} && ${Target.ID}!=${MyTargetID} && ${CombatStart}) /call CombatTargetCheck 1
        /if (!${MyTargetID}) /return
        /for i 1 to ${Aggro.Size}
            /if (${Target.Type.Equal[corpse]} || !${Target.ID}) /break
            /varset AggroSpell ${Aggro[${i}].Arg[1,|]}
            /varset AggroPCT ${Aggro[${i}].Arg[2,|]} 
            /varset AggroGLT ${Aggro[${i}].Arg[3,|]}
            /varset AggroTarget ${Aggro[${i}].Arg[4,|]}
            /if (${AggroTarget.Left[4].Equal[cond]}) /varset AggroTarget null
            /if (${AggroGLT.Equal[<<]}) /varcalc AggroPCT ${AggroPCT}-100
            DEBUGCOMBAT AggroCheck ${Me.PctAggro} ${AggroGLT} ${AggroPCT} ${AggroSpell} ${Target.SecondaryPctAggro} ${AggroGLT.Equal[<<]}
            /if (${ConOn} && ${Aggro[${i}].Find[|cond]} && ${If[${Cond[${Aggro[${i}].Mid[${Math.Calc[${Aggro[${i}].Find[|cond]}+5]},3]}]},0,1]}) /continue
            /if (${Me.SpellReady[${AggroSpell}]} || ${Me.AltAbilityReady[${AggroSpell}]} || ${Me.AbilityReady[${AggroSpell}]} || ${Me.CombatAbilityReady[${AggroSpell}]}) {
                | If I need to Gain more Aggro. My Aggro Check.
                /if (${AggroGLT.Equal[<]}) {
                    /if (${AggroPCT}<=${Me.PctAggro}) /continue
                | If I need to Gain more Aggro. Secondary Aggro Check.
                } else /if (${AggroGLT.Equal[<<]}) {
                    /if (!${Target.SecondaryPctAggro} || ${Target.SecondaryPctAggro}<${AggroPCT}) /continue
                | If I need to Loose Aggro    
                } else /if (${AggroGLT.Equal[>]}) {
                    /if (${AggroPCT}>${Me.PctAggro}) {
                        /continue
                    }
                } else {
                    /continue
                }
                /if (${Me.CombatAbility[${AggroSpell}]} && (${Spell[${AggroSpell}].Duration} && ${Spell[${AggroSpell}].TargetType.Equal[self]} && ${Me.ActiveDisc.ID})) /continue
                DEBUGCOMBAT Trying to control Aggro: ${Me.PctAggro} ${AggroGLT} ${AggroPCT} ${AggroSpell}
                /if (${Select[${AggroTarget},null,Mob]} || (${AggroTarget.Equal[INC]} && ${Spawn[${MyTargetID}].Distance}>${MeleeDistance})) {
                    /varset AggroTID ${MyTargetID}
                } else /if (${AggroTarget.Equal[Me]}) {
                    /varset AggroTID ${Me.ID}
                } else /if (${AggroTarget.Equal[MA]}) {
                    /varset AggroTID ${Spawn[=${MainAssist}].ID}
                } else /if (${AggroTarget.Equal[Pet]}) {
                    /varset AggroTID ${Me.Pet.ID}
                } 
                /if (${AggroTarget.Equal[INC]} && ${Spawn[${MyTargetID}].Distance}<${MeleeDistance}) /continue
                /if (!${AggroTID}) /continue
                /call CastWhat "${AggroSpell}" ${AggroTID} Aggro 0 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting >> ${AggroSpell} << to control AGGRO(${AggroGLT}) on ${Spawn[${AggroTID}].CleanName}.
                    /if (${AggroGLT.Equal[>]}) {
                        /if (!${AggroOffTimer}) {
                           /if (${Me.Feigning} || ${Me.Invis}) /varset AggroOffTimer 20
                        }
                    }
                    /break
                }
                /if (${AggroGLT.Equal[>]} && ${AggroPCT}>${Me.PctAggro}) /break
                /if (${AggroGLT.Equal[<<]} && ${Target.SecondaryPctAggro}<${AggroPCT}) /break
                /if (${AggroGLT.Equal[<]} && ${AggroPCT}<${Me.PctAggro}) /break
            }
        /next i
        DEBUGCOMBAT AggroCheck Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CastReady
| -------------------------------------------------------------------------------------
    Sub CastReady(string castWhat,string sentFrom)
        /varset SpellReadyL 0
        /if (!${Bool[${castWhat}]}) /return 0
        /if (${sentFrom.Equal[rezwithcheck]}) {
            /if (${Select[TRUE,${Me.AltAbilityReady[${castWhat}]},${Me.ItemReady[=${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]}]}==0) {
                /if (${Me.Book[${castWhat}]}) {
                    /if (!${Me.Gem[${castWhat}]}) {
                        /varset SpellReadyL 5
                        /return ${SpellReadyL}
                    }
                }
            }
        } else /if (${sentFrom.Equal[singleheal]} || ${sentFrom.Equal[groupheal]}) {
            /if (${Me.Gem[${castWhat}]}) {
                /while (${Me.SpellInCooldown}) {
                    /delay 2
                }
            }
        }
        /varset SpellReadyL ${Select[TRUE,${Me.AltAbilityReady[${castWhat}]},${Me.ItemReady[=${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${Me.AbilityReady[${castWhat}]},${Me.SpellReady[${castWhat}]}]}
    /return ${SpellReadyL}
| -------------------------------------------------------------------------------------
| SUB: CastWhat
| -------------------------------------------------------------------------------------
    Sub CastWhat(string castWhat,int WhatID,string sentFrom,int CondNumber, int miscFlag)
        DEBUGCAST CastWhat Enter \aw ${castWhat} ID: ${WhatID} Target:${Spawn[id ${WhatID}].CleanName} SentFrom: ${sentFrom} Cond: ${CondNumber}
        /if (!${IAmABard} && ${Me.Casting.ID} && ${Window[CastingWindow].Open}) /return CAST_CASTING
        /declare ReadyToCast       int      local 0
        /declare MemReturn         string   local null 
        /declare EventsCalcTimer   timer    local 0
        /declare str_TargetType    string   local ${Spell[${castWhat}].TargetType}
        /varset castReturn X
        /varset CastResult CAST_NO_RESULT
        /if (${castWhat.Find[command:]} || ${Me.AltAbility[${castWhat}]} || ${Me.CombatAbility[${castWhat}]} || ${FindItem[=${castWhat}].ID} || ${Me.Skill[${castWhat}]} || ${Me.Book[${castWhat}]}) {
            /if (${IAmABard}) {
                /varset ReadyToCast ${Select[TRUE,${Me.ItemReady[=${castWhat}]},${Me.AltAbilityReady[${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${If[${Me.AbilityReady[${castWhat}]} && ${Me.Skill[${castWhat}]},TRUE,FALSE]},${If[${Me.Gem[${castWhat}]} && ${Me.GemTimer[${castWhat}]}==0,TRUE,FALSE]},${Bool[${castWhat.Find[command:]}]}]}
                DEBUGCAST CastWhat \aw ${Me.ItemReady[=${castWhat}]},${Me.AltAbilityReady[${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${If[${Me.AbilityReady[${castWhat}]} && ${Me.Skill[${castWhat}]},TRUE,FALSE]},${If[${Me.Gem[${castWhat}]} && ${Me.GemTimer[${castWhat}]}==0,TRUE,FALSE]},${Bool[${castWhat.Find[command:]}]}
            } else {
                /varset ReadyToCast ${Select[TRUE,${Me.ItemReady[=${castWhat}]},${Me.AltAbilityReady[${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${If[${Me.AbilityReady[${castWhat}]} && ${Me.Skill[${castWhat}]},TRUE,FALSE]},${Me.SpellReady[${castWhat}]},${Bool[${castWhat.Find[command:]}]}]}
                DEBUGCAST CastWhat \aw ${Me.ItemReady[=${castWhat}]},${Me.AltAbilityReady[${castWhat}]},${Me.CombatAbilityReady[${castWhat}]},${If[${Me.AbilityReady[${castWhat}]} && ${Me.Skill[${castWhat}]},TRUE,FALSE]},${Me.SpellReady[${castWhat}]},${Bool[${castWhat.Find[command:]}]}
            }
            | Check for gems stuck or spell in book but not memed.
            /if (${ReadyToCast}==0 || ${Me.Casting.ID}) {
                /if (${Me.Book[${castWhat}]}) {
                    /if (!${IAmABard} && ${Me.Casting.ID} && !${Window[CastingWindow].Open}) {
                        /if (${CheckStuckGem}) /call CheckStuckGems
                        /if (${Me.Gem[${castWhat}]}) {
                            /varset ReadyToCast 5
                        } else {
                            /varset ReadyToCast 7
                        }
                    } else /if (!${FindItem[=${castWhat}].ID} && !${Me.Gem[${castWhat}]} && !${Me.AltAbility[${castWhat}]}) {
                        /varset ReadyToCast 7
                    }
                }
            }
            /if (${ReadyToCast}) {
                /if (${str_TargetType.Equal[null]}) {
                    /if (${ReadyToCast}==1) {
                        /varset str_TargetType ${FindItem[=${castWhat}].Spell.TargetType}
                    }
                }
                DEBUGCAST CastWhat \aw Target Info !${Target.ID} ${Target.ID}!=${WhatID} ${Spawn[id ${WhatID}].ID} ${ReadyToCast} ${str_TargetType}
                | Check if Castwhat has a conditon attached to it.
                /if (${CondNumber}) {
                    /if (${Cond[${CondNumber}].Find[TARGETCHECK]}) {
                        /if (${str_TargetType.NotEqual[Self]} && (!${Target.ID} || (${Target.ID}!=${WhatID} && ${Spawn[id ${WhatID}].ID}))) /call CastTarget ${WhatID}
                    }
                    /if (${If[${Cond[${CondNumber}]},0,1]}) /return CAST_COND_FAILED
                }
                /if (${str_TargetType.NotEqual[Self]} && (!${Target.ID} || (${Target.ID}!=${WhatID} && ${Spawn[id ${WhatID}].ID}))) /call CastTarget ${WhatID}
                | Check target for dps effects and stacking issues to prevent overcasting.
                /if (${sentFrom.Equal[DPS]} && ${Spell[${castWhat}].SpellType.Equal[Detrimental]}) {
                    /if (!${Me.CombatAbilityReady[${castWhat}]} && !${Me.AbilityReady[${castWhat}]} && (${Me.AltAbilityReady[${castWhat}]} || ${Me.SpellReady[${castWhat}]})) {
                        /call CastDPSSpellCheck "${castWhat}"
                        DEBUGCAST CastWhat ${Macro.Return}
                        /if (${Macro.Return}) {
                            DEBUGCAST CastWhat --${castWhat} is already on Mob. Skipping.
                            /return ${CastResult}
                        }
                    }
                | Check target for buffs and stacking issues to prevent overcasting.
                } else /if (${sentFrom.Find[Buffs]} && ${Spell[${castWhat}].SpellType.Find[Beneficial]} && ${WhatID}!=${Me.ID}) {
                    /call CastBuffsSpellCheck "${castWhat}"
                    DEBUGCAST CastWhat ${Macro.Return}
                    /if (${Macro.Return}) {
                        DEBUGCAST CastWhat --${castWhat} is already on Target. Skipping.
                        /varset CastResult CAST_HASBUFF
                        /varset HasBuffDuration ${Int[${Macro.Return}]}
                        /return ${CastResult}
                    }
                } else /if (${sentFrom.Find[pull]} && ${PullAggroTargetID}) {
                    /return
                }
                | Stop moving to Prevent cast interruption.
                /if (${Spell[${castWhat}].CastTime} && ${Me.Moving} && !${IAmABard}) /call StopMoving
                | Check Castwhat for type item/aa/disc/skill/spell/command and send to correct sub
                DEBUGCAST CastWhat 2: --${castWhat} ${ReadyToCast} ${Me.SpellReady[${castWhat}]} && ${Me.Book[${castWhat}]} ${Me.Gem[${castWhat}]} && ${Me.GemTimer[${castWhat}]}==0
                /if (${ReadyToCast}==1 && ${Me.ItemReady[=${castWhat}]} && ${FindItem[=${castWhat}].ID}) {
                    /call CastItem "${castWhat}" ${WhatID} ${sentFrom}
                } else /if (${ReadyToCast}==2 && ${Me.AltAbilityReady[${castWhat}]} && !${FindItem[=${castWhat}].ID}) {
                    /call CastAA "${castWhat}" ${WhatID} ${sentFrom}
                } else /if (${ReadyToCast}==3 && ${Me.CombatAbilityReady[${castWhat}]} && ${Spell[${castWhat}].EnduranceCost}<${Me.Endurance}) {
                    /call CastDisc "${castWhat}" ${WhatID} ${sentFrom} 
                } else /if (${ReadyToCast}==4 && ${Me.AbilityReady[${castWhat}]}) {
                    /call CastSkill "${castWhat}" ${WhatID} ${sentFrom}
                } else /if (${ReadyToCast}==5) {
                    /if (${Spell[${castWhat}].Mana}<${Me.CurrentMana}) {
                        /if (${Me.SpellReady[${castWhat}]} && ${Me.Book[${castWhat}]}) {
                            /call CastSpell "${castWhat}" ${WhatID} ${sentFrom} ${miscFlag}
                        } else /if (${IAmABard} && ${Me.Gem[${castWhat}]} && !${Me.GemTimer[${castWhat}]}) {
                            /call CastSpell "${castWhat}" ${WhatID} ${sentFrom} ${miscFlag}
                        }
                        /varset MemReturn ${CastResult}
                    } else {
                        /varset CastResult CAST_NEEDMANA
                        /varset MemReturn CAST_NO_RESULT
                        |/return ${CastResult}
                    }
                } else /if (${ReadyToCast}==6 && ${castWhat.Find[command:]}) {
                    /call CastCommand "${castWhat}" ${WhatID}
                } else /if (${ReadyToCast}==7) {
                    /if (!${sentFrom.Find[combat]}) {
                        /if (${Spell[${castWhat}].Mana}<${Me.CurrentMana}) {
                            /call CastMem "${castWhat}" ${sentFrom}
                            /varset MemReturn ${Macro.Return}
                            /if (${Macro.Return.NotEqual[notready]} && ${Me.Gem[${castWhat}]}!=0) {
                                /call CastSpell "${castWhat}" ${WhatID} ${sentFrom} ${miscFlag}
                            }
                        } else {
                            /varset CastResult CAST_NEEDMANA
                            /varset MemReturn notready
                        }
                    } else {
                        /varset CastResult CAST_NO_RESULT
                        /varset MemReturn notready
                    }
                }
                /if (${sentFrom.Find[pull]} && ${PullAggroTargetID}) /return CAST_SUCCESS
                | Remem spell originally in Miscgem slot except if combat or just rezd
                | 0nly need to do this if ReadyToCast had a value other than 0.
                /if (${MiscGemRemem}) {
                    /if (${ReadyToCast}==7 && ${MemReturn.NotEqual[notready]}) {
                        /call CastReMem "${castWhat}" 0 ${sentFrom}
                    } else /if (${ReadyToCast}==5 && ${MemReturn.NotEqual[CAST_NO_RESULT]} && (${ReMemWaitLong.Equal[${castWhat}]} || ${ReMemWaitShort.Equal[${castWhat}]})) {
                        /call CastReMem "${castWhat}" 0 ${sentFrom}
                    }
                }
                /if (${IAmABard}) {
                    /if (!${Twist} && ${Twist.List.Length}) {
                        /if (${DPSTwisting}) {
                            /if (${Target.ID}==${Me.ID} || ${MyTargetID}!=${Target.ID}) {
                                /if (${MyTargetID}) {
                                    /target id ${MyTargetID}
                                } else {
                                    /target clear
                                }
                                /delay 5
                            }
                        }
                        /squelch /twist
                    }
                }
                /varset SitToMedTimer ${SitToMedTimer.OriginalValue}
            } else {
                /varset CastResult CAST_RECOVER
            }
        }
        DEBUGCAST CastWhat \aw Leave ${CastResult}
    /return ${CastResult}
| -------------------------------------------------------------------------------------
| SUB: CastWait
|--------------------------------------------------------------------------------------
    Sub CastWait(string WaitSpell,string sentFrom)
        DEBUGCAST CastWait Enter ${WaitSpell} ${Spell[${WaitSpell}].CastTime}
        /if (${Spell[${WaitSpell}].CastTime}) {
            /if (!${Me.Casting.ID} || !${Window[CastingWindow].Open}) /delay 5
            /while (${Me.Casting.ID} && ${Window[CastingWindow].Open}) {
                /if (${sentFrom.Find[pull]} && ${PullAggroTargetID}) {
                    /stopcast
                    /varset CastResult CAST_SUCCESS
                    /break
                }
                /delay 5
            }
        } else {
            /delay 5
            /varset CastResult CAST_SUCCESS
        }
        DEBUGCAST CastWait Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CastAA
|--------------------------------------------------------------------------------------
    Sub CastAA(string WhatAA,int WhatID,string sentFrom)
        DEBUGCAST CastAA Enter ${WhatAA} ${Me.AltAbility[${WhatAA}].Spell.CastTime}
        /if (${Select[${WhatAA},Banestrike,15073]} && !${Banestrike.Find[|${Target.Race}|]} && ${Spawn[${MyTargetID}].Distance3D}>70 && ${CombatStart}) /return
        /if (${Me.Invis} && !${Select[${sentFrom},SingleHeal,GroupHeal]}) {
            /varset CastResult CAST_CANCELLED
            /return CAST_CANCELLED
        }
        
        /if (${IAmABard}) {
            /if (${Me.AltAbility[${WhatAA}].Spell.CastTime}>0) {
                /call CastBardCheck 0
            } else {
                /call CastBardCheck 1
            }
        }
        /varset IAMCastingID ${Me.AltAbility[${WhatAA}].Spell.ID}
        /alt act ${Me.AltAbility[${WhatAA}].ID}
        DEBUGCAST Before While: ${WhatAA} ${IAMCastingID} ${Me.Casting.ID} ${Window[CastingWindow].Open}
        /if (${Me.AltAbility[${WhatAA}].Spell.CastTime}>0) /delay 10 ${Window[CastingWindow].Open}
        /while (1) {
            /call DoCastingEvents
            /if (${sentFrom.Find[pull]} && ${PullAggroTargetID}) {
                /varset castReturn CAST_SUCCESS
                /break
            }
            /if (!${IAmABard}) {
                /if (!${Me.AltAbilityReady[${WhatAA}]} && !${Me.Casting.ID}) {
                    /varset castReturn CAST_SUCCESS
                    /break
                } else /if (!${Me.Casting.ID}) {
                    /if (${castReturn.Equal[x]}) /call DoCastingEvents 2
                    /break
                }
            } else {
                | 1 - singing Quick Cast AA and AA NotReady
                | 3 - Not Singing Cast AA and AA NotReady and Not Casting.
                /if (!${Me.AltAbilityReady[${WhatAA}]}) {
                    /if ((${Me.Casting.ID} && ${Me.Casting.ID}!=${IAMCastingID}) || !${Me.Casting.ID}) {
                        /varset castReturn CAST_SUCCESS
                        /break
                    }
                | 4 - Not Singing Cast AA and AA NotReady and still Casting. Continue/DropThrough
                } else {
                    | 2 - singing Quick Cast AA and AA Still Ready
                    | 5 - Not Singing Cast AA and AA Ready and Not Casting.
                    /if ((${Me.Casting.ID} && ${Me.Casting.ID}!=${IAMCastingID}) || (!${Me.Casting.ID} || !${Window[CastingWindow].Open})) {
                        /call DoCastingEvents 10 1
                        /break
                    }
                    | 6 - Not Singing Cast AA and AA Ready and still Casting. Continue/DropThrough
                }
                /if (!${Me.Casting.ID} || ${Me.Casting.ID}!=${IAMCastingID} || !${Window[CastingWindow].Open}) {
                    /break
                }
            }
        }
        /varset CastResult ${castReturn}
        DEBUGCAST After While: ${WhatAA} ${IAMCastingID} ${castReturn} ${WasTwisting}
        |/if (${IAmABard}) {
        |    /if (${WasTwisting} && !${Twist}) /squelch /twist 
        |}
        DEBUGCAST CastAA Leave ${CastResult} ${Me.AltAbilityReady[${WhatAA}]}
    /return ${CastResult}
|--------------------------------------------------------------------------------------
| SUB: CastItem
|--------------------------------------------------------------------------------------
    Sub CastItem(string WhatItem,int WhatID,string sentFrom)
        /declare ItemCastTime float local 0
        DEBUGCAST CastItem Enter
        | Prevent casting of Prestige items on silver and F2P accounts
        /if (${Me.Subscription.NotEqual[gold]} && ${FindItem[=${WhatItem}].Prestige}) /return CAST_NO_RESULT
        /if (${Me.Invis} && !${Select[${sentFrom},SingleHeal,GroupHeal]}) {
            /varset CastResult CAST_CANCELLED
            /return CAST_CANCELLED
        }
        /varset ItemCastTime ${FindItem[=${WhatItem}].Clicky.CastTime.Float}
        /if (${IAmABard}) {
            | only pause twisting if Item needs the spell casting window.
            /if (${ItemCastTime}>0) {
                /call CastBardCheck 0
            } else {
                /call CastBardCheck 1
            }
            DEBUGCAST I am a bard CastItem ${WhatItem} ${ItemCastTime}
        }
        /useitem "${WhatItem}"
        /if (${ItemCastTime}>0) {
            /delay 10 ${Window[CastingWindow].Open}
            /while (1) {
                /call DoCastingEvents
                /if (${sentFrom.Find[pull]} && ${PullAggroTargetID}) {
                    /varset CastResult CAST_SUCCESS
                    /break
                }
                /if (!${Me.Casting.ID} || !${Window[CastingWindow].Open}) /break 
            }
        } else {
            /call DoCastingEvents
        }
        DEBUGCAST CastItem ${ItemCastTime} ${FindItem[=${WhatItem}].Spell.ID} ${Me.Casting.ID} ${Window[CastingWindow].Open}
        /varset CastResult ${castReturn}
        | Assign cast success if item on cooldown or summoned item consumed
        /if (!${Me.ItemReady[=${WhatItem}]} || !${FindItem[=${WhatItem}].ID} && !${Select[${CastResult},CAST_IMMUNE,CAST_RESISTED]})  /varset CastResult CAST_SUCCESS
        /if (${IAmABard}) {
            /if (${ItemCastTime}>0) {
                /if (${Me.Casting.ID}) /stopcast
            }
            |/if (${WasTwisting} && !${Twist}) /squelch /twist 
        }
        DEBUGCAST CastItem Leave
    /return ${CastResult}
|--------------------------------------------------------------------------------------
| SUB: CastDisc
|--------------------------------------------------------------------------------------
    Sub CastDisc(string WhatDisc,int WhatID,string sentFrom)
        /declare WaitTimerCD timer local
        DEBUGCAST CastDisc ${WhatDisc} Enter
        /if (${Me.Invis} && !${Select[${sentFrom},SingleHeal,GroupHeal]}) {
            /varset CastResult CAST_CANCELLED
            /return CAST_CANCELLED
        }
        /if (!${Spell[${WhatDisc}].Duration} || (${Spell[${WhatDisc}].Duration} && ${Spell[${WhatDisc}].TargetType.Equal[Self]} && !${Me.ActiveDisc.ID}) || ${Spell[${WhatDisc}].TargetType.NotEqual[Self]} || ${Spell[${WhatDisc}].DurationWindow}) {
            DEBUGCAST Well we passed the CastDisc checks...
            /if (${Spell[${WhatDisc}].RecastTime.TotalSeconds}) {
                /if (${Spell[${WhatDisc}].RecastTime.TotalSeconds} < 3) {
                    /varset WaitTimerCD ${Spell[${WhatDisc}].RecastTime.TotalSeconds}s
                } else {
                    /varset WaitTimerCD 30
                }
            } else {
                /varset WaitTimerCD 10
            }
            DEBUGCAST CastDisk ${WhatDisc} ${Me.CombatAbilityReady[${WhatDisc}]} ${WaitTimerCD}
            /while (${Me.CombatAbilityReady[${WhatDisc}]} && ${WaitTimerCD}) {
                /if (${MacroQuest.Build}!=4) {
                    /disc ${Me.CombatAbility[${Me.CombatAbility[${WhatDisc}]}].ID}
                } else {
                    |in old clients /disc only accepts name not ID
                    /disc ${WhatDisc}
                }
                /delay 1
                /if (${MacroQuest.Build}!=4) {
                    /if (${Spell[${WhatDisc}].MyCastTime}) /call CastWait "${WhatDisc}"
                } else {
                    /if (${Spell[${WhatDisc}].RecastTimerID} == -1) {
                        |we cant wait here for this on emu CombatAbilityReady always return true
                        /break
                    }
                }
                /delay 10 !${Me.CombatAbilityReady[${WhatDisc}]}
            }
            /varset CastResult CAST_SUCCESS
        } else {
            DEBUGCAST CastDisk ${WhatDisc} Skipping.
        }
        DEBUGCAST CastDisc Leave
    /return ${CastResult}
|--------------------------------------------------------------------------------------
| SUB: CastCommand
|--------------------------------------------------------------------------------------
    Sub CastCommand(string WhatSkill,int WhatID)
        DEBUGCAST CastCommand Enter
        /declare CommandText string local ${WhatSkill.Right[-8]}
        DEBUGCAST "${CommandText}"
        /docommand ${CommandText}
        /delay 5
        /varset CastResult CAST_SUCCESS
        DEBUGCAST CastCommand Leave
    /return ${CastResult}
|--------------------------------------------------------------------------------------
| SUB: CastSkill
|--------------------------------------------------------------------------------------
    Sub CastSkill(string WhatSkill,int WhatID,string sentFrom)
        DEBUGCAST CastSkill Enter
        /if (${Me.Invis} && ${sentFrom.NotEqual[SingleHeal]}) {
            /varset CastResult CAST_CANCELLED
        } else {
            /doability "${WhatSkill}"
            /delay 20 !${Me.AbilityReady[${WhatSkill}]}
            /if (!${Me.AbilityReady[${WhatSkill}]}) /varset CastResult CAST_SUCCESS
            DEBUGCAST CastSkill Leave
        }
    /return ${CastResult}
|--------------------------------------------------------------------------------------
| SUB: CastSpell
|--------------------------------------------------------------------------------------
    Sub CastSpell(string WhatSpell,int WhatID,string sentFrom, int miscFlag)
        DEBUGCAST CastSpell Enter Line#: ${WhatSpell} ID:${WhatID} SentFrom:${sentFrom} ${Me.GemTimer[${WhatSpell}]}
        /declare MaxTryNum int local 2
        /declare TryNum int local 0
        /declare int_amIWasSitting bool local ${Me.Sitting}

        /if (${Me.Invis} && !${Select[${sentFrom},SingleHeal,GroupHeal]}) {
            /varset CastResult CAST_CANCELLED
            /return CAST_CANCELLED
        }
        /if (!${Target.CanSplashLand} && ${Spell[${WhatSpell}].TargetType.Equal[Free Target]}) {
           /echo Splash Spell will not cast at targets location. Skipping ${WhatSpell}
           /return CAST_NO_RESULT
        }
        /if (${IAmABard}) {
            /call CastBardCheck
        }
        /if (${Me.Gem[${WhatSpell}]}) {
            /while (1) {
                /if (${Me.GemTimer[${WhatSpell}]}==0 || ${Me.SpellReady[${WhatSpell}]}) {
                    /cast "${WhatSpell}"
                    DEBUGCAST CastSpell cast "${WhatSpell}"
                    /call DoCastingEvents 0 0
                    DEBUGCAST CastSpell1 Return from DoCastingEvents 1 CastResult: ${CastResult} castReturn: ${castReturn}
                    /varcalc TryNum ${TryNum}+1
                    /while (${Me.Casting.ID} && ${Window[CastingWindow].Open} && ${CastResult.NotEqual[CAST_CANCELLED]}) {
                        /if (${CastingInterruptOn}) {
                            DEBUGCAST CastSpell ENTER Interrupts SentFrom ${sentFrom} Spell:${WhatSpell} CastID:${Me.Casting.ID}
                            /if (${sentFrom.Equal[SingleHeal]} && (${CastingInterruptOn}&4)==4) {
                               /call CastInteruptHeals "${WhatSpell}" ${miscFlag}
                            } else /if (${sentFrom.Equal[MezMobs]} && (${CastingInterruptOn}&16)==16) {
                               /call CastInteruptMez "${WhatSpell}"
                            } else /if (${Select[${sentFrom},dps,gom,burn]}>0 && (${CastingInterruptOn}&8)==8) {
                               /call CastInteruptDPS "${WhatSpell}"
                            } else /if (${Select[${sentFrom},buffs,buffs-nomem,Regenother]}>0 && (${CastingInterruptOn}&2)==2) {
                               /call CastInteruptBuffs "${WhatSpell}"
                            }
                            |/delay 2
                            DEBUGCAST CastSpell LEAVE Interrupts SentFrom ${sentFrom}
                        }
                        /if (${sentFrom.Equal[pull]} && ${PullAggroTargetID}) {
                            /stopcast
                            /return CAST_SUCCESS
                        }
                    }
                    /call DoCastingEvents 5 0
                    DEBUGCAST CastSpell2 Return from DoCastingEvents 2 CastResult: ${CastResult} castReturn: ${castReturn}
                    /if (${CastResult.Equal[CAST_CANCELLED]} || ${castReturn.Equal[x]}) /break
                    /varset CastResult ${castReturn}
                }
                |Don't change this it has to be PullAggroTargetID or you break ChainPulling.
                /if (${sentFrom.Equal[Pull]} && ${PullAggroTargetID}) /return CAST_SUCCESS
                DEBUGCAST CastSpell3 ${Select[${CastResult},CAST_FIZZLE,CAST_INTERRUPTED,CAST_RESISTED]} ${Spell[${WhatSpell}].RecastTime.TotalSeconds} ${Me.GemTimer[${WhatSpell}]} ${Me.SpellReady[${WhatSpell}]}
                /if (${TryNum}<${MaxTryNum} && ${Select[${CastResult},CAST_FIZZLE,CAST_INTERRUPTED,CAST_RESISTED]}) {
                    /if  (${Spell[${WhatSpell}].RecastTime.TotalSeconds}<=2) {
                        /while (${Me.GemTimer[${WhatSpell}]} && !${Me.SpellReady[${WhatSpell}]}) {
                            /delay 5
                        }
                    } else {
                        /break
                    }
                } else {
                    /break
                }
            }
        } else {
            /echo Skip Casting ${WhatSpell}. Spell Not Memed.
            /varset CastResult CAST_NO_RESULT
        }
        /if (${IAmABard}) {
            /if (${Me.Casting.ID}) /stopcast
            |/if (${WasTwisting} && !${Twist}) /squelch /twist 
        }
        /if (${int_amIWasSitting} && !${Me.Sitting} && !${CombatStart}) /sit
        DEBUGCAST CastSpell Leave ${Me.GemTimer[${WhatSpell}]} ${CastResult}
    /return  ${CastResult}
| ----------------------------------------------------------------------------
| SUB: Cast DPS Spell Check ${Spell[${Spell[Gift of T'Vem].ID}].RecastTime}
| ----------------------------------------------------------------------------
    Sub CastDPSSpellCheck(SpellToCheck)
        |might think about looping through all buffs looking for caster name. 
        |necro dots and raid mobs.
        DEBUGCAST DPSSpellCheck \awEnter
        /declare i int local 0
        /declare k int local 0
        /if (${Target.Buff[${SpellToCheck}].ID} && ${Target.Buff[${SpellToCheck}].Caster.Equal[${Me}]}) {
            DEBUGCAST DPSSpellCheck ${SpellToCheck} is already on the target.
                /return TRUE
        } else {
            /if (${Spell[${SpellToCheck}].HasSPA[470]}==TRUE) {
                /for k 1 to ${Spell[${SpellToCheck}].NumEffects}
                    /if (${Spell[${SpellToCheck}].Attrib[${k}]}==470) {
                        DEBUGCAST \atDEBUGCOMBAT DPSSpellCheck ${k} ${Target.Buff[${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].Name}].ID}==${Spell[${SpellToCheck}].Trigger[${k}].ID} ${Spell[${SpellToCheck}].Trigger[${k}].Name} && ${Target.Buff[${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].Name}].Caster.Equal[${Me}]}
                        /if (${Target.Buff[${Spell[${SpellToCheck}].Trigger[${k}].Name}].ID} && ${Target.Buff[${Spell[${SpellToCheck}].Trigger[${k}].Name}].Caster.Equal[${Me}]}) {
                            DEBUGCAST \atDEBUGCOMBAT DPSSpellCheck The spell ${SpellToCheck} triggers ${Spell[${SpellToCheck}].Trigger[${k}].Name} is already on the target.
                            /return TRUE
                        }
                    }
                /next k
            }
        }
        DEBUGCAST DPSSpellCheck \awLeave
    /return FALSE
| ----------------------------------------------------------------------------
| SUB: Cast Buffs Spell Check
| ----------------------------------------------------------------------------
    Sub CastBuffsSpellCheck(SpellToCheck)
        DEBUGCAST CastBuffsSpellCheck \awEnter
        /declare i int local
        /declare k int local
        /declare numEffects int local
        /delay 5s ${Target.BuffsPopulated}
        | If spell is already on target skip
        /if (${Target.Buff[${SpellToCheck}].ID}) {
            DEBUGCAST \at The spell ${SpellToCheck} is already on the target.
            /return ${Target.BuffDuration[${SpellToCheck}].TotalSeconds}
            | Does buff have children spells like Unified Hand of Assurance or Talisman of the Wulthan
        } else /if (${Spell[${SpellToCheck}].HasSPA[374]} || ${Spell[${SpellToCheck}].HasSPA[340]}) {
            /varcalc numEffects ${Spell[${SpellToCheck}].NumEffects}
            /for k 1 to ${numEffects}
                | Double check spell attrib to make sure it has children spells
                /if (${Spell[${SpellToCheck}].Attrib[${k}]} == 374 || ${Spell[${SpellToCheck}].Attrib[${k}]} == 340) {
                    | If child spell is already on target skip
                    /if (${Target.Buff[${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].Name}].ID}) {
                        DEBUGCAST \at${k} BuffSpellCheck: The spell ${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].Name} is already on the target.
                        /return ${Target.BuffDuration[${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].Name}].TotalSeconds}
                    }
                }
            /next k
            |If spell doesn't stack with targets buffs skip
            /for k 1 to ${numEffects}
                | Double check spell attrib to make sure it has children spells
                /if (${Spell[${SpellToCheck}].Attrib[${k}]} == 374 || ${Spell[${SpellToCheck}].Attrib[${k}]} == 340) {
                    | If  spell doesn't stack with target buff skip
                    /for i 1 to 85
                        /if (${Target.Buff[${i}].Name.Length}) {
                            /if (!${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].WillStack[${Target.Buff[${i}]}]}) {
                                DEBUGCAST \at${i} ${k} BuffSpellCheck: The spell ${Spell[${Spell[${SpellToCheck}].Base2[${k}]}].Name} does not stack with ${Target.Buff[${i}].Name} on the target.
                                /return ${Target.BuffDuration[${i}].TotalSeconds}
                            }
                        }
                    /next i
                }
            /next k
        } else /if (${AltAbility[${SpellToCheck}].Spell.Trigger.ID}) {
            /if (${Target.Buff[${AltAbility[${SpellToCheck}].Spell.Trigger.Name}].ID}) {
                DEBUGCAST \at The spell ${SpellToCheck}(${AltAbility[${SpellToCheck}].Spell.Trigger}) is already on the target.
                /return ${Target.BuffDuration[${AltAbility[${SpellToCheck}].Spell.Trigger.Name}].TotalSeconds}
            }
        } else {
            /for i 1 to 85
                /if (${Target.Buff[${i}].Name.Length}) {
                    /if (!${Spell[${SpellToCheck}].WillStack[${Target.Buff[${i}]}]}) {
                    DEBUGCAST \at${i} The spell ${SpellToCheck} does not stack with ${Target.Buff[${i}].Name} on the target.
                        /return ${Target.BuffDuration[${i}].TotalSeconds}
                    }
                }
            /next i
        }
        DEBUGCAST CastBuffsSpellCheck \awLeave
    /return FALSE
| -------------------------------------------------------------------------------------
| SUB: Cast Weave
| -------------------------------------------------------------------------------------
    Sub CastWeave(TarID)
        /if (!${Select[${Me.State},stand,mount]}) /return
        DEBUGCAST CastWeave \awEnter
        /declare i int local
        /declare DPSat1 int Local 0
        /declare DPSWeaveDelay timer local 2
        /declare DPSWeaveSpell string local
        /declare DPSWeaveArg3 string local
        /declare DPSWeaveArg4 string local
        /for i 1 to ${WeaveArray.Size}
            /varset DPSat1 ${Int[${WeaveArray[${i}].Arg[2,|]}]}
            /varset DPSWeaveSpell ${WeaveArray[${i}].Arg[1,|]}
            DEBUGN Cast DPSWeaveSpell:(${DPSWeaveSpell}) at (${DPSat1}%) ${i}
            /if (${DPSat1}==0 || !${TarID} || ${Spawn[${TarID}].Type.Equal[corpse]}) /return
            /if (${DPSat1}<${Spawn[${TarID}].PctHPs} && ${DPSOn}==1) /continue
            /if (!${ConOn} || !${WeaveArray[${i}].Find[|cond]} || ${If[${Cond[${WeaveArray[${i}].Mid[${Math.Calc[${WeaveArray[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
                /if (${Me.AltAbilityReady[${WeaveArray[${i}].Arg[1,|]}]} || ${Me.ItemReady[${WeaveArray[${i}].Arg[1,|]}]} || ${Me.CombatAbilityReady[${WeaveArray[${i}].Arg[1,|]}]}) {
                    /if (${IAmMA} && ${TargetSwitchingOn} && ${Target.ID} && ${Target.ID}!=${TarID}) {
                        /call CombatTargetCheck 1
                        /varset TarID ${MyTargetID}
                    }
                    /call CastWhat "${DPSWeaveSpell}" ${TarID} WeaveStuff 0 0
                    /while (${DPSWeaveDelay}) {
                        /doevents
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo -- Weaving: ${DPSWeaveSpell}
                        /return 1
                    }
                }
            }
        /next i
        DEBUGCAST CastWeave \awLeave
    /return 0
|--------------------------------------------------------------------------------------
| SUB: CastBardCheck
|--------------------------------------------------------------------------------------
    Sub CastBardCheck(int ignorePlaying)
        DEBUGCAST CastBardCheck \awEnter ${Me.Casting.ID} ${Window[CastingWindow].Open}
        /if (${Twist}) {
            /varset WasTwisting TRUE
            /varset BardWasTwisting ${Twist.List}
            /if (!${ignorePlaying}) {
                /while (${Me.BardSongPlaying}) {
                    /if (${Twist}) /squelch /twist off
                    /delay 5
                    /if (${Me.Casting.ID}) /stopsong
                    /delay 30 !${Me.Casting.ID}
                }
            }
        } else {
            /varset WasTwisting FALSE
            /if (${Me.BardSongPlaying}) {
                /stopsong
                /delay 5
            }
        }
        /call DoCastingEvents 10 1
        /varset CastResult CAST_NO_RESULT
        DEBUGCAST CastBardCheck Leave ${Me.Casting.ID}
    /return 
|--------------------------------------------------------------------------------------
| SUB: CastTarget
|--------------------------------------------------------------------------------------
    Sub CastTarget(int CTWhatID)
        DEBUGCAST CastTarget Enter \aw ID:${CTWhatID} Target:${Spawn[id ${CTWhatID}].CleanName}
        /if (${CTWhatID}) {
            /squelch /target clear
            /delay 10 !${Target.ID}
            /squelch /target id ${CTWhatID}
            /delay 10 ${Target.ID}==${CTWhatID}
        }
        DEBUGCAST CastTarget Leave
    /return
|--------------------------------------------------------------------------------------
| SUB: CastMem
|--------------------------------------------------------------------------------------
    Sub CastMem(string WhatMemSpell,string sentFrom)
        /declare WaitTimerCM timer local 0
        DEBUGCAST CastMem Enter
        /if (!${IAmABard} && (${Me.Casting.ID} || ${Me.Moving})) /return notready
        /if (${Me.Invis} && !${Select[${sentFrom},SingleHeal,GroupHeal]}) {
            /varset CastResult CAST_CANCELLED
            /return notready
        }
        | Prevent tanks and heals trying to mem spells during combat.
        /if ((${Attacking} && ${IAmMA}) || (${HealsOn} && ${AggroTargetID} && ${sentFrom.NotEqual[Heal]} && !${Me.Mount.ID})) {
            /echo Cannot mem a spell during combat or while you have aggro. ${WhatMemSpell}
            /return notready
        }
        /if (${Cursor.ID}) /call CheckCursor CastMem 0
        /if (${MiscGemRemem} && ${MiscGemLW} && ${Spell[${WhatMemSpell}].RecastTime.TotalSeconds}>30) {
            /if (${ReMemWaitLong.Equal[null]}) {
                /echo RMWL: ${ReMemWaitLong} ${WhatMemSpell} ${ReMemWaitLong.Equal[${WhatMemSpell}]} ${Spell[${WhatMemSpell}].RecastTime.TotalSeconds}
                /varset ReMemWaitLong ${WhatMemSpell}
                /varset DontMoveMe 1
                /call CastMemSpell "${WhatMemSpell}" ${MiscGemLW} 0 CastMem
                /varset DontMoveMe 0
                /return notready
            } else {
                /echo Still Waiting on Long Wait Spell ${ReMemWaitLong} 
                /return notready
            }
        } else {
            /if (${Spell[${WhatMemSpell}].Mana}>${Me.CurrentMana}) /return notready
            /varset ReMemWaitShort ${WhatMemSpell}
            /varset DontMoveMe 1
            /call CastMemSpell "${WhatMemSpell}" ${MiscGem} 0 CastMem
            /varset DontMoveMe 0
            /if (${Me.Gem[${WhatMemSpell}]}) {
                /varset WaitTimerCM 350
                /while (!${Me.SpellReady[${WhatMemSpell}]} && ${WaitTimerCM}) {
                    /if (${ChaseAssist}) {
                        /call DoWeChase 0 CastMem
                    } else {
                        DOPARSE
                        /delay 5
                    }
                    /if (${Select[${sentFrom},buffs,buffs-nomem,buffonce,checkaura,summonstuff-nomem,dopetstuff,pet,pet-nomem]} && ${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) {
                        /varset CastResult CAST_CANCELLED
                        /return notready
                    }
                }
            }
            /if (!${Me.Gem[${WhatMemSpell}]}) /return notready
        }
        DEBUGCAST CastMem Leave
    /return 1
|--------------------------------------------------------------------------------------
| SUB: CastReMem
|--------------------------------------------------------------------------------------
    Sub CastReMem(string WhatMemSpell,int forceReMem,string sentFrom)
        DEBUGCAST CastReMem Enter
        |We need to check if the spell just cast was swaped out and other spell needs to bo rememed.
        |Need a way to carry a flag so remem will be done out of combat after the spell has been cast.
        /if (${CastResult.Equal[CAST_SUCCESS]}) {
            |Is it the MiscGem?
            /if (${WhatMemSpell.Equal[${ReMemWaitShort}]}) {
                /varset ReMemCast 1
            |Is it the MiscGemLW
            } else /if (${WhatMemSpell.Equal[${ReMemWaitLong}]}) {
                /varset ReMemCastLW 1
            }
        }
        /if (!${forceReMem}) /return
        /if (${sentFrom.Equal[buffs]} && ${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) /return
        /if (${MiscGemRemem}==1 || ${MiscGemRemem}==2) {
            /if (!${Me.Gem[${ReMemMiscSpell}]} && ${ReMemCast} && !${CombatStart} && !${Me.Buff[Resurrection Sickness].ID} && !${sentFrom.Find[-nomem]}) {
                /if (${Cursor.ID}) /call CheckCursor CastReMem 0
                /varset DontMoveMe 1
                /call CastMemSpell "${ReMemMiscSpell}" ${MiscGem} 0 CastReMem
                /varset DontMoveMe 0
                /varset ReMemCast 0
                /varset ReMemWaitShort null
            }
        }
        |Remem spell originally in Long Wait Gem slot
        /if ((${MiscGemRemem}==1 || ${MiscGemRemem}==3) && ${MiscGemLW} && ${ReMemWaitLong.NotEqual[null]}) {
            /if (${ReMemCastLW} && !${Me.Buff[Resurrection Sickness].ID}) {
                /if (${Cursor.ID}) /call CheckCursor CastReMem2 0
                /varset DontMoveMe 1
                /call CastMemSpell "${ReMemMiscSpellLW}" ${MiscGemLW} ${Int[${Me.Gem[${ReMemMiscSpellLW}]}]} CastReMem
                /varset DontMoveMe 0
                /varset ReMemCastLW 0
                /varset ReMemWaitLong null
            }
        }
        DEBUGCAST CastReMem Leave
    /return
|--------------------------------------------------------------------------------------
| SUB: CastMemSpell
|--------------------------------------------------------------------------------------
    Sub CastMemSpell(SpellToMem, int gemNum, int ForceIt, string sentFrom)
        DEBUGCAST CastMemSpell Enter
        /if (${Int[${SpellToMem.Length}]}==0 || ${SpellToMem.Equal[null]} || ${gemNum}==0) /return

        /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && !${ForceIt}) /return
        /if (${Cursor.ID} && ${Cursor.NoRent}) {
            /autoinventory
            /delay 10
        }
        | Unmem a spell if already memmed in a diffent gem
        /if (${ForceIt}) {
            /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && ${gemNum}!=${ForceIt}) {
                /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${ForceIt}-1]}]} rightmouseup
                /delay 20 ${Int[${Me.Gem[${gemNum}].ID}]}==0
            }
        }
        /if (${Me.Book[${SpellToMem}]}) {
            /if (!${Cursor.ID}) {
                /if (${Int[${Me.Gem[${gemNum}].ID}]}>0) {
                    /notify CastSpellWnd CSPW_Spell${Int[${Math.Calc[${gemNum}-1]}]} rightmouseup
                    /delay 20 ${Int[${Me.Gem[${gemNum}].ID}]}==0
                }
                /if (!${Int[${Me.Gem[${gemNum}].Name.Length}]} || ${Me.Gem[${gemNum}].Name.NotEqual[${SpellToMem}]}) {
                    /if (${IAmABard}) {
                        /call CastBardCheck 0
                    }
                    /while (${Me.Moving}) {
                        DOPARSE
                        /delay 5
                    }
                    /echo Memming ${SpellToMem} in slot ${gemNum}
                    /if (${Stick.Active}) {
                        /stick pause
                        /MemSpell ${gemNum} "${SpellToMem}"
                        /delay 150 ${Me.Gem[${gemNum}].Name.Equal[${SpellToMem}]}
                        /stick unpause
                    } else {
                        /MemSpell ${gemNum} "${SpellToMem}"
                        /delay 150 ${Me.Gem[${gemNum}].Name.Equal[${SpellToMem}]}
                    }
                }
            } else {
                /echo Cannot Mem a spell with Items on Cursor. Please drop item to Inventory.
            }
        } else {
            /echo Could Not find the spell ${SpellToMem} in your spell book.
        }
        /if (${Window[SpellBookWnd].Open}) /windowstate spellbookwnd close
        DEBUGCAST CastMemSpell ${SpellToMem} ${gemNum} ${ForceIt} ${sentFrom} ${Me.Gem[${gemNum}].Name}
        DEBUGCAST CastMemSpell Leave
    /return
|--------------------------------------------------------------------------------------
| SUB: CastInteruptHeals
|--------------------------------------------------------------------------------------
    Sub CastInteruptHeals(string CIHSpell, int overRide)
        DEBUGCAST CastInteruptHeals Enter
        /if (!${Int[${Me.Casting.ID}]}) /return
        | Check heal target is not an npc unless spell is detrimenatl like a tap or nuke type heal
        /if (${Target.Type.Equal[npc]} && ${Spell[${CIHSpell}].SpellType.NotEqual[Detrimental]} && !${overRide}) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIHSpell} interrupted. Target is an NPC
            DEBUGCAST CastInteruptHeals  CheckHP1: ${Target.Type}
        }
        | Override default heal interupts if caster MA and has his own healing set. ie pally or sk
        /if (${Target.Type.NotEqual[npc]} && ${SHealPct}>65 && ${Target.PctHPs}>${SHealPct} && !${CIHSpell.Find[promised]}) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIHSpell} interrupted. Target is above required ${SHealPct}% health. ${Target}
            DEBUGCAST CastInteruptHeals CheckHP2: ${Target.PctHPs} ${SHealPct}
        }
        DEBUGCAST CastInteruptHeals Leave
    /return
|--------------------------------------------------------------------------------------
| SUB: CastInteruptDPS
|--------------------------------------------------------------------------------------
    Sub CastInteruptDPS(string CIDSpell)
        DEBUGCAST CastInteruptDPS Enter
        /declare MAInterruptAt int local ${If[${SingleHealPointMA}<70,${SingleHealPointMA},70]}
        /if (!${Int[${Me.Casting.ID}]}) /return
        /if (${Target.Type.Equal[pc]}) /return
        /if (${Target.PctHPs}<1 || ${Target.Type.Equal[corpse]} || !${Int[${Target.ID}]}) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIDSpell} interrupted due to Killing corpses is not required.
            DEBUGCAST CastInteruptDPSCheckDPS1: ${Target.PctHPs} ${Target.Type} ${Int[${Target.ID}]}
        }
        /if (${HealsOn}) {
            /if (!${IAmMA} && ${Spawn[${MainAssist}].PctHPs}<${MAInterruptAt} && ${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} && ${Select[${Me.Class.ShortName},nec,mag]}==0) {
                /stopcast
                /varset CastResult CAST_CANCELLED
                /echo ${CIDSpell} interrupted due to The Main Assist Needs a Heal.
                DEBUGCAST CastInteruptDPS CheckDPS2: ${HealsOn}  ${Spawn[${MainAssist}].PctHPs} ${Spawn[${MainAssist} ${MainAssistType}].ID}  ${Spawn[${MainAssist} ${MainAssistType}].Type}
            } else /if (${Select[${Role},pettank,petpullertank,hunterpettank]}>0 && ${Me.Pet.ID} && ${Me.Pet.PctHPs}<${MAInterruptAt}) {
                /stopcast
                /varset CastResult CAST_CANCELLED
                /echo ${CIDSpell} interrupted due to my Pet Tank needs a heal.
                DEBUGCAST CastInteruptDPS CheckDPS3: ${HealsOn}  ${Me.Pet.ID} ${Me.Pet.PctHPs}
            }
        }
        DEBUGCAST CastInteruptDPS Leave
    /return
|--------------------------------------------------------------------------------------
| SUB: CastInteruptBuffs
|--------------------------------------------------------------------------------------
    Sub CastInteruptBuffs(string CIBSpell)
        DEBUGCAST CastInteruptBuffs Enter
        /if (!${Me.Casting.ID}) /return
        /if (${Me.Casting.Range}==0 && ${Me.Casting.AERange}==0) /return
        /if (${Me.Invis}) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIBSpell} interrupted because I am now invised.
            DEBUGCAST CheckBUFFS1: ${Me.Invis}
            /return
        }
        /if ((${Target.ID} && ${Target.PctHPs}<1) || (${Target.Type.Equal[corpse]})) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIBSpell} interrupted because target dead or not valid.
            DEBUGCAST CheckBUFFS2: ${Int[${Target.PctHPs}]} ${Target.Type}  ${Int[${Target.ID}]} ${Me.Casting} ${Me.Casting.TargetType}
        }
        /if (${Me.Casting.TargetType.NotEqual[self]}) {
            /if ((${Me.Casting.Range}>0 && ${Target.Distance}>${Me.Casting.Range}) || (${Me.Casting.AERange}>0 && ${Target.Distance}>${Me.Casting.AERange})) {
                /stopcast
                /varset CastResult CAST_CANCELLED
                /echo ${CIBSpell} interrupted because target out of range.
                DEBUGCAST CheckBUFFS3: ${Int[${Me.Casting.ID}]}  ${Target.Distance} ${Me.Casting.Range} ${Me.Casting.AERange} ${Me.Casting}
            }
        }
        /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) {
            /stopcast
            /varset CastResult CAST_CANCELLED
            /echo ${CIBSpell} interrupted because we now have aggro.
            DEBUGCAST CheckBUFFS4: ${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}
        }
        DEBUGCAST CastInteruptBuffs Leave
    /return
|--------------------------------------------------------------------------------------
| SUB: CastInteruptMez
|--------------------------------------------------------------------------------------
    Sub CastInteruptMez(string CIMSpell)
        DEBUGCAST CastInteruptMez Enter
        /if (!${Me.Casting.ID}) /return
        /if (!${Select[${Me.Class.ShortName},BRD,ENC]}) /return
        /if (${MezAECount}==0 || ${Select[${MezOn},1,3]}==0 || ${MezAETimer}) /return
        /if (${Spell[${MezAESpell}].Range}==0 && ${Spell[${MezAESpell}].AERange}==0) /return
        /varset MezMobAECount ${SpawnCount[npc xtarhater loc ${Target.X} ${Target.Y} radius ${Spell[${MezAESpell}].AERange}]}
        /if (!${MezMobAECount}) /return
        /if (${Me.XTarget[${XTSlot}].TargetType.NotEqual[Auto Hater]} && ${Me.XTarget[${XTSlot}].Type.NotEqual[pc]}) /varcalc MezMobAECount ${MezMobAECount}+1
        /if (${MezMobAECount}<${MezAECount}) /return
        /stopcast
        /varset MezAEClosest ${Target.ID}
        /varset CastResult CAST_CANCELLED
        /echo ${CIMSpell} interrupted because Need AE Mez.
        DEBUGCAST CastInteruptMez: ${Target.Type} ${Int[${Target.ID}]} ${Me.Casting} ${Me.Casting.TargetType} ${MezMobAECount} Leave
    /return
|**************************************************************************************|
| -------------------------------------------------------------------------------------
| SUB: Do We Move
| -------------------------------------------------------------------------------------
    Sub DoWeMove(int ForceToCamp, SentFrom)
        /if (!${ReturnToCamp} && !${ForceToCamp}) /return
        /declare StuckCount int local 0
        /declare X1 int local
        /declare Y1 int local
        /declare scatterDistance int local
        /declare CampYRandom int local
        /declare CampXRandom int local
        /while (1) {
            /varset EventFlag 0
            /doevents
            /if (!${EventFlag}) /break
        }
        /call EndMacroIf
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 30s
        /declare SpamTimerL timer local 0
        /declare LocCheckTimer timer local 0
        /declare _Y0           float local ${Math.Calc[${CampYLoc}-20]}
        /declare _Y1           float local ${Math.Calc[${CampYLoc}+20]}
        /declare MyDistance    int   local 0
        /declare DToggle       bool  local false

        /if (${Target.ID} && ${Target.Type.Equal[npc]}) {
            /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        }
        /declare circleDirection string local
        DEBUGN DoWeMove: Enter
        | - Shuts off ReturnToCamp if a toon moves a big distance defined by CampRadiusExceed ie CoH !${Pulled} || ${Pulling}
        DEBUGMOVE DoWeMove:(ReturnToCamp) My distance from camp is: (${Math.Distance[${CampYLoc},${CampXLoc}]}).
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadiusExceed} && !${Role.Find[hunter]} && ${ReturnToCamp}==1 && ${CampZone}==${Zone.ID}) {
            DEBUGMOVE DoWeMove:(ReturnToCamp) CampRadiusExceed turning off ReturnToCamp.
            /varset ReturnToCamp 0
            /echo Leashing exceeded distance of ${CampRadiusExceed} turning off ReturnToCamp
            /return
        }
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > 12 && ${CampZone}==${Zone.ID}) {
            /if (${Me.Feigning}) {
                /if (${AggroOffTimer}) {
                    /while (${Me.Feigning}) {
                        /doevents Timer
                        /delay 5
                    }
                } else {
                    /doevents Timer
                    /delay 10
                    /if (${Me.Feigning}) /stand
                }
            }
            DEBUGMOVE DoWeMove:(ReturnToCamp) Distance to camp > 10 and no adds in camp. ${Math.Distance[${CampYLoc},${CampXLoc}]} ${CampRadius} ${Medding}
            | Prevent puller roles from returning to camphere spot and just pull from where they are if in camp radius.
            /if (${Select[${Role},puller,pullertank,pullerpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=${CampRadius} && !${ForceToCamp} && !${Medding}) /return
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                |---------------------------------------------- MQ2Nav ---------------------------------------------------------------------|
                /if (${PullMoveUse.Equal[nav]}) {
                    /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius})  {
                        DEBUGMOVE DoWeMove:(ReturnToCamp) Distance to camp > 15, MQ2Nav return to camp.
                        /while (1) {
                            /doevents
                            /if (${IAmDead} || ${Me.Hovering}) {
                                /if (${Navigation.Active}) /nav stop
                                /return IAD
                            }
                            /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
                            /nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
                            /if (${Me.Mount.ID} && ${Math.Distance[${CampYLoc},${CampXLoc}]} <= 75) {
                                /echo MQ2Nav does not work well with mounts. Dismounting.
                                /dismount
                            }
                            /while (1) {
                                /varset X1 ${Int[${Me.X}]}
                                /varset Y1 ${Int[${Me.Y}]}
                                /if (${Pulled}) {
                                    | PullerPetTank - send in pet to attack on my way back to camp if not too far from camp.
                                    /if (${Role.Equal[pullerpettank]} || ${PullWith.Equal[pet]}) {
                                        /if (${Me.Pet.ID}) {
                                            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                                                /call CombatPet
                                            } else {
                                                /if (${Me.Pet.Combat}) /pet back off
                                                /if (${Me.Pet.Stance.NotEqual[FOLLOW]} && ${PullWith.Equal[pet]}) /pet follow
                                            }
                                        }
                                    }
                                    |if MyTargetID is not on Xtarget, and the mob is still in the zone, then the mob lost aggro.
                                    |and we need to go back and get him.
                                    /if (!${SpawnCount[id ${MyTargetID} xtarhater]} && ${Spawn[id ${MyTargetID}].ID}) {
                                        /if (!${AggroTargetID} || (${ChainPull} && !${PullAggroTargetID})) {
                                            /echo I got Here1: ${AggroTargetID} ${ChainPull} ${PullAggroTargetID} ${MyTargetID}
                                            /varset Pulled 0
                                            | if using ranged then try and pull mob again, other wise start looking for another mob.
                                            /if (${PullWith.Equal[Ranged]}) {
                                                /if (${Navigation.Active}) /nav stop
                                                /return lma
                                            } else {
                                                /continue
                                            }
                                        } else /if (!${ChainPull}) {
                                            /varset MyTargetID ${AggroTargetID}
                                        } else {
                                            /varset MyTargetID ${PullAggroTargetID}
                                        }
                                        /if (!${MyTargetID}) /varset Pulled 0
                                    }
                                    /if ((${Me.Running} && !${SpawnCount[xtarhater radius 300]}) || (!${Me.Running} && ${SpawnCount[xtarhater radius 200]})) /nomodkey /keypress RUN_WALK
                                } else {
                                    | Added for finding mob to pull when running back to camp after a failed pull.
                                    /if (${CheckOnReturn} && ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${Math.Calc[${MaxRadius}*.90]}) {
                                        /call FindMobToPull 0 1 0
                                        /if (${Macro.Return}>0) {
                                            /varset MyTargetID 0
                                            /if (${Navigation.Active}) /nav stop
                                            /return 
                                        }
                                    }
                                }
                                /delay 5
                                /if (${Me.Hovering}) {
                                    /break
                                } else /if (!${Me.Stunned} && !${Me.Feigning}) {
                                    | Check for getting stuck on geometry
                                    /if (${Int[${Me.X}]}==${X1} && ${Int[${Me.Y}]}==${Y1}) {
                                        /varcalc StuckCount (${StuckCount})+1
                                        /if (${StuckCount}>=3) {
                                            /if (${Navigation.Active}) /nav stop
                                            /call Stuck DoWeMove
                                            /varset StuckCount 0
                                            /break
                                        }
                                    }
                                } else /if (${Me.Stunned}) {
                                    /while (${Me.Stunned}) {
                                        /delay 2
                                    }
                                    /break
                                }
                                DEBUGMOVE DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} >= ${CampRadius} Timer: ${DWMTimer}
                                /if (${Navigation.Active}) {
                                    /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>${CampRadius}) {
                                        /if (!${DWMTimer}) /varset DWMTimer 5s
                                    }
                                }
                                /if (!${Navigation.Active} || !${DWMTimer}) /break
                            }
                            /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < 16) {
                                /if (!${CampZLoc}) /varset CampZLoc ${Me.Z}
                                /break
                            }
                        }
                    }
                |---------------------------------------------- MQ2AdvPath ---------------------------------------------------------------------|
                } else /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                    /if (${MoveTo.Moving}) /moveto off
                    /play ${PullPath} reverse nodoor smart
                    DEBUGMOVE DoWeMove: /play ${PullPath} reverse nodoor smart
                    /while (1) {
                        /doevents
                        /if (${IAmDead} || ${Me.Hovering}) {
                            /if (${AdvPath.State}) /play off
                            /return
                        }
                        /delay 5
                        /varset DWMWPCurrent ${AdvPath.NextWaypoint}
                        DEBUGMOVE DoWeMove: ReturnToCamp WP#: ${DWMWPCurrent} ${MoveTo.Moving}
                        /if (${AdvPath.State}==2 && ${Me.Moving} && ${DWMTimer}<10) /varset DWMTimer 10
                        /if (${DWMTimer}==0) /break
                        |This is for when you get summoned while running back to camp.
                        |AdvPath stops playing the path back to camp when summoned.
                        /if (${DWMWPCurrent}<2) {
                            /break
                        } else /if (${AdvPath.State}==0) {
                            /play ${PullPath} reverse nodoor smart
                            /varset DWMTimer 10
                        }
                        /if (${Pulled}) {
                            /if ((${Me.Running} && !${SpawnCount[xtarhater radius 300]}) || (!${Me.Running} && ${SpawnCount[xtarhater radius 200]})) /nomodkey /keypress RUN_WALK
                        }
                    }
                    /if (${AdvPath.State}) /play off
                }
            } else /if (${PullMoveUse.Equal[nav]}) {
                DEBUGMOVE DoWeMove:(ReturnToCamp) Non-Puller MQ2Nav return to camp.
                /varset DWMTimer 10s
                /doevents
                /if (${IAmDead} || ${Me.Hovering}) {
                    /if (${Navigation.Active}) /nav stop
                    /return
                }
                /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
                /nav locxyz ${CampXLoc} ${CampYLoc} ${CampZLoc}
                /while (1) {
                    /if (${IAmDead} || ${Me.Hovering}) {
                        /if (${Navigation.Active}) /nav stop
                        /return
                    }
                    /if (!${Navigation.Active}) {
                        /break
                    } else {
                        /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>${CampRadius}) {
                            /if (!${DWMTimer}) /varset DWMTimer 5s
                        } else {
                            /if (!${CampZLoc}) /varset CampZLoc ${Me.Z}
                        }
                    }
                }
            }
            |------------------------------------------------ MoveTo -----------------------------------------------------------------------|
            DEBUGMOVE DoWeMove: Distance to camp ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15, MQ2MoveUtils return to camp.
            /doevents
            /if (!${Me.FeetWet}) /look 0
            /moveto dist 10
            /if (${ScatterOn}) {
                | Randomize camp x,y by +- so toons don't always retun to exact same spot and help to look less botted.
                /varcalc scatterDistance ${Math.Rand[7]}+5
                /if (${Math.Rand[2]}) {
                    /varcalc CampYRandom ${CampYLoc}-${scatterDistance}
                } else {
                    /varcalc CampYRandom ${CampYLoc}+${scatterDistance}
                }
                /if (${Math.Rand[2]}) {
                    /varcalc CampXRandom ${CampXLoc}-${scatterDistance}
                } else {
                    /varcalc CampXRandom ${CampXLoc}+${scatterDistance}
                }
            } else {
                /varset CampYRandom ${CampYLoc}
                /varset CampXRandom ${CampXLoc}
            }
            DEBUGMOVE DoWeMove: Camp Location Info: ScatterOn: ${ScatterOn} YRandom: ${CampYRandom} XRandom: ${CampXRandom} ${IAmDead} ${Me.Hovering}
            /varcalc MyDistance ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]}-4
            /varset LocCheckTimer ${LocDelayCheckUW}
            /while (1) {
                /if (${IAmDead} || ${Me.Hovering}) {
                    /moveto off
                    /return
                }
                /if (!${Me.Mount.ID} && ${Me.Sitting} && ${Math.Distance[${CampYLoc},${CampXLoc}]} >= 16) /stand
                /if (!${Me.Moving} || !${MoveTo.Moving}) {
                    /if (${Me.FeetWet}) {
                        /face loc ${CampYRandom},${CampXRandom},${CampZLoc}
                        /moveto set useback off
                        /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc} mdist 15
                    } else {
                        /moveto set useback on
                        /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc}
                    }
                } else {
                    /if (!${LocCheckTimer}) {
                        /if (${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]}>${MyDistance}) {
                           |OK I am Stuck or snared. Because I am not moving or moving slowly.
                            /if (${Me.FeetWet}) {
                                /if (${MoveTo.Moving}) {
                                    /moveto off
                                    /delay 5
                                }
                                /if (${DToggle}) {
                                    /face loc ${_Y1},${CampXRandom},${CampZLoc}
                                    /delay 5
                                    /moveto loc ${_Y1} ${CampXRandom} ${CampZLoc} mdist 5
                                } else {
                                    /face loc ${_Y0},${CampXRandom},${CampZLoc}
                                    /delay 5
                                    /moveto loc ${_Y0} ${CampXRandom} ${CampZLoc} mdist 5
                                }
                                /varcalc DWMTimer ${DWMTimer}+20
                                /varset DToggle ${If[${DToggle},False,True]}
                                |/delay 5
                            }
                        } else {
                            /face loc ${CampYRandom},${CampXRandom},${CampZLoc}
                        }
                        /varcalc MyDistance ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]}-4
                        /varset LocCheckTimer ${LocDelayCheckUW}
                    }
                }
                /if (${Pulled}) {
                    /if (${Role.Equal[pullerpettank]} || ${PullWith.Equal[pet]}) {
                        /if (${Me.Pet.ID}) {
                            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${PetAttackRange}) {
                                /call CombatPet
                            } else {
                                /if (${Me.Pet.Combat}) /pet back off
                                /if (${Me.Pet.Stance.NotEqual[FOLLOW]} && ${PullWith.Equal[pet]}) /pet follow
                            }
                        }
                    }
                    /if ((${Me.Running} && !${SpawnCount[xtarhater radius 300]}) || (!${Me.Running} && ${SpawnCount[xtarhater radius 200]})) /nomodkey /keypress RUN_WALK
                }
                /delay 10
                /if ((!${MoveTo.Moving} && !${Me.Moving}) || ${DWMTimer}==0) /break
                DEBUGMOVE DoWeMove: MoveTo My distance from Camp is: ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} ${Me.FeetWet}.
                /if (!${MoveTo.Moving} || ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} < 16) /break
            }
            /if (${Me.FeetWet} && ${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} >= 15) {
                /varset DWMTimer 20
                /face loc ${CampYRandom},${CampXRandom},${CampZLoc}
                /moveto loc ${CampYRandom} ${CampXRandom} ${CampZLoc} mdist 15
                /while (${Math.Distance[${CampYRandom},${CampXRandom},${CampZLoc}]} > 15 && ${DWMTimer}) {
                    /delay 5
                }
                /if (${MoveTo.Moving}) /moveto off
            }
            /delay 20 !${Me.Moving}
            | Move down if Z distance more than 3 due to levitation
            /if (${Target.ID} && ${Select[${Target.Type},npc,corpse]})  /call ZAxisCheck ${ZDist} 3.1
            /if (${FaceMobOn} && !${AggroTargetID} && !${CombatStart} || ${Select[${Role},pullertank,puller,pullerpettank]}==0) /face heading ${LookForward}
            /if (!${Me.FeetWet}) /look 0
        }
        /if (${Me.FeetWet} && ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} >= 15) {
            /face loc ${CampYLoc},${CampXLoc},${CampZLoc}
            /moveto loc ${CampYLoc} ${CampXLoc} ${CampZLoc} mdist 15
            /varset DWMTimer 30
            /while (${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} > 15 && ${DWMTimer}) {
                /delay 5
            }
            /if (${MoveTo.Moving}) /moveto off
        }
        DEBUGMOVE DoWeMove: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Do We Chase
| -------------------------------------------------------------------------------------
    Sub DoWeChase(string SentFrom)
        /if (!${ChaseAssist}) /return
        /if (${Me.Hovering} || !${Spawn[=${WhoToChase}].ID}) /return
        /declare StuckCount int local 0
        /declare X1 int local
        /declare Y1 int local
        /declare MeshLoadedCheck bool local FALSE
        /declare DWMWPCurrent int local 0
        /declare DWMTimer timer local 0
        /if (${PullMoveUse.Equal[nav]}) {
            /varset MeshLoadedCheck ${Navigation.MeshLoaded}
        }
        DEBUGMOVE DoWeChase: Enter ${SentFrom}
        /if (${Me.Pet.ID} && ${Me.Pet.Stance.NotEqual[follow]}) /pet follow
        /while (${ChaseAssist}) {
            | Stop sticking if mobs are on xtarget
            /if (${ChaseAssist}==1) {
                /if (${SpawnCount[npc xtarhater]} && !${Role.Find[pull]} && !${IAmMA} && ${Spawn[=${WhoToChase}].Distance} < ${CampRadius}) {
                    /if (${Stick.Active}) {
                        DEBUGMOVE Not gonna be an idiot and move during fight cause I dont have to.
                        /stick off
                        /moveto off
                    }
                    /if (${PullMoveUse.Equal[nav]}) {
                        /if (${Navigation.Active}) /nav stop
                    }
                    /break
                }
            }
            /doevents
            /call EndMacroIf
            DEBUGMOVE DoWeChase:(ChaseAssist) My distance from (${WhoToChase}) is: (${Spawn[=${WhoToChase}].Distance}) Z: ${Spawn[=${WhoToChase}].DistanceZ}.
            | If the mesh loaded then ignore Distance and Z Distance. Just try and run the path to WhoToChase.
            /if (${JustZoned}==0) {
                /if (!${MeshLoadedCheck} && (${Spawn[=${WhoToChase}].Distance} > ${CampRadiusExceed} || ${Spawn[=${WhoToChase}].DistanceZ}>100)) {
                    /if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist exceed camp check
                    /varset ChaseAssist 0
                    /echo ChaseAssist distance exceeded: Turning off ChaseAssist
                    /call BroadCast r "Hey! I got left behind please run me to " ${WhoToChase}
                    /break
                }
            } else {
                /while (!${Spawn[=${WhoToChase}].ID}) {
                    /delay 10
                    /if (!${JustZoned}) /break
                    DOPARSE
                }
            }
            /if (!${Spawn[=${WhoToChase}].ID}) /break
            /if (${Spawn[=${WhoToChase}].Distance} > ${ChaseDistance}) {
                /if (${Debug} || ${DebugMove}) /echo \atDEBUG ChaseAssist MA distance check
                /if (${MeshLoadedCheck}) {
                    /if (!${Navigation.Active}) {
                        /if (${Navigation.PathExists[id ${Spawn[=${WhoToChase}].ID}]}) {
                            /nav id ${Spawn[=${WhoToChase}].ID}
                        } else /if (${Spawn[=${WhoToChase}].LineOfSight}) {
                            /moveto id ${Spawn[=${WhoToChase}].ID} uw mdist ${ChaseDistance}
                        } else {
                            /echo Chase Failed due to ${WhoToChase} is not in Line of sight and Navigation couldn't find a path. Will try /Sticking.
                        }
                    }
                } else /if (${Spawn[=${WhoToChase}].LineOfSight}) {
                    /moveto id ${Spawn[=${WhoToChase}].ID} uw mdist ${ChaseDistance}
                }
                /delay 10 ${Me.Moving}
                /while (${Me.Moving}) {
                    /if (${Spawn[=${WhoToChase}].Distance3D}<=${ChaseDistance}) {
                        /if (${PullMoveUse.Equal[nav]}) {
                            /if (${Navigation.Active}) /nav stop
                        }
                    }
                    /delay 5
                }
            } else /if (!${Stick.Active} && !${MeshLoadedCheck}) {
                /if (${Spawn[=${WhoToChase}].Type.Equal[Pet]}) {
                    /target ${Spawn[=${WhoToChase}].Master}
                    /delay 10
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} id ${Target.ID} loose uw
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else /if ( ${Spawn[=${WhoToChase}].Type.Equal[mercenary]}) {
                    /target ${Spawn[=${WhoToChase}].Owner}
                    /delay 10
                    /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} id ${Target.ID} loose uw
                    } else {
                        /stick ${ChaseDistance} id ${Target.ID} loose
                    }
                } else {
                   /if (${Me.FeetWet}) {
                        /stick ${ChaseDistance} id ${Spawn[=${WhoToChase}].ID} loose uw
                    } else {
                       /stick ${ChaseDistance} id ${Spawn[=${WhoToChase}].ID} loose
                    }
                }
                /delay 10
                /while (${Me.Moving}) {
                    /delay 10
                }
            }
            /if (!${Me.Moving} && !${Spawn[=${WhoToChase}].Moving}) /break
            /while (${ChaseAssist}==3) {
                /delay 10
            }
        }
        DEBUGMOVE DoWeChase: Leave
    /return
|-------------------------------------------------------------------------------------
| SUB: Stuck
| -------------------------------------------------------------------------------------
    Sub Stuck(string SentFrom)
        /declare strafedir string local
        | - We're stuck, back off a second, move left or right (randomly) for 1 second
        /if (${IAmDead}) /return
        /keypress back hold
        /delay 10
        /keypress back
        /if (${Math.Rand[2]}) {
            /varset strafedir STRAFE_LEFT
        } else {
            /varset strafedir STRAFE_RIGHT
        }
        /keypress ${strafedir} hold
        /delay 10
        /keypress ${strafedir}
    /return
| -------------------------------------------------------------------------------------
| SUB: DoWeMed
| -------------------------------------------------------------------------------------
    Sub DoWeMed(int p_UseFlag, int p_watchID, string p_stat, int p_resume)
        /if (!${MedOn}) /return
        /if (!${MedCombat} && ${AggroTargetID}) /return
        /if (${MedCombat} && !${Medding} && ${AggroTargetID}!=0 && ${AggroTargetID}==${MyTargetID}) /return
        DEBUGN DoWeMed Enter
        /declare Med2On       int    local 0
        /declare MedForceOn   int    local 0
        /declare MedStat1     string local ${MedStat}
        /declare j            int    local 0
        /declare MedFlag      int    local 0
        /declare SittingDown  int    local 0
        /declare IAmMedding   int    local 0
        /declare MedSingingID int    local 0
        /declare watchName    string local
        /declare MedCombatCK  int    local ${MedCombat}
        
        /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
        /if (!${Me.Moving}) {
            /if (${Select[${Me.Class.ShortName},BRD,BST,PAL,RNG,SHD]} && ${Me.Pct${MedStat2}}<${MedStart} && ${Me.Pct${MedStat}}>${MedStart}) {
                /varset MedStat1 ${MedStat}
                /varset MedStat ${MedStat2}
                /varset Med2On 1
            }
            /if ((${Group.MainAssist.ID} && ${Group.MainAssist.Sitting}) || (!${Group.Member[${MainAssist}].Index} && ${Spawn[PC ${MainAssist}].Sitting})) {
                /if (!${MASitTime}) {
                    /varset MASitTime 300
                } else /if (${MASitTime}<260) {
                   /varset MedForceOn 1
                }
            } else {
                /varset MASitTime 0
            }
            /if (${Me.Pct${MedStat}}<${MedStart}) {
                /varset MedFlag 1
            } else /if (${MeddingInterrupted}) {
                /if (${MeddingInterrupted}==2) {
                    /varset p_UseFlag 1
                    /varset PullWaitTimer1 ${PullWaitRemaining}
                | Need to find the lowest of MedStat in the group and use them as who to watch.
                } else /if (${MeddingInterrupted}==3) {
                    /varset MeddingInterrupted 0
                }
                /varset MedFlag 1
            } else /if (${PullHold}==2 && ${Me.Pct${MedStat}}<98) {
                /varset MedFlag 1
            } else /if (${MedForceOn} && ${Me.Pct${MedStat}}<90 && !${Role.Find[puller]}) {
                /if (${MedCombat}) /varset MedCombatCK 0
                /varset MedFlag 1
            } else /if (${MedForceOn} && ${IAmABard} && ${TwistMed}) {
                /varset MedFlag 1
            } else /if (${p_UseFlag}==1 && ${PullWaitTimer1}) {
                /varset MedFlag 1
            } else /if (${p_UseFlag}==2 && ${p_watchID}) {
                /varset MedFlag 1
                /varset watchName ${Spawn[id ${p_watchID}].CleanName}
            } else {
                /return
            }
            /if (${MedFlag}) {
                /if (${Target.ID}) /squelch /target clear
                /varset Medding 1
                /if (${Attacking}) /call CombatReset 0 dowemed
                | bards twisting while others fighting negate fast med
                /if (${IAmABard}) {
                    /if (${TwistMed}) {
                        /if (${Int[${TwistMed.Arg[2,]}]}>0) {
                            /varset MedFlag 2
                        } else {
                            /varset MedSingingID ${Me.Gem[${TwistMed.Arg[1,]}].ID}
                        }
                    }
                    /call CastBardCheck 0
                    /squelch /twist clear
                }
                /if (${Medding}) /echo Medding until ${MedStat} ${MedStop}% ${Me.Pct${MedStat}} ${MedStart}
                /if (${Me.Pct${MedStat}}<${MedStart}) {
                    /call BroadCast t "My ${MedStat} is ${Me.Pct${MedStat}}% time to med."
                } else /if (${MeddingInterrupted}) {
                    /call BroadCast t "Medding Interrupted. My ${MedStat} is ${Me.Pct${MedStat}}% time to Resume."
                }
                /if (!${MeddingInterrupted}) {
                    /if (!${p_UseFlag}) {
                        /varset MeddingInterrupted 1
                    } else /if (${p_UseFlag}==1) {
                        /varset MeddingInterrupted 2
                    } else /if (${p_UseFlag}==2) {
                        /varset MeddingInterrupted 3
                    }
                }
                /while (1) {
                    /doevents
                    /if (${ChaseAssist}) /call DoWeChase
                    /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                        /call DoWeMove 0 DoWeMed
                    }
                    /if (${MountOn} && !${Me.Mount.ID} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]})) /call CastMount
                    /if (!${IAmABard}) {
                        /if (!${Me.Mount.ID} && !${IAmMedding} && ${Me.Standing} && !${Me.Moving}) {
                            /sit
                            /varset SittingDown 1
                            /varset IAmMedding 1
                            /delay 10
                        } else /if (${SittingDown}==1 && ${Me.Standing}) {
                            /echo I sat you down, but you are no longer sitting.
                            /echo You have something outside of Kissassist standing you.
                            /varset SittingDown 2
                        }
                    } else {
                        | For Bards Only.
                        /if (${MedFlag}==1) {
                            /if (${MedSingingID}) {
                                /if (${MedSingingID}!=${Me.Casting.ID} || !${Me.Casting.ID}) {
                                    /squelch /stopsong
                                    /if (${Me.Sitting}) /stand
                                    /delay 5
                                    /cast ${TwistMed}
                                    /delay 10
                                    /while (${Window[CastingWindow].Open}) {
                                        /delay 5
                                    }
                                    /varset SittingDown 0
                                    /varset IAmMedding 1
                                }
                            }
                        } else {
                            /if (!${Twist} || ${Twist.List.Left[-1].NotEqual[${TwistMed}]}) {
                                /call CastBardCheck 0
                                /squelch /twist ${TwistMed}
                                /varset IAmMedding 1
                                /delay 10
                            }
                        }
                        /if (!${Me.Mount.ID} && ${Me.Standing} && !${Twist}) {
                            /if (!${SittingDown}) {
                                /sit
                                /varset SittingDown 1
                                /varset IAmMedding 1
                                /delay 10
                            } else /if (${SittingDown}==1 && ${Me.Standing}) {
                                /echo I sat you down, but you are no longer sitting.
                                /echo You have something outside of Kissassist standing you.
                                /varset SittingDown 2
                            }
                        }
                    }
                    DEBUGN ${MedStat} ${MedStat1} ${MedStat2} ${MedFlag} ${p_UseFlag} ${MeddingInterrupted}
                    /delay 10
                    /if (!${MedCombatCK}) {
                        /doevents AttackCalled
                        DEBUGN MedCombat1 ${CalledTargetID} ${Group.Member[${MainAssist}].Index} ${IAmMA} ${Me.XTarget[${XTSlot}].TargetType}
                        /if (${CalledTargetID} && !${Group.Member[${MainAssist}].Index} && !${IAmMA} && ${Spawn[${CalledTargetID}].Type.NotEqual[PC]}) {
                            /squelch /target id ${CalledTargetID}
                            /delay 10
                            /if (${XTarAutoSet}) {
                                /xtarget set ${XTSlot} currenttarget
                                /delay 10
                            }
                            /varset CalledTargetID 0
                        }
                        /call WaitSubs
                        /if (${SittingDown} && ${Me.Standing}) {
                            /echo You stood up while you were waiting. Will sit you back down.
                            /varset SittingDown 0
                            /varset IAmMedding 0
                        }
                        DEBUGN MedCombat2 ${CalledTargetID} ${Group.Member[${MainAssist}].Index} ${IAmMA} ${Me.XTarget[${XTSlot}].TargetType}
                        /if (${CalledTargetID} && !${Group.Member[${MainAssist}].Index} && !${IAmMA} && ${Spawn[${CalledTargetID}].Type.NotEqual[PC]}) {
                            /squelch /target id ${CalledTargetID}
                            /delay 10
                            /if (${XTarAutoSet}) {
                                /xtarget set ${XTSlot} currenttarget
                                /delay 10
                            }
                            /varset CalledTargetID 0
                        }
                        /if (${AggroTargetID} && (${SpawnCount[xtarhater radius 150]} || ${MeleeTwistOn}==2 || ${Int[${Me.XTarget[${XTSlot}].Distance}]}<150)) {
                            /if (!${Me.Mount.ID} && ${Me.Sitting}) {
                                /stand
                            }
                            /varset Medding 0
                            /if (${IAmABard}) {
                                /call CastBardCheck
                                /if (${MeleeTwistOn}==2) /call DoBardStuff 
                            }
                            | May need to add check to call DoBardStuff to get meletwist started.
                            /if (${Med2On}) /varset MedStat ${MedStat1}
                            /return
                        }
                    } else {
                        /if (${AutoRezOn}) /call RezCheck all
                    }
                    /if (!${p_UseFlag}) {
                        /if (${MedForceOn} && (!${Group.MainAssist.ID} || !${Group.MainAssist.Sitting})) /varset MedForceOn 0
                        /if (${Me.Pct${MedStat}}>=${MedStop} && !${MedForceOn}) /break
                    } else {
                        /if (${p_UseFlag}==1) {
                            /if (!${PullWaitTimer1}) {
                                /varset PullWaitRemaining 0
                                /break
                            } else {
                                /varset PullWaitRemaining ${PullWaitTimer1}
                            }
                        } else /if (${p_UseFlag}==2 && ${p_watchID}) {
                            /if (${Spawn[id ${p_watchID}].ID} && ${Target.ID}!=${p_watchID}) {
                                /squelch /target id ${p_watchID}
                                /delay 20
                            } else /if (!${Spawn[id ${p_watchID}].ID}) {
                                /echo Character ${watchName} Left the zone. Leaving Med Routine.
                                /break
                            }
                            /if (${Target.Pct${p_stat}}>=${p_resume}) /break
                        }
                    }
                }
                | Done Medding
                /if (${Med2On}) /varset MedStat ${MedStat1}
                /if (${Me.Sitting} && ${Me.Pct${MedStat}}>=${Math.Calc[${MedStop}-5]}) {
                    /stand
                }
                /if (${IAmABard} && ${TwistMed}) {
                    /call CastBardCheck
                    /if (${TwistOn}) /squelch /twist ${TwistWhat}
                }
            }
            /varset Medding 0
            /if (${MeddingInterrupted}<4) /varset MeddingInterrupted 0
            /varset SittingDown 0
            | return if using timer or watching another character.
            /if (${p_UseFlag}) /return
            /if (${Select[${Role},pullerpettank,puller,hunter,hunterpettank]} && ${Me.PctHPs}<=50) {
                /echo Medding to 100% health
                /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                    /call DoWeMove 0 dowemed
                }
                /varset Medding 1
                /if (!${Me.Mount.ID} && ${Me.Standing} && !${Me.Moving} && !${SittingDown}) {
                    /sit
                    /varset SittingDown 1
                    /delay 10
                }
                /varset MeddingInterrupted 4
                /while (1) {
                    /doevents
                    /delay 5
                    /if (!${MedCombatCK}) {
                        /call WaitSubs
                        /if (${AggroTargetID}) {
                            /if (${DPSOn} || ${MeleeOn}) {
                                /call CheckForCombat 0 DoWeMed3 0
                            } else {
                                /call CheckForCombat 1 DoWeMed4 0
                            }
                            /varset Medding 0
                            /return
                        }
                    }
                    /if  (${Me.PctHPs}>=${MedStop}) {
                        /varset Medding 0
                        /break
                    }
                }
                /varset MeddingInterrupted 0
                /if (!${Me.Mount.ID} && ${Me.Sitting}) {
                    /stand
                    /varset SittingDown 0
                }
            }
            /if (${Select[${Role},pullerpettank,hunterpettank]} && !${Me.Invis} && (${Me.Pet.PctHPs}<=50 || ${PetForceHealOnMed})) {
                | Check pet is at full health before pulling.
                /echo Waiting on pet to full health before next pull
                | Might want to add to make the pet sit to help with recovery.
                /if (${Me.Pet.ID} && ${Me.Pet.PctHPs}<${MedStop}) {
                    /while (1) {
                        /for j ${SingleHeal.Size} downto 1
                            /if (${SingleHeal[${j}].Arg[3,|].NotEqual[pet]} || !${SingleHeal[${j}].Length} || ${SingleHeal[${j}].Arg[2,|]}==0) /continue
                            /if (${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) {
                                DEBUGN \amDEBUG DoPetMedStuff (${SingleHeal[${j}].Arg[3,|].Find[PET]} && ${Me.Pet.PctHPs} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range})
                                /call CastWhat "${SingleHeal[${j}].Arg[1,|]}" ${Me.Pet.ID} Med 0 0
                                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                    /call BroadCast o "${Heals[${j}].Arg[1,|]} on  >> ${Me.Pet.CleanName} <<"
                                    /varcalc PetHealTimer${j} ${Spell[${SingleHeal[${j}].Arg[1,|]}].MyDuration.TotalSeconds}*10
                                }
                                /break
                            }
                        /next j
                        /if (!${Me.Pet.ID} || ${Me.Pet.PctHPs}>=${MedStop} || ${AggroTargetID}) /break
                    }
                }
            }
        }
        DEBUGN DoWeMed Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckBuffs
| -------------------------------------------------------------------------------------
    Sub CheckBuffs(int ForceGroup)
        /if (!${BuffsOn} || ${IAmDead} || ${Me.Hovering} || (${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || (${ChaseAssist} && ${Me.Moving}) || (${Me.Moving} && ${WhoToChase.Equal[${Me}]})) /return
        DEBUGBUFF CheckBuffs CheckBuffs: Enter
        /declare i                int     local 0
        /declare j                int     local 0
        /declare k                int     local 0
        /declare l                int     local 0
        /declare FullText         string  local 0
        /declare 2ndPart          string  local 0
        /declare 3rdPart          string  local 0
        /declare 4thPart          string  local 0
        /declare 5thPart          string  local 0
        /declare 6thPart          string  local 0
        /declare 7thPart          string  local 0
        /declare SpellRange       int     local 0
        /declare SpellToCast      string  local null
        /declare MATargetID       int     local 0
        /declare i_TargetID       int     local 0
        /declare BookSpellTT      string  local 0
        /declare BuffToCheck      string  local null
        /declare CondNo           int     local 0
        /declare PeersZone        string  local
        /if (${PowerSource.NotEqual[NULL]} && ${Bool[${Me.Inventory[powersource].Name.Length}]} && !${Me.Inventory[powersource].Power}) {
           /call CheckCursor CheckBuffs0 0
           /nomodkey /itemnotify "${PowerSource}" leftmouseup
           /delay 5s ${Cursor.ID}
           /if (${Cursor.Name.Equal[${PowerSource}]}) /destroy
           /delay 5s !${Cursor.ID}
        }
        |--------- Change to add Zone.Outdoor TLO and specific Zone.Type to stop mount cast spam.
        /if (${MountOn} && !${Me.Mount.ID} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]}) && ${Me.CombatState.NotEqual[COMBAT]}) /call CastMount
        | Call Buffs Array
        /if (${Zone.ShortName.Find[_]}) {
            /varset PeersZone zone_${Zone.ShortName}
        } else {
            /varset PeersZone zone_${EverQuest.Server.Lower}_${Zone.ShortName}
        }
        /for i 1 to ${Buffs.Size}
            /if (${Me.Invis}) /return
            /while (1) {
                /varset EventFlag 0
                /doevents
                /if (!${EventFlag}) /break
            }
            /if (${CalledTargetID} && !${AggroTargetID}) /call CombatTargetCheck 0
            /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) /return
            /if (${Buffs[${i}].Find[|0]}) /continue
            /if (${ChaseAssist} && !${CombatStart}) /call DoWeChase
            /if (${CuresOn}) {
                /call CheckCures Combat
            } else /if (${HealsOn}) {
                /if (!${LastHealCheck}) {
                    /call CheckHealth CheckBuffs
                    /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
                }
            } else /if (${AutoRezOn}) {
                /call RezCheck group
            }
            | If Buffs=NULL skip to next buff
            /if (${Buffs[${i}].Equal[null]}) /continue
            | Check for combat and skip redundant subs called in combat routines.
            DEBUGBUFF CheckBuffs Buff${i}: ${Buffs[${i}]}
            | Check for spells with 2 parts such as Exigent Focusing Rk. II,Talisman of Soul's Unity Rk. II - Set Buffs to the buff
            /if (${Buffs[${i}].Arg[2,|].Length}) {
                /varset FullText ${Buffs[${i}]}
                /varset SpellToCast ${Buffs[${i}].Arg[1,|]}
                /varset 2ndPart ${Buffs[${i}].Arg[2,|]}
                /varset 3rdPart ${Buffs[${i}].Arg[3,|]}
                /varset 4thPart ${Buffs[${i}].Arg[4,|]}
                /varset 5thPart ${Buffs[${i}].Arg[5,|]}
                /if (${2ndPart.Equal[Dual]}) {
                    /if (${4thPart.Equal[MA]}) {
                        /varset 2ndPart DualMA
                    } else /if (${4thPart.Equal[melee]}) {
                        /varset 2ndPart DualMelee
                    } else /if (${4thPart.Equal[caster]}) {
                        /varset 2ndPart DualCaster
                    } else /if (${4thPart.Equal[class]}) {
                        /varset 2ndPart DualClass
                    } else /if (${4thPart.Equal[!class]}) {
                        /varset 2ndPart Dual!Class
                    } else /if (${4thPart.Equal[mgb]}) {
                        /varset 2ndPart DualMgb
                    } else /if (${4thPart.Equal[me]}) {
                        /varset 2ndPart Dualme
                    }
                } else /if (${2ndPart.Equal[class]}) {
                    /varset 5thPart ${3rdPart}
                } else /if (${2ndPart.Equal[!class]}) {
                    /varset 5thPart ${3rdPart}
                } else /if (${2ndPart.Equal[alias]}) {
                    /continue
                } else /if (${2ndPart.Left[4].Equal[cond]}) {
                    /varset 2ndPart
                }
            } else {
                /varset FullText ${Buffs[${i}]}
                /varset SpellToCast ${Buffs[${i}]}
                /varset 2ndPart
                /varset 3rdPart
                /varset 4thPart
                /varset 5thPart
            }
            /if (${Me.Subscription.NotEqual[gold]}) {
                /if (${Select[${2ndPart},Dual,DualMA,DualMelee,DualCaster,DualClass,Dual!Class,DualMgb,Dualme]}==0) {
                    /if (${SpellToCast.Find[ Rk.]}) {
                        /varset BuffToCheck ${SpellToCast.Left[${Math.Calc[${SpellToCast.Find[ Rk.]}-1]}]}
                    } else {
                        /varset BuffToCheck ${SpellToCast}
                    }
                } else {
                    /if (${3rdPart.Find[ Rk.]}) {
                        /varset BuffToCheck ${3rdPart.Left[${Math.Calc[${3rdPart.Find[ Rk.]}-1]}]}
                    } else {
                        /varset BuffToCheck ${3rdPart}
                    }
                }
            } else {
                /if (${Select[${2ndPart},Dual,DualMA,DualMelee,DualCaster,DualClass,Dual!Class,DualMgb,Dualme]}==0) {
                    /varset BuffToCheck ${SpellToCast}
                } else {
                    /varset BuffToCheck ${3rdPart}
                }
            }
            DEBUGBUFF CheckBuffs 1st:${SpellToCast} 2nd: ${2ndPart} #rd: ${3rdPart} ${BuffToCheck} 4th: ${4thPart}
            /if (${Me.Book[${SpellToCast}]}) {
                /varset BookSpellTT ${Spell[${Me.Book[${Me.Book[${SpellToCast}]}].ID}].TargetType}
            } else {
                /varset BookSpellTT 0
            }
            /if (${Int[${Spell[${SpellToCast}].Range}]}>=${Int[${Spell[${SpellToCast}].AERange}]}) {
                /varset SpellRange ${Spell[${SpellToCast}].Range}
            } else {
                /varset SpellRange ${Spell[${SpellToCast}].AERange}
            }
            /if (!${SpellRange}) /varset SpellRange 100
            DEBUGBUFF CheckBuffs ${i} 1st: ${SpellToCast} 2nd: ${2ndPart} FullText: ${Buffs[${i}]} Type: ${Spell[${SpellToCast}].TargetType} ReadBuffsTimer: ${ReadBuffsTimer} IniNextTimer: ${IniNextTimer}
            DEBUGBUFF CheckBuffs Skip if Combat: ${CombatStart}  Aggro: ${AggroTargetID} IDied: ${IAmDead} ReadBTimer: ${ReadBuffsTimer} Invised: ${Me.Invis}
            /if ((${Me.CombatState.Equal[COMBAT]} && ${AggroTargetID}) || ${CombatStart}) /return
            /if (${IAmDead} || ${Me.Invis} || ${ReadBuffsTimer}) /return
            | Conditions Check
            /if (${ConOn} && ${Buffs[${i}].Find[|cond]}) {
                /varset CondNo ${Buffs[${i}].Mid[${Math.Calc[${Buffs[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            | Check for Mana/End AA Regen on others
            DEBUGBUFF CheckBuffs Start of If Structure. ${SpellToCast} ${2ndPart} ${Spell[${SpellToCast}].Mana} ${Me.CurrentMana}
            /varset MacroReturn CAST_NO_RESULT
            /if (${Select[${2ndPart},Endgroup,Managroup]}>0) {
                /if (${Group}) {
                    /if (${2ndPart.Equal[Endgroup]}) {
                        /call RegenOther "${SpellToCast}" Endurance ${3rdPart} 0 ${CondNo}
                    } else /if (${2ndPart.Equal[Managroup]}) {
                        /call RegenOther "${SpellToCast}" Mana ${3rdPart} 0 ${CondNo}
                    }
                    /varset MacroReturn ${Macro.Return}
                    /if (${MacroReturn.Equal[TRUE]}) /varcalc Buff${i}GM0 (${Spell[${SpellToCast}].Duration.TotalSeconds})*10
                }
            } else /if (${2ndPart.Equal[mana]}) {
                /if (${Me.PctMana}>${3rdPart} || ${Me.PctHPs}<${Int[${4thPart}]}) /continue
                /call CastWhat "${SpellToCast}" ${Me.ID} Buffs ${CondNo} 0
                /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                    /echo You are missing components. Turning off ${SpellToCast}.
                    /varset Buffs[${i}] NULL
                    /varset FullText NULL
                    /delay 10
                    /continue
                }
            | Combat check to skip all buffs but mana regen
            | Check and Cast endurance discs/AAs - 2nd wind, respite, etc
            } else /if (${2ndPart.Equal[End]}) {
                /if (${Me.PctEndurance}<=${3rdPart} && (${Me.CombatAbilityReady[${SpellToCast}]} || ${Me.AltAbilityReady[${SpellToCast}]})) /call CheckEndurance "${SpellToCast}" ${3rdPart} ${4thPart} ${CondNo}
            | Remove buff from |Remove tag
            } else /if (${2ndPart.Equal[Remove]} && (${Me.Buff[${SpellToCast}].ID} || ${Me.Song[${SpellToCast}].ID})) {
                /if (!${CondNo} || ${If[${Cond[${CondNo}]},1,0]}) {
                    /echo Removing Buff: ${SpellToCast}
                    /removebuff "${SpellToCast}"
                }
            | If buff cost more mana than I have skip it
            } else /if (${2ndPart.NotEqual[begfor]} && ${Spell[${SpellToCast}].Mana} && ${Spell[${SpellToCast}].Mana}>${Me.CurrentMana}) {
                /continue
            | Check if aura is up
            } else /if (${2ndPart.Equal[Aura]}) {
                /call CheckAura "${SpellToCast}" ${CondNo}
            | Check for |Once tag and turn buff off is cast is successful
            } else /if (${2ndPart.Equal[Once]}) {
                /call BuffOnce "${SpellToCast}" ${CondNo}
                /if (${Macro.Return.Equal[TRUE]}) {
                    /varset Buffs[${i}] ${SpellToCast}|0
                    /echo Buffing Once with ${SpellToCast}.
                }
            | Summon items ini example Buffs1=The Guardian's Pouch|Summon|Guardian Blade|200
            } else /if (${2ndPart.Equal[Summon]}) {
                /if (${FindItemCount[=${3rdPart}]}<${4thPart}) /call SummonStuff "${SpellToCast}" "${3rdPart}" ${4thPart} ${CondNo}
                /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                    /echo You are missing components. Turning off ${SpellToCast}.
                    /varset Buffs[${i}] NULL
                    /varset FullText NULL
                }
            } else /if (${Select[${2ndPart},mgb,dualmgb]}>0 && !${Me.Buff[${BuffToCheck}].ID}) {
                /call MassGroupBuff "${SpellToCast}" ${i} ${CondNo}
            } else /if (${2ndPart.Equal[begfor]} && !${Buff${i}GM0}) {
                | this is only run for the beggar when begging.
                /if (${Int[${3rdPart}]}>0 && ${4thPart.Equal[alias]}) {
                    /if (${Select[${5thPart},BEGFORITEMS]}>0) {
                        /if (${FindItemCount["=${SpellToCast}"]}<${3rdPart}) {
                            |"#*# KABeg for #1# #2#"
                            /call BroadCast o "KABeg for ${Me.CleanName} ${5thPart} 0"
                            /varset Buff${i}GM0 900
                        }
                    } else /if (${Select[${5thPart},BEGFORBUFFS]}>0) {
                        /if (!${Me.Buff[${SpellToCast}].ID}) {
                            /call BroadCast o "KABeg for ${Me.CleanName} ${5thPart} 0"
                            /varset Buff${i}GM0 900
                        }
                    } else {
                        /echo Invalid Option ${5thPart} for Alias. Turning Option off.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                    }
                }
            | Check for Command: tag
            } else /if (${SpellToCast.Find[command:]}) {
                /varset i_TargetID ${Int[${Target.ID}]}
                /call TargetTag "${FullText}"
                /call CastWhat "${SpellToCast}" ${Macro.Return} Buffs ${CondNo} 0
                /continue
            }
            DEBUGBUFF CheckBuffs End of If Structure. ${2ndPart}
            | Everything above is for self/group only can skip to end if 2ndPart is in list below. mana and end are exceptions.
            /if (${Select[${2ndPart},Aura,Mount,Summon,Endgroup,Managroup,Once,Remove,Mana,End,mgb,dualmgb,begfor]}) /continue
            DEBUGBUFF CheckBuffs BuffSlot: !${Int[${Me.Buff[${BuffToCheck}].ID}]} SongSlot: ${Int[${Me.Song[${BuffToCheck}].ID}]} Stacks: ${Spell[${SpellToCast}].WillLand} 2nd Part: ${Select[${2ndPart},Aura,Mount,Summon,Endgroup,Managroup,Once,Remove]}<1 Tar Type: ${Spell[${SpellToCast}].TargetType}
            DEBUGBUFF CheckBuffs Find 0: ${BookSpellTT.Find[0]} Spell TT: ${Spell[${SpellToCast}].TargetType.Find[single]} BookTT: ${BookSpellTT.Find[single]} Medding: ${Medding} MedCombat: ${MedCombat}
            | Cast buffs on MA && ${Spell[${Buffs[${i}]}].TargetType.Find[self]}
            /if (${Select[${2ndPart},MA,DualMA]}) {
                DEBUGBUFF CheckBuffs MA/DualMA Tag: ${2ndPart} ${Spawn[=${MainAssist}].ID} ${Buff${i}GM7}
                /if (${Spawn[=${MainAssist}].Distance}<=${SpellRange} && ${Spawn[=${MainAssist}].ID} && ${Buff${i}GM7}==0) {
                    DEBUGBUFF Cast buffs with MA tag ${Buffs[${i}]}
                    | Check buffs in file to see if MA has buff or its blocked
                    /if (${MainAssist.NotEqual[${Me}]}) {
                        /if (!${DanNetOn}) {
                            /if (${Ini["KissAssist_Buffs.ini",${Spawn[${MainAssistType} ${MainAssist}].ID},"Blockedbuffs"].Find[${BuffToCheck}]}) /continue
                            /if (${Ini["KissAssist_Buffs.ini",${Spawn[${MainAssistType} ${MainAssist}].ID},"Buffs"].Find[${BuffToCheck}]}) /continue
                        } else /if (${DanNet.Peers[${PeersZone}].Find[${MainAssist}|]}) {
                            /dquery ${MainAssist} -q "Me.BlockedBuff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${MainAssist} -q "Me.Buff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                        } else {
                            /continue
                        }
                    } else {
                        /if (${Me.BlockedBuff[${BuffToCheck}].ID}) /continue
                        /if (${Me.Buff[${BuffToCheck}].ID}) /continue
                    }
                    | If its a group spell cast on mercs - owner
                    /if (${Spawn[=${MainAssist}].Type.Equal[mercenary]} && ${Spell[${SpellToCast}].TargetType.Find[group v]}) {
                        /varset MATargetID ${Spawn[=${MainAssist}].Owner.ID}
                    } else /if (${Select[${Role},hunterpettank,pettank,pullerpettank]} ) {
                        /varset MATargetID ${Me.Pet.ID}
                    } else {
                        /varset MATargetID ${Spawn[=${MainAssist}].ID}
                    }
                    /if (${Cursor.ID}) /call CheckCursor CheckBuffs1 0
                    DEBUGBUFF CheckBuffs: MA Buff CastWhat "${SpellToCast}" ${MATargetID} Buffs ${CondNo}
                    /call CastWhat "${SpellToCast}" ${MATargetID} Buffs-nomem ${CondNo} 0
                    DEBUGBUFF CheckBuffs: MA Buff MacroReturn: ${Macro.Return}
                    /if (${Macro.Return.Equal[CAST_SUCCESS]} || (!${Spawn[${MainAssistType} ${MainAssist} group].ID} && ${Macro.Return.Equal[CAST_TAKEHOLD]})) {
                        /echo Buffing MA >> ${Spawn[=${MainAssist}].CleanName} << with ${SpellToCast}.
                        /varcalc Buff${i}GM7 ${Spell[${BuffToCheck}].MyDuration.TotalSeconds}*10
                        DEBUGBUFF CheckBuffs MA Buff Timer ${Buff${i}GM7}
                        /if (${MATargetID}==${Me.ID}) {
                            /varset WriteBuffsTimer 0
                            /call WriteBuffs
                        }
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_HASBUFF]}) {
                        /varcalc Buff${i}GM7 ${HasBuffDuration}*10
                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /continue
                    }
                } else {
                    /continue
                }
            | Check if buff is up and if it stacks with existing buffs
            | What about checking the timer for the buff and not the buff. Then use DanNet to see if the buff is on the other character. 
            | If not using DanNet then we could check the Buff Timer to tell if to buff or not. This will cause the caster to target all the characters to set the bufftimers the first time through
            | ${MacroQuest.InternalName.Equal[next]} or ${MacroQuest.InternalName.Equal[redguides]}
            |} else /if (BuffsNotAnItem && (${ForceGroup} || (!${Int[${Me.Buff[${BuffToCheck}].ID}]} && !${Int[${Me.Song[${BuffToCheck}].ID}]} && ${Spell[${SpellToCast}].WillLand}))) {
            } else /if (BuffsNotAnItem && (${ForceGroup} || (!${Int[${Me.Buff[${BuffToCheck}].ID}]} && !${Int[${Me.Song[${BuffToCheck}].ID}]}))) {
            |} else /if (BuffsNotAnItem) {
                DEBUGBUFF CheckBuffs -- 2nd asssigned: ${SpellToCast} TargetType: ${Spell[${SpellToCast}].TargetType} ${ForceGroup} ${DanNetOn}
                |/if (!${ForceGroup}) {
                    |/if (${DanNetOn} && ${Group}) {
                    |    /for j 1 to ${Group}
                    |        /if (${DanNet.Peers[${PeersZone}].Find[${Group.Member[${j}]}|]}) {
                    |            /dquery ${Group.Member[${j}]} -q "Me.Buff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                    |            /if (${Bool[${DNout}]}) /continue
                    |            /dquery ${Group.Member[${j}]} -q "Me.Song[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                    |            /if (${Bool[${DNout}]}) /continue
                    |            /dquery ${Group.Member[${j}]} -q "Me.BlockedBuff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                    |            /if (${Bool[${DNout}]}) /continue
                    |            /dquery ${Group.Member[${j}]} -q "Spell[${SpellToCast}].WillLand" -o DNout -t ${DanNetDelay}
                    |            /if (!${Bool[${DNout}]}) /continue
                    |            /varset Buff${i}GM${j} 0
                    |            /varset ForceGroup 1
                    |        }
                    |    /next j
                    |} else {
                    |    /if (${Int[${Me.Buff[${BuffToCheck}].ID}]} || ${Int[${Me.Song[${BuffToCheck}].ID}]} || !${Spell[${SpellToCast}].WillLand}) /continue
                    |    /if (${Group}) /varset ForceGroup 1
                    |}
                    |/if (!${ForceGroup} && ${Group}) /continue
                |}
                | If Target.Type=Group then buff self with group buff
                /if ((${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[group v]}) || ${BookSpellTT.Find[group v]}) {
                    /if (${Cursor.ID}) /call CheckCursor CheckBuffs2 0
                    /while (1) {
                        /varset EventFlag 0
                        /doevents WornOff
                        /if (!${EventFlag}) /break
                    }
                    |Added to skip group buffs that won't land(TakeHold) on the caster.
                    /if (${Buff${i}GM0}) /continue
                    /call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem ${CondNo} 0
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Buffing >> ${SpellToCast} <<
                        /doevents flush WornOff
                        /varset WriteBuffsTimer 0
                        /call WriteBuffs
                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /delay 10
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_TAKEHOLD]}) {
                        /echo Buffing >> ${SpellToCast} << TH
                        /varcalc Buff${i}GM0 ${Spell[${BuffToCheck}].MyDuration.TotalSeconds}*10
                    }
                    /if (${ForceGroup}) {
                        /while (${Me.SpellInCooldown}) {
                            /delay 5
                        }
                        /continue
                    }
                | If Target.Type=Single then buff each party member with single buff
                } else /if ((${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[single]}) || ${BookSpellTT.Find[single]}) {
                    |/if (${Buff${i}GM0}) /varset Buff${i}GM0 0
                    /if (${Group}) {
                        |/if (${Me.CurrentMana}>=${Math.Calc[${Spell[${SpellToCast}].Mana}*${Group}]}) {
                        |/if (${Me.CurrentMana}>=${Spell[${SpellToCast}].Mana}) {
                            DEBUGBUFF CheckBuffs Single Type Group Buff
                            /for j ${Group} downto 0
                                |/echo ${j} ${Buff${i}GM${j}}
                                DEBUGBUFF CheckBuffs !${Group.Member[${j}].ID} ${Spawn[${Group.Member[${j}]}].Distance} ${SpellRange} ${2ndPart.Equal[Me]} ${j}>=1 ${2ndPart.Equal[MA]} ${Group.Member[${j}].ID}!=${Spawn[${MainAssistType} ${MainAssist}].ID} ${Buff${i}GM${j}} ${Me.Invis}
                                /if (${Me.Invis}) /break
                                | Check if party member is alive in zone and within spell range and spell timer does not exist
                                /if (!${Group.Member[${j}].ID} || ${Spawn[${Group.Member[${j}]}].Distance}>=${SpellRange} || ${Buff${i}GM${j}}) /continue
                                /if (${Select[${2ndPart},me,dualme]} && ${j}>0) /continue
                                /if (${Me.CurrentMana}<${Spell[${SpellToCast}].Mana}) /break
                                DEBUGBUFF CheckBuffs 3 ${2ndPart.Equal[caster]} ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]} ${2ndPart.Equal[Melee]} ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}
                                /if ((${Select[${2ndPart},caster,DualCaster]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${Select[${2ndPart},Melee,DualMelee]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /continue
                                /if (${Select[${2ndPart},class,dualclass]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},${5thPart}]}==0) /continue
                                /if (${Select[${2ndPart},!class,dual!class]}>0 && ${Select[${Group.Member[${j}].Class.ShortName},${5thPart}]}>0) /continue
                                /if (${Select[${2ndPart},MA,Dualma]}>0 && ${Group.Member[${j}].ID}!=${Spawn[${MainAssistType} ${MainAssist}].ID}) /continue
                                /if (${2ndPart.Equal[!MA]} && ${Group.Member[${j}].ID}==${Spawn[${MainAssistType} ${MainAssist}].ID}) /continue
                                /if (${Cursor.ID}) /call CheckCursor CheckBuffs3 0
                                /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) {
                                    /return
                                } else /if (${Me.Gem[${SpellToCast}]}) {
                                    /if (${Me.GemTimer[${SpellToCast}].TotalSeconds}>6) /continue
                                    /while (!${Me.SpellReady[${SpellToCast}]}) {
                                        /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) /return
                                        /delay 5
                                    }
                                }
                                /while (1) {
                                    /varset EventFlag 0
                                    /doevents WornOff
                                    /if (!${EventFlag}) /break
                                }
                                /call CastWhat "${SpellToCast}" ${Group.Member[${j}].ID} Buffs-nomem ${CondNo} 0
                                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                    /echo Buffing ${SpellToCast} on ${Group.Member[${j}].CleanName}
                                    /varcalc Buff${i}GM${j} ${Spell[${BuffToCheck}].MyDuration.TotalSeconds}*10
                                    /doevents flush WornOff
                                    /if (${j}==0) {
                                        /varset WriteBuffsTimer 0
                                        /call WriteBuffs
                                    }
                                } else /if (${Macro.Return.Equal[CAST_HASBUFF]}) {
                                    /varcalc Buff${i}GM${j} ${HasBuffDuration}*10
                                } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                                    /echo You are missing components. Turning off ${SpellToCast}.
                                    /varset Buffs[${i}] NULL
                                    /varset FullText NULL
                                    /continue
                                }
                                /if (${BuffsOn}==1) /continue
                                /if (${Select[${Group.Member[${j}].Class.ShortName},CLR,PAL,WIZ,BRD,BER,MNK,ROG,RNG,WAR]}) /continue
                                /if (${DanNetOn} && ${Group.Member[${j}].Pet.ID}) {
                                    /if (!${DanNet.Peers[${PeersZone}].Find[${Group.Member[${j}]}|]}) /continue
                                    /dquery ${Group.Member[${j}]} -q "Me.BlockedPetBuff[${BuffToCheck}].ID" -o DNout -t ${DanNetDelay}
                                    /if (${Bool[${DNout}]}) /continue
                                    /dquery ${Group.Member[${j}]} -q "Me.Pet.Buff[${BuffToCheck}]" -o DNout -t ${DanNetDelay}
                                    /if (${Bool[${DNout}]}) /continue
                                    /dquery ${Group.Member[${j}]} -q "Spell[${BuffToCheck}].StacksPet[0]" -o DNout -t ${DanNetDelay}
                                    /if (!${Bool[${DNout}]}) /continue
                                    /dquery ${Group.Member[${j}]} -q "Me.Pet.Name" -o DNout -t ${DanNetDelay}
                                    /if (!${Bool[${DNout}]}) /continue
                                    /while (1) {
                                        /varset EventFlag 0
                                        /doevents WornOff
                                        /if (!${EventFlag}) /break
                                    }
                                    /while (${Me.SpellInCooldown}) {
                                        /delay 5
                                    }
                                    /call CastWhat "${SpellToCast}" ${DNout} Buffs-nomem ${CondNo} 0
                                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                        /echo Buffing ${SpellToCast} on ${Group.Member[${j}].CleanName} Pet ${DNout}
                                        |Have to create a different timer for group pets.
                                        /doevents flush WornOff
                                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                                        /echo You are missing components. Turning off ${SpellToCast}.
                                        /varset Buffs[${i}] NULL
                                        /varset FullText NULL
                                        /continue
                                    }
                                }
                            /next j
                        |} else {
                        |    /continue
                        |}
                    } else /if (${Select[${2ndPart},MA,Melee,Caster,DualMA,DualMelee,DualCaster,class,!class,dualclass,dual!class]}==0) {
                        DEBUGBUFF CheckBuffs 4 ${2ndPart} 
                        /if (${Cursor.ID}) /call CheckCursor CheckBuffs4 0
                        /while (1) {
                            /varset EventFlag 0
                            /doevents WornOff
                            /if (!${EventFlag}) /break
                        }
                        /call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem ${CondNo} 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /echo Buffing ${SpellToCast} on ${Group.Member[${j}].CleanName}
                            /varcalc Buff${i}GM0 ${Spell[${BuffToCheck}].MyDuration.TotalSeconds}*10
                            /doevents flush WornOff
                            /varset WriteBuffsTimer 0
                            /call WriteBuffs
                        } else /if (${Macro.Return.Equal[CAST_HASBUFF]}) {
                            /varcalc Buff${i}GM0 ${HasBuffDuration}*10
                        } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                            /echo You are missing components. Turning off ${SpellToCast}.
                            /varset Buffs[${i}] NULL
                            /varset FullText NULL
                            /varset SpellToCast
                            /continue
                        }
                    }
                | If Target.Type=self then buff self
                } else /if ((${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[self]}) || ${BookSpellTT.Find[self]}) {
                    DEBUGBUFF CheckBuffs Self Buff ${Me.Buff[${BuffToCheck}].ID} ${Me.Song[${BuffToCheck}].ID} ${Spell[${BuffToCheck}].WillLand}
                    /if (${Me.Buff[${BuffToCheck}].ID} || ${Me.Song[${BuffToCheck}].ID} || !${Spell[${BuffToCheck}].WillLand}) /continue
                    /call CastWhat "${SpellToCast}" ${Me.ID} Buffs-nomem ${CondNo} 0
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /delay 10
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Casting ${SpellToCast} on me.
                        /delay 10
                    }
                | Check if buff needs pet as target ie Mage's Symbiosis line of mana buffs
                } else /if (${Me.Pet.ID} && (${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[pet]} || ${Select[${Spell[${Spell[${SpellToCast}].ID}].Name.Arg[2,]},Symbiosis,Siphon,Simulacrum,Draw]})) {
                    DEBUGBUFF CheckBuffs Self Buff that targets pet ie mage mana buff line
                    /call CastWhat "${SpellToCast}" ${Me.Pet.ID} Buffs ${CondNo} 0
                }
                | If buff is an item click it
            } else /if (${FindItem[=${SpellToCast}].Spell.WillLand} && !${Int[${Me.Buff[${BuffToCheck}].ID}]} && ${Me.ItemReady[${SpellToCast}]} && ${Select[${2ndPart},Aura,Mount,Mana]}==0) {
                DEBUGBUFF CheckBuffs Items
                /if (${Me.Buff[${BuffToCheck}].ID} || ${Me.Song[${BuffToCheck}].ID}) /continue
                /if (!${Me.Invis}) {
                    | Call of the wild ear fix
                    /if (${SpellToCast.Equal[Call of the Wild]}) {
                        /useitem "Call of the Wild"
                        /delay 15
                    } else {
                        /call CastWhat "${SpellToCast}" ${Me.ID} Buffs ${CondNo} 0
                    }
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Clicking > ${SpellToCast} <
                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${SpellToCast}.
                        /varset Buffs[${i}] NULL
                        /varset FullText NULL
                        /delay 10
                        /continue
                    }
                }
            }
            DEBUGBUFF CheckBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${SpellToCast}]}>=1 Self:${Spell[${SpellToCast}].TargetType.Find[self]}
            | If Buff is a Mana,Aura,Mount,Me,dualme,Summon,End, an item, self buff or Spawn ID is me skip ini check because none of these are cast on others
            /if (${Select[${2ndPart},me,dualme]} || ${Me.Invis}) /continue
            /if ((${FindItemCount[=${SpellToCast}]}>=1 && ${Spell[${SpellToCast}].TargetType.Equal[self]}) || (${FindItemCount[${SpellToCast}]}>=1 && ${Spell[${BuffToCheck}].TargetType.Equal[self]}) || (${BookSpellTT.Find[0]} && ${Spell[${SpellToCast}].TargetType.Find[self]}) || ${BookSpellTT.Find[self]} || ${BookSpellTT.Find[pet]}) /continue
            /if (${Redguides} && !${IniNextTimer} && !${CombatStart}) /call CheckiniBuffs "${SpellToCast}" ${i} ${SpellRange} "${BuffToCheck}" "${2ndPart}" "${3rdPart}" "${4thPart}" "${5thPart}" "${BookSpellTT}" ${CondNo}
            DEBUGBUFF CheckBuffs reset var ${i} ${Buffs[${i}]}
        /next i
        /if (${PowerSource.NotEqual[NULL]} && !${Bool[${Me.Inventory[powersource].Name.Length}]} && ${FindItemCount[=${PowerSource}]}) {
            /exchange "${PowerSource}" powersource
            /if (${FindItem[=${PowerSource}].Attuneable}) {
                /delay 20 ${Window[confirmationdialogbox].Open}
                /if (${Window[confirmationdialogbox].Open}) {
                    /notify confirmationdialogbox CD_Yes_Button leftmouseup
                    /delay 20 !${Window[confirmationdialogbox].Open}
                }
            }
        }
        /if (!${ReadBuffsTimer} && !${AggroTargetID}) /varset ReadBuffsTimer ${CheckBuffsTimer}s
        /if (${Macro.RunTime}>120 && !${IniNextTimer}) /varset IniNextTimer 30s
        /if (${MiscGemRemem} && (${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscSpell}]} || ${ReMemCastLW})) {
            /varset DontMoveMe 1
            /varset ReMemCast 1
            /call CastReMem "${ReMemMiscSpell}" 1 buffs
            /varset DontMoveMe 0
        }
        DEBUGBUFF CheckBuffs Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: TargetTag
| -------------------------------------------------------------------------------------
    Sub TargetTag(TargetTagText)
        /declare TagReturn string local
        /if (${TargetTagText.Find[|pet]}) {
            /varset TagReturn ${Pet.ID}
        } else /if (${TargetTagText.Find[|me]}) {
            /varset TagReturn ${Me.ID}
        } else /if (${TargetTagText.Find[|ma]}) {
            /varset TagReturn ${MainAssistID}
        } else {
            /varset TagReturn 0
        }
    /return ${TagReturn}
| -------------------------------------------------------------------------------------
| SUB: BuffOnce
| -------------------------------------------------------------------------------------
    Sub BuffOnce(OnceSpell, int CondNumber)
        /if (${Me.Invis}) /return
        /declare OnceResult string local FALSE
        /if (!${CondNumber} || ${If[${Cond[${CondNumber}]},1,0]}) {
            /call CastWhat "${OnceSpell}" ${Me.ID} BuffOnce 0 0
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /varset OnceResult TRUE
            } else {
                /varset OnceResult ${Macro.Return}
            }
        }
    /return ${OnceResult}
| -------------------------------------------------------------------------------------
| SUB: CheckAura | Check if aura is up
| -------------------------------------------------------------------------------------
    Sub CheckAura(AuraSpell, int CondNumber)
        /if (${Me.Invis}) /return
        DEBUGBUFF CheckAura Spell: ${AuraSpell} Enter
        /declare AuraName string local
        /declare TempAura string local
        /declare AuraResult string local FALSE
        | Strip the Rk II/III out of the spell to check against aura window
        /if (${AuraSpell.Find[ Rk.]}) {
            /varset AuraName ${AuraSpell.Left[${Math.Calc[${AuraSpell.Find[ Rk.]}-1]}]}
        } else {
            /varset AuraName ${AuraSpell}
        }
        /if (${AuraSpell.Find[Disciple's Aura]}) {
        | Correct typo from SOE in monks 55 level aura
            /varset AuraName Disciples Aura
        } else /if (${Me.Class.Name.Equal[cleric]} && ${AuraSpell.Find[Reverent]}) {
            | Cleric exception for Reverent Aura
            /varset AuraName Reverent Aura
        } else /if (${AuraSpell.Find[Mana Reiteration]}) {
            /varset AuraName Mana Recursion Aura
        } else /if (${AuraSpell.Find[Mana Reiterate]}) {
            /varset AuraName Mana Reiterate Aura
        } else /if (${AuraSpell.Find[Mana Reverberation]}) {
            /varset AuraName Mana Rev.
        } else /if (${AuraSpell.Find[Mana Resurgence]}) {
            /varset AuraName Mana Resurgence Aura
        } else /if (${AuraSpell.Find[Mana Repercussion Aura]}) {
            /varset AuraName Mana Rep. Aura
        } else /if (${AuraSpell.Find[Runic Radiance Aura]}) {
            /varset AuraName Runic Rad. Aura
        } else /if (${AuraSpell.Find[Arcane Distillect]}) {
            | Mage exceptions because aura is on pet not in aura window and other fucked up shit
            /varset TempAura Arcane Distillect
        } else /if (${AuraSpell.Find[Earthen Strength]}) {
            /varset TempAura Earthen Strength Effect
        } else /if (${AuraSpell.Find[Rathe's Strength]}) {
            /varset TempAura Rathe's Strength Effect
        }
        | Check if aura is up 4 parts - Mage | Everyone else | 2 auras cleric | 2 auras enchamter
        /if (${Select[${Me.Class.ShortName},CLR,ENC,MAG]}==0 && ${Me.Aura[1].Name.Find[${AuraName}]}) {
            /return ${AuraResult}
        } else /if (${Me.Class.ShortName.Equal[MAG]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<175) {
            /if (${Me.Aura[1].Name.Find[${TempAura}]}) {
                /return ${AuraResult}
            } else /if (${Me.PetBuff[${TempAura}]}) {
                /return ${AuraResult}
            }
        } else /if (${Select[${Me.Class.ShortName},CLR,ENC]} && (${Me.Aura[1].Name.Find[${AuraName}]} || ${Me.Aura[2].Name.Find[${AuraName}]})) {
            /return ${AuraResult}
        }
        DEBUGBUFF CheckAura Aura
        | - Mutant Bards do this. Not any more.
        /if (!${CondNumber} || ${If[${Cond[${CondNumber}]},1,0]}) {
            | - Normal casting
            /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]} && ${Me.CurrentEndurance}>500) {
                /disc ${AuraSpell}
                /delay 10
                /while (${Me.Casting.ID} && ${Window[CastingWindow].Open}) {
                    /delay 5
                }
                /varset AuraResult TRUE
                /return ${AuraResult}
            } else {
                /varset DontMoveMe 1
                /call CastWhat "${AuraSpell}" ${Me.ID} CheckAura 0 0
                /varset DontMoveMe 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting Aura >> ${AuraSpell} <<
                    /varset AuraResult TRUE
                } else {
                    /varset AuraResult ${Macro.Return}
                }
            }
        }
    /return ${AuraResult}
| -------------------------------------------------------------------------------------
| SUB: CheckEndurance
| -------------------------------------------------------------------------------------
    Sub CheckEndurance(ESpell,EPct,EHealth,int CondNumber)
        /if (${Me.Invis}) /return
        /declare EndResult string local FALSE
        DEBUGBUFF CheckAura Enter Spell: ${ESpell} EndPct: ${EPct} HealthPct: ${EHealth}
        /if (${EHealth.Equal[null]} || !${EHealth.Length}) /varset EHealth 0
        DEBUGBUFF CheckAura Endurance Regen
        /if (${Me.Sitting}) /stand
        /call CastWhat "${ESpell}" ${Me.ID} CheckEndurance ${CondNumber} 0
        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
            /varset EndResult TRUE
            /echo Casting >> ${ESpell} << for endurance
        } else {
            /varset EndResult ${Macro.Return}
        }
        DEBUGBUFF CheckAura Leave
    /return ${EndResult}
| -------------------------------------------------------------------------------------
| SUB: SummonStuff
| -------------------------------------------------------------------------------------
    Sub SummonStuff(SSpell,SumItem,int SumNum,int CondNumber)
        /if (${Me.Invis}) /return
        /if (${FindItemCount[=${SumItem}]}>=${SumNum}) /return 0
        /declare SumResult string local FALSE
        /declare SummonAttempts int local 0
        /declare CurrentCount int local 0
        /declare OriginalCount int local ${FindItemCount[=${SumItem}]}
        DEBUGBUFF SummonStuff Enter SSpell: ${SSpell} SumItem: ${SumItem} SumNum: ${SumNum}
        /if (${CondNumber} && ${If[${Cond[${CondNumber}]},0,1]}) /return 0
        /while (${FindItemCount[=${SumItem}]}<${SumNum}) {
            /if (${Me.FreeInventory}==0) {
                /echo No room in inventory skipping summoning >> ${SumItem} <<.
                /break
            }
            /varset CurrentCount ${FindItemCount[=${SumItem}]}
            | Summon axes for zerkers had to be hard coded because spell is same name as the item summoned.
            /if (${Select[${Me.Class.ShortName},BER]} && ${SSpell.Find[axe]}) {
                /doevents flush Missing
                /if (!${Me.CombatAbility[${SSpell}]}) {
                    /varset SumResult CAST_COMPONENTS
                    /return ${SumResult}
                }
                /if (${Cursor.ID}) /call CheckCursor SummonStuff 1
                /docommand /disc ${SSpell}
                /varset MissingComponent 0
                /call CastWait "${SSpell}" SummonStuff
                /doevents Missing
                /if (!${MissingComponent} && !${Cursor.ID}) {
                    /delay 20 ${Cursor.ID}
                }
                /if (${Cursor.ID}) {
                    /varcalc SummonAttempts ${SummonAttempts}+1
                    /varset SumResult CAST_SUCCESS
                } else {
                    /if (!${MissingComponent}) {
                        /doevents Missing
                    } else {
                        /varset SumResult CAST_COMPONENTS
                    }
                }
            } else {
                | Check if summoning from an item
                /if (${FindItemCount[=${SSpell}]} > 0) {
                    | Check if item is ready to cast
                    /if (${FindItem[=${SSpell}].Timer}!=0) {
                        DEBUGBUFF ${SSpell} not ready yet skipping
                        /varset SumResult CAST_NOT_READY
                        /return ${SumResult}
                    }
                }
                /if (${Cursor.ID}) /call CheckCursor SummonStuff 1
                /call CastWhat "${SSpell}" ${Me.ID} SummonStuff-nomem 0 0
                /varset SumResult ${Macro.Return}
            }
            DEBUGBUFF CheckBuffs summon item cast result ${Macro.Return} ${SumResult}
            /if (${SumResult.Equal[CAST_SUCCESS]}) {
                /delay 5s ${Cursor.ID}
                /if (${Cursor.ID}) {
                    /echo Summoned  >> ${SumItem} <<
                    /varcalc SummonAttempts ${SummonAttempts}+1
                    /call CheckCursor SummonStuff 1
                } else /if (${FindItemCount[=${SumItem}]}==${CurrentCount} && ${SummonAttempts}>0) {
                    /echo Summoning >> ${SumItem} << Failed - Check reagents, timer, etc
                    /echo -- Turning off ${SSpell} - ${SSpell}|Summon|${SumItem}|0
                    /varset SummonAttempts 0
                    /varset SumResult CAST_COMPONENTS
                    /break
                }
            } else /if (${SumResult.Equal[CAST_COMPONENTS]}) {
                /echo You are missing components. Turning Off ${SSpell}.
                /break
            } else /if (${Select[${SumResult},CAST_NO_RESULT,CAST_RECOVER]}) {
                /break
            }
            /if (${SummonAttempts}>5) /break
        }
        /if (${Cursor.ID}) /call CheckCursor SummonStuff 0
        /if (${FindItemCount[=${SumItem}]}>${OriginalCount}) /echo I now have ${FindItemCount[=${SumItem}]} of >> ${SumItem} <<
        DEBUGBUFF SummonStuff Leave ${Me.FreeInventory} ${SumResult} ${SummonAttempts}
    /return ${SumResult}
| -------------------------------------------------------------------------------------
| SUB: CheckIniBuffs
| -------------------------------------------------------------------------------------
    Sub CheckIniBuffs(SpellName, BuffsNum, int BuffRange, BuffName, 2ndPart, 3rdPart, 4thPart, 5thPart, BookTT, int CondNumber)
        DEBUGBUFF CheckIniBuffs Enter ${SpellName} ${BuffsNum} ${BuffRange} ${BuffName} ${2ndPart} ${3rdPart} ${4thPart} ${5thPart} ${BookTT} ${CondNumber} ${Me.Invis}
        /if (${Me.Invis}) /return
        /declare k int local
        /declare l int local
        | Assign var IniIDList all the spawn ids from buff ini file 2345|2195|2391| etc
        /declare IniIDList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare SearchList string local
        /declare IniIDCount int local ${IniIDList.Count[|]}
        /declare SearchCount int local 0
        /declare IniBuffCount int local 0
        /declare IniBBuffList string local
        /declare IniBuffList string local
        /declare SearchBuffList string local
        /declare IniStackCheck[50] string local
        /declare PBTimerID string local
        /declare IniTempBuff string local
        /declare skipFlag int local 0
        /declare TryToBuffID int local 0
        /declare TryToBuffName string local
        /declare MercID int local 0
        /declare MercIDList string local
        /declare WhileFlag int local 1
        /while (${WhileFlag}) {
            /if (${Me.Invis}) /break
            | Check Buffs from ini
            /if (!${DanNetOn}) {
                | 1 = Ini File, 2 = Too Buff List
                /if (${WhileFlag}==1) {
                    /varset SearchList ${Ini["KissAssist_Buffs.ini"]}
                    /varset SearchCount ${IniIDList.Count[|]}
                } else {
                    /varset SearchList ${ExtendedBuffList}
                    /varset SearchCount ${ExtendedBuffList.Count[|]}
                }
            } else {
                | 1 = Characters using DanNet, 2 = Mercenaries in the area
                | 3 = Too Buff List, 4 = Pets of Characters using DanNet
                /if (${WhileFlag}==1 || ${WhileFlag}==4) {
                    /if (${Zone.ShortName.Find[_]}) {
                        /varset SearchList ${DanNet.Peers[zone_${Zone.ShortName}]}
                    } else {
                        /varset SearchList ${DanNet.Peers[zone_${EverQuest.Server.Lower}_${Zone.ShortName}]}
                    }
                    /varset SearchCount ${SearchList.Count[|]}
                } else /if (${WhileFlag}==2) {
                    | This is for Mercenaries in other groups.
                    /if (${SpawnCount[mercenary zradius 20 radius ${BuffRange}]}>0) {
                        /varset SearchCount ${SpawnCount[mercenary zradius 20 radius ${BuffRange}]}
                        /if (${Zone.ShortName.Find[_]}) {
                            /varset SearchList ${DanNet.Peers[zone_${Zone.ShortName}]}
                        } else {
                            /varset SearchList ${DanNet.Peers[zone_${EverQuest.Server.Lower}_${Zone.ShortName}]}
                        }
                        /for l 1 to ${SearchCount}
                            /varset MercID ${NearestSpawn[${l},mercenary zradius 20 radius ${BuffRange}].ID}
                            /if (${SearchList.Find[${Spawn[id ${MercID}].Owner.CleanName}|]}) {
                                /varset MercIDList ${MercIDList}|${MercID}
                            }
                        /next SearchCount
                        /varset SearchList ${MercIDList}|
                        /varset SearchCount ${SearchList.Count[|]}
                    }
                } else {
                    /varset SearchList ${ExtendedBuffList}
                    /varset SearchCount ${ExtendedBuffList.Count[|]}
                }
            }
            /if (${Redguides}) {
                | IniIDCount = number of Char IDs counted in ini file. If 0 skip or Buff is null the the process.
                /if (${SearchCount}<=0 || ${SpellName.Equal[null]} || (${2ndPart.Equal[Dual]} && ${BuffName.Equal[null]})) /return
                | Check if invalid spell and we don't have the item
                /if (!${Spell[${SpellName}].ID} && !${FindItemCount[=${SpellName}]}) /return
                | Start scan of buffs listed on toons in ini file
                /for k 1 to ${SearchCount}
                    /if (${Me.Invis}) /break
                    /varset skipFlag 0
                    /if (${AggroTargetID} && ${Spawn[${AggroTargetID}].Distance}<200) /return
                    /if (!${DanNetOn}) {
                        | 1 = Ini File, 2 = Too Buff List
                        /if (${WhileFlag}==1) {
                            /varset TryToBuffID ${Int[${SearchList.Arg[${k},|]}]}
                            /varset TryToBuffName ${Spawn[${TryToBuffID}].CleanName}
                        } else {
                            /varset TryToBuffName ${SearchList.Arg[${k},|]}
                            /varset TryToBuffID ${Int[${Spawn[=${TryToBuffName}].ID}]}
                        }
                    } else {
                        | 1 = Characters using DanNet, 2 = Mercenaries in the area
                        | 3 = Too Buff List, 4 = Pets of Characters using DanNet
                        /if (${WhileFlag}!=2) {
                            /varset TryToBuffName ${SearchList.Arg[${k},|]}
                            /varset TryToBuffID ${Int[${Spawn[=${TryToBuffName}].ID}]}
                        } else {
                            /varset TryToBuffID ${Int[${SearchList.Arg[${k},|]}]}
                            /varset TryToBuffName ${Spawn[${TryToBuffID}].CleanName}
                        }
                    }
                    |/echo ${TryToBuffID} ${TryToBuffName}
                    /if (!${TryToBuffID} || !${Spawn[id ${TryToBuffID}].ID}) /continue
                    | If the Spawn ID is not in the zone and not a PC/merc and not me skip to next ID
                    /if (${Select[${Spawn[${TryToBuffID}].Type},AURA,BANNER,CAMPFIRE,CORPSE,CHEST,ITEM,NPC,TRIGGER,TRAP,TIMER,MOUNT]} || ${TryToBuffID}==${Me.ID}) /continue
                    | If Buff is a Mana,Aura,Mount,Me,Summon,End, an item, self buff or Spawn ID is me skip because none of these are cast on others
                    DEBUGBUFF CheckINIBuffs  IniBuffCheck 1: Mana,Aura,Mount,Me,Summon,End:${Select[${2ndPart},Mana,Aura,Mount,Me,Summon,End,0]} Item:${FindItemCount[=${SpellName}]}>=1 Self:${Spell[${SpellName}].TargetType.Find[self]}
                    | Set buff to correct spell to check for with Dual tag
                    /if ((${2ndPart.Find[Dual]} && ${Spell[${SpellName}].TargetType.Equal[self]}) || ${Spell[${BuffName}].TargetType.Equal[self]} || ${BookTT.Equal[self]}) /return
                    | Check for Group only spells and skip NON group members.
                    | If buff marked MA skipped if spawn ID isn't MA
                    /if (${Select[${2ndPart},MA,DualMA]} && ${Spawn[${TryToBuffID}].CleanName.NotEqual[${MainAssist}]} || ${2ndPart.Equal[!MA]} && ${Spawn[${TryToBuffID}].CleanName.Equal[${MainAssist}]}) /continue
                    /if ((${Select[${2ndPart},Caster,DualCaster]}>0 && ${Select[${Spawn[${TryToBuffID}].Class.ShortName},CLR,DRU,SHM,BST,ENC,MAG,NEC,PAL,SHD,RNG,WIZ]}==0) || (${Select[${2ndPart},Melee,DualMelee]}>0 && ${Select[${Spawn[${TryToBuffID}].Class.ShortName},BRD,BER,BST,MNK,PAL,ROG,RNG,SHD,WAR]}==0)) /continue
                    /if (${Select[${2ndPart},class,dualclass]}>0 && ${Select[${Spawn[${TryToBuffID}].Class.ShortName},${5thPart}]}==0) /continue
                    /if (${Select[${2ndPart},!class,!dualclass]}>0 && ${Select[${Spawn[${TryToBuffID}].Class.ShortName},${5thPart}]}) /continue
                    DEBUGBUFF CheckINIBuffs  IniBuffCheck 1.1: 2ndPart: ${2ndPart} Class Name: ${Spawn[${IniIDList.Arg[${k},|]}].Class.ShortName}
                    | Temp variable to store buff name after stripping rk stuff makes it easier to compare
                    /if (${BuffName.Find[ Rk.]}) {
                        /varset IniTempBuff ${BuffName.Left[${Math.Calc[${BuffName.Find[ Rk.]}-1]}]}
                    } else {
                        /varset IniTempBuff ${BuffName}
                    }
                    DEBUGBUFF CheckINIBuffs  IniBuffCheck 2: ${Spawn[${IniIDList.Arg[${k},|]}].Name} ${IniIDList.Arg[${k},|]} ${IniTempBuff} ${BuffName}
                    /if (!${DanNetOn}) {
                        | 1 = Ini File, 2 = Too Buff List
                        /if (${WhileFlag}==1) {
                            | Assign var IniBBuffList blocked buffs list from ini file
                            /varset IniBBuffList ${Ini["KissAssist_Buffs.ini",${TryToBuffID},"Blockedbuffs"]}
                            | If the current buff is on the blocked buff list skip it.
                            DEBUGBUFF CheckINIBuffs  IniBuffCheck 3: ${IniBBuffList.Find[${IniTempBuff}]} Buff blocked?
                            /if (${IniBBuffList.Find[${IniTempBuff}]}) /continue
                            | Assign var IniBuffList buffs list from ini file
                            /varset IniBuffList ${Ini["KissAssist_Buffs.ini",${TryToBuffID},"Buffs"]}
                            | If current buff is on the buff list skip it
                            DEBUGBUFF CheckINIBuffs IniBuffCheck 4: ${IniTempBuff} ${IniBuffList.Find[${IniTempBuff}]}
                            /if (${IniBuffList.Find[${IniTempBuff}]}) /continue
                            | Assign buff count
                            /varset IniBuffCount ${IniBuffList.Count[|]}
                            | Check if current buff stacks will all existing buffs in list
                            DEBUGBUFF CheckINIBuffs  IniBuffCheck 5: ${Spawn[${TryToBuffID}].Name} ${IniBuffCount} BuffsNum ${SpellName}
                            /for l 1 to ${IniBuffCount}
                                | Fix for stacking issues with Perfected Group Levitation there are a lot
                                /if (${IniBuffList.Arg[${l},|].Find[Group Perfected Levitation]} && !${SpellName.Find[Group Perfected Levitation]}) /continue
                                /if (!${Spell[${IniTempBuff}].RankName.WillStack[${IniBuffList.Arg[${l},|]}]}) {
                                    /varset skipFlag 1
                                    DEBUGBUFF CheckINIBuffs IniBuffCheck Stack: ${IniBuffList.Arg[${l},|]} !Stack ${SpellName} ${Select[${Spell[${IniTempBuff}].RankName.WillStack[${IniBuffList.Arg[${l},|]}]},TRUE,FALSE,NULL]}
                                    /break
                                }
                            /next l
                        }
                    } else {
                        | 1 = Characters using DanNet, 2 = Mercenaries in the area
                        | 3 = Too Buff List, 4 = Pets of Characters using DanNet
                        /if (${WhileFlag}==1) {
                            | Is buff in Blocked Buff List?
                            /dquery ${TryToBuffName} -q "Me.BlockedBuff[${IniTempBuff}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Me.Buff[${IniTempBuff}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Me.Song[${IniTempBuff}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Spell[${IniTempBuff}].Stacks[0]" -o DNout -t ${DanNetDelay}
                            /if (!${Bool[${DNout}]}) /continue
                        } else /if (${WhileFlag}==4) {
                            |Do I have a pet?
                            /dquery ${TryToBuffName} -q "Me.Pet.ID" -o DNout -t ${DanNetDelay}
                            /if (!${Bool[${DNout}]}) /continue
                            /varset TryToBuffID ${DNout}
                            /dquery ${TryToBuffName} -q "Me.BlockedPetBuff[${IniTempBuff}].ID" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Me.Pet.Buff[${IniTempBuff}]" -o DNout -t ${DanNetDelay}
                            /if (${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Spell[${IniTempBuff}].StacksPet[0]" -o DNout -t ${DanNetDelay}
                            /if (!${Bool[${DNout}]}) /continue
                            /dquery ${TryToBuffName} -q "Me.Pet.Name" -o DNout -t ${DanNetDelay}
                            /varset TryToBuffName ${DNout}
                        }
                    }
                    /if (!${skipFlag}) {
                        | varset ini buff timer toon Id spell Id to shorten var and clarity
                        /varset PBTimerID ${TryToBuffID}${Spell[${SpellName}].ID}
                        | Define timer for spell i am about to cast
                        /if (!${Defined[ExtBuffTimer${PBTimerID}]}) /declare ExtBuffTimer${PBTimerID} timer outer 0
                        DEBUGBUFF CheckINIBuffs IniBuffCheck 6: ${Spawn[${TryToBuffID}].Name} Temp:${IniTempBuff} OnList:${IniBuffList.Find[${IniTempBuff}]} Timer:${ExtBuffTimer${PBTimerID}}
                        | Check if toon is within spell range and cast buff
                        /if (${Spawn[${TryToBuffID}].Distance}<=${BuffRange} && !${ExtBuffTimer${PBTimerID}}) {
                            /if (${Spell[${SpellName}].TargetType.Equal[self]} && ${TryToBuffID}!=${Me.ID}) {
                                DEBUGBUFF CheckINIBuffs tried to buff ${Spawn[${TryToBuffID}].CleanName} with a self buff
                                /continue
                            }
                            /if (${Me.SpellInCooldown} && !${IAmABard}) {
                                /while (${Me.SpellInCooldown}) {
                                    /delay 5
                                }
                            }
                            /call CastWhat "${SpellName}" ${TryToBuffID} Buffs ${CondNumber} 0
                            DEBUGBUFF CheckINIBuffs IniBuffCheck 7: "${SpellName}" ${TryToBuffID} Buffs 0 ${Macro.Return}
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /echo Buffing >> ${SpellName} << on ${TryToBuffName}
                                /varset ExtBuffTimer${PBTimerID} 60s
                                /varset IniNextTimer 0
                                /doevents flush WornOff
                                /varset WriteBuffsTimer 0
                                /call WriteBuffs
                            } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                                /echo You are missing components. Turning off ${BuffName}.
                                /varset Buffs[${BuffsNum}] NULL
                                /varset SpellName
                                /continue
                            } else /if (${Macro.Return.Equal[CAST_HASBUFF]}) {
                                /varset ExtBuffTimer${PBTimerID} ${HasBuffDuration}*10
                                /varset IniNextTimer 0
                            }
                        }
                        DEBUGBUFF CheckINIBuffs IniBuffCheck 8: ExtBuffTimer${PBTimerID}:${ExtBuffTimer${PBTimerID}} IniNextTimer:${IniNextTimer}
                    }
                /next k
            }
            /if (!${DanNetOn} && ${WhileFlag}==2) {
                /break
            } else /if (${DanNetOn} && ${WhileFlag}==4) {
                /break
            }
            /varcalc WhileFlag ${WhileFlag}+1
        }
        DEBUGBUFF CheckIniBuffs Leave
    /return
| ----------------------------------------------------------------------------
| SUB: RegenOther
| ----------------------------------------------------------------------------
    Sub RegenOther(RGName, Stat, int StatPct, RegonOnClasses, int CondNumber)
    | Casting on others during combat will interrupt fast med
    /if (${Medding} && ${MedCombat}) /return FALSE
    /if (${Me.Invis}) /return FALSE
        DEBUGBUFF RegenOther Enter  ${RGName} ${Stat} ${StatPct} ${RegonOnClasses}
        /declare i int local
        /declare ROResult string local FALSE
        /if (${RegonOnClasses.Equal[0]} || ${RegonOnClasses.Equal[null]}) {
            /if (${Stat.Equal[endurance]}) {
                /varset RegonOnClasses BER,BST,MNK,PAL,RNG,ROG,SHD,WAR
            } else /if (${Stat.Equal[mana]}) {
                /varset RegonOnClasses BRD,BST,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHD,SHM,WIZ
            }
        }
        /for i 1 to ${Group}
            DEBUGBUFF RegenOther Class: ${Group.Member[${i}].Class.ShortName} AggroID: ${AggroTargetID}  GrpMemPct: ${Group.Member[${i}].Current${Stat}}<=${StatPct} GrpMemID: ${Group.Member[${i}].ID}
            | If bard rallying call aa skip tank or he won't attack
            /if (${RGName.Find[Rallying Call]} && ${Group.Member[${i}].ID}==${Spawn[${MainAssist} ${MainAssistType}].ID}) /continue
            | Bard Dichotomic uses endurance not mana
            /if  (${RGName.Find[Dichotomic Psalm]} && ${Me.CurrentEndurance}<15000) /continue
            | Dichotomic Psalm & Quiet Miracle do not work on bards
            /if (${Group.Member[${i}].Class.Name.Equal[bard]} && (${RGName.Equal[Dichotomic Psalm]} || ${RGName.Equal[Quiet Miracle]})) /continue
            /if (${Select[${Group.Member[${i}].Class.ShortName},${RegonOnClasses}]} && !${AggroTargetID} && ${Group.Member[${i}].Current${Stat}}<=${StatPct} && ${Group.Member[${i}].Current${Stat}}>=1 && ${Group.Member[${i}].ID}) {
                /call CastWhat "${RGName}" ${Group.Member[${i}].ID} Regenother ${CondNumber} 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting ${RGName} on ${Group.Member[${i}].CleanName} for ${Stat}.
                    /varset ROResult TRUE
                    /break
                } else {
                    /varset ROResult ${Macro.Return}
                }
            }
        /next i
        DEBUGBUFF RegenOther Leave ${ROResult}
    /return ${ROResult}
| -------------------------------------------------------------------------------------
| SUB: PetStateCheck
| -------------------------------------------------------------------------------------
    Sub PetStateCheck
        DEBUGPET Checking Pet State.
        /if (${Me.AltAbility[Companion's Suspension]}>0) {
            /while (!${Me.AltAbilityReady[Companion's Suspension]}) {
                /echo Waiting on Suspend Minion AA to be ready.
                /delay 10
            }
            /alt act ${Me.AltAbility[Companion's Suspension].ID}
            /delay 5s !${Window[CastingWindow].Open}
            /doevents
        } else {
            /echo You do not have the "Companion's Suspension" AA, PetSuspend being turned off.
            /varset PetSuspend 0
        }
        /if (${Me.Pet.ID}) /varset PetActiveState 1
    /return
| -------------------------------------------------------------------------------------
| SUB: DoPetStuff
| -------------------------------------------------------------------------------------
    Sub DoPetStuff
        /if (!${PetOn} || ${CampZone}!=${Zone.ID}) /return
        /if (${AggroTargetID} || ${Me.Invis} || ${Me.Hovering}) /return
        /while (1) {
            /varset EventFlag 0
            /doevents
            /if (!${EventFlag}) /break
        }
        /declare PetSummonTimer timer local 60s
        DEBUGN DoPetStuff Enter
        /declare FocusPet string local ${PetFocus.Arg[1,|]}
        /declare FocusSlot string local ${PetFocus.Arg[2,|]}
        /declare FocusBuff string local ${PetFocus.Arg[3,|]}
        /declare FocusCurrent string local 
        /declare FocusSwitch int local 0
        /if (!${FocusSlot.Length} || ${FocusSlot.Equal[null]}) {
            /varset FocusPet
            /varset FocusSlot
            /varset FocusCurrent
        } else /if (${FocusSlot.NotEqual[buff]}) {
            /varset FocusCurrent ${Me.Inventory[${FocusSlot}].Name}
        } else {
            /varset FocusCurrent ${FocusBuff}
        }
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]}) /pet get lost
        | Swap pet focus in pet cast
        DEBUGN DoPetStuff ${FocusPet} ${FocusSlot} ${FocusCurrent} ${Me.Pet.ID}
        /if (!${Me.Pet.ID} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
            | verbose
            /echo I have no pet. ${Me.Class}s live longer when we have pets.
            /varset PetActiveState 0
            /varset g_PetToysGave
            | it Gets changed to 2 when activated, so as not to keep turning it on.
            /if (${PetFocusOn}) /varset PetFocusOn 1
            /if (${PetHoldOn}) /varset PetHoldOn 1
            /if (${FocusPet.Length} && ${FindItemCount[=${FocusPet}]}) {
                /if (${FocusSlot.NotEqual[buff]}) {
                    /if (!${Cursor.ID} && ${FocusPet.NotEqual[${FocusCurrent}]}) {
                        /exchange "${FocusPet}" ${FocusSlot}
                        /varset FocusSwitch 1
                        /delay 10
                    }
                } else {
                    /if (${FocusBuff.Length} && ${FocusBuff.NotEqual[null]}) {
                        /if (!${Me.Buff[${FocusBuff}].ID} && !${Me.Song[${FocusBuff}].ID}) {
                            /call CastWhat "${FocusPet}" ${Me.ID} DoPetStuff 0 0
                        }
                    }
                }
            }
            /while (1) {
                /varset EventFlag 0
                /doevents
                /if (!${EventFlag}) /break
            }
            /delay 3
            | Pet spell mem check - Else try item like mage epic
            /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff 0 0
            /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                /echo You are missing components to make this pet.
                /return CAST_COMPONENTS
            }
            | Summon Pet
            |- If using suspended pet function.
            /if (${PetSuspend}) {
               |- If I have a suspended pet bust him out!
                /if ((${PetTotCount}==1) && (${PetActiveState}==0) && (${PetSuspendState}==1)) {
                   /echo I have a suspended pet, summoning it now!
                   /call PetStateCheck
                }
                |- If I don't have a suspended or an active pet, make them.
                /if (${PetTotCount}<2 && ${PetSuspendState}==0 && ${PetActiveState}==0 && ${Me.Book[${PetSpell}]} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
                    /while (1) {
                        /echo - Making pet now.
                        /echo ARISE ${PetSpell}
                        /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff 0 0
                        /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                            /echo You are missing components to make this pet. Ending macro.
                            /endmacro
                        }
                        /delay 1s ${Me.Pet.ID}
                        /if (!${PetSummonTimer}) /break
                        /if (!${Me.Pet.ID}) /continue
                        /if (${Me.Pet.ID}) {
                            /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
                            /varset PetActiveState 1
                            /call CheckPetBuffs
                            /if (${PetToysOn}) {
                                /call PetToys ${Me.Pet.CleanName}
                                /if ((${PetSuspendState}==0) && (${PetActiveState}==1)) /varset PetToysDone 0
                                /if ((${PetSuspendState}==1) && (${PetActiveState}==1)) /varset PetToysDone 1
                            }
                        }
                        /call PetStateCheck
                        /if (${PetTotCount}==2 || !${PetSuspend} || !${PetSummonTimer}) /break
                    }
                }
            } else /if (${Me.Book[${PetSpell}]} && ${Spell[${PetSpell}].Mana}<=${Me.CurrentMana}) {
                | Normal pet function for not using suspend pet.
                /while (1) {
                    /echo ARISE ${PetSpell}
                    /call CastWhat "${PetSpell}" ${Me.ID} DoPetStuff 0 0
                    /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components to make this pet. Ending macro.
                        /endmacro
                    }
                    /delay 1s ${Me.Pet.ID}
                    /if (!${PetSummonTimer} || ${Me.Pet.ID}) /break
                }
                /if (${Me.Pet.ID}) {
                    /echo My pet is now: ${Me.Pet.CleanName} from ${PetSpell}
                    /varset PetActiveState 1
                }
                | Swap pet focus out for regular item
                /if (${FocusSwitch} && !${Cursor.ID}) {
                    /exchange "${FocusCurrent}" ${FocusSlot}
                    /delay 10
                }
            }
            | Reset PetToysGave in config after pet creation, as well as memory variable so we will pickup if our pet needs toys after death, under new condition checks.
            /ini "${IniFileName}" "Pet" "PetToysGave" ""
            /if (${Me.Pet.ID} && ${PetToysOn}) {
                /varset PetToysGave NULL
            }
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]}) {
                /if (!${ChaseAssist}) {
                    /if (${Me.Pet.Distance}<=${CampRadius}) {
                        /if (${Me.Pet.Stance.NotEqual[guard]}) /pet guard
                    } else {
                        /if (${Me.Pet.Stance.NotEqual[follow]}) /pet follow
                    }
                } else {
                    /if (${Me.Pet.Stance.NotEqual[follow]}) /pet follow
                }
            }
            /if (${PetHoldOn}==1) {
                /pet ${PetHold} on
                /varset PetHoldOn 2
            }
            /if (${PetFocusOn}==1) {
                /pet focus on
                /varset PetFocusOn 2
            }
        } else /if (${Me.Pet.ID}) {
            /if (${Select[${Role},puller,pullertank,pettank,pullerpettank]}) {
                /if (!${ChaseAssist}) {
                    /if (${Me.Pet.Distance}<=${CampRadius}) {
                        /if (${Me.Pet.Stance.NotEqual[guard]}) /pet guard
                    } else {
                        /if (${Me.Pet.Stance.NotEqual[follow]}) /pet follow
                    }
                } else {
                    /if (${Me.Pet.Stance.NotEqual[follow]}) /pet follow
                }
            }
            /if (${PetHoldOn}==1) {
                /pet ${PetHold} on
                /varset PetHoldOn 2
            }
            /if (${PetFocusOn}==1) {
                /pet focus on
                /varset PetFocusOn 2
            }
        }
        /if (${Me.Pet.ID}) {
            /if (!${PetTauntOverride}) {
                /if (!${Pet.Taunt}) {
                    /if (${Select[${Role},pettank,pullerpettank,hunterpettank]}) /pet taunt on
                } else {
                    /if (!${Select[${Role},pettank,pullerpettank,hunterpettank]}) /pet taunt off
                }
            }
        }
        /call CheckPetBuffs
        | Pet Toy routines
        | Condition revised to only call PetToys if I do not have my pet name in the PetToysGave string.
        /if (${Me.Pet.ID} && ${PetToysOn} && (!${PetToysGave.Find[${Me.Pet.CleanName}]} || !${PetToysGave.Find[Summoned]})) {
            /call PetToys ${Me.Pet.CleanName}
            /varset g_PetToysGave ${PetToysGave}
        }
        | Check to have pet come to owner if owner out of camp too long.
        /if (${Select[${Role},pettank,hunterpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) && ${Me.Pet.Stance.Equal[GUARD]}) /pet follow
        /if (${Me.Pet.ID} && ${Me.Gem[${MiscGem}].Name.NotEqual[${ReMemMiscSpell}]} && ${MiscGemRemem}) {
            /varset DontMoveMe 1
            /call CastMemSpell "${ReMemMiscSpell}" ${MiscGem} 0 DoPetStuff
            /varset DontMoveMe 0
        }
        DEBUGN DoPetStuff Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckPetBuffs
| -------------------------------------------------------------------------------------
    Sub CheckPetBuffs
        /if (!${Me.Pet.ID}) /return
        /if (!${PetOn}) /return
        /if (!${PetBuffsOn}) /return
        /if (${CombatStart}) /return
        /if (${Pulling}) /return
        /if (${PetBuffCheck}) /return
        /if (${Me.Invis}) /return
        DEBUGN CheckPetBuffs Enter
        /declare PTempBuff string local
        /declare PTempSpell string local
        /declare i int local
        /declare j int local
        /declare 1stPart string local 0
        /declare 2ndPart string local 0
        /declare 3rdPart string local 0
        /declare FoundPetBuff int local 0
        /declare CondNo int local 0
        /varset PetBuffCheck 60s
        /for i 1 to ${PetBuffs.Size}
            /doevents
            | Stop pet buffing if aggro detected
            /if (${AggroTargetID}) /return
            /if (${PetBuffs[${i}].Equal[Null]}) /continue
            /varset 1stPart ${PetBuffs[${i}].Arg[1,|]}
            /varset 2ndPart ${PetBuffs[${i}].Arg[2,|]}
            /varset 3rdPart ${PetBuffs[${i}].Arg[3,|]}

            /if (${2ndPart.NotEqual[dual]}) /varset 3rdPart ${1stPart}

            /if (${ConOn} && ${PetBuffs[${i}].Find[|cond]}) {
                /varset CondNo ${PetBuffs[${i}].Mid[${Math.Calc[${PetBuffs[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            
            | Check for pet spells in book to prevent double casting of items
            /if (${Me.Book[${1stPart}]} || ${Me.AltAbility[${1stPart}]}) {
                /if (${1stPart.Find[ Rk.]}) {
                    /varset PTempSpell ${1stPart.Left[${Math.Calc[${1stPart.Find[ Rk.]}-1]}]}
                } else {
                    /varset PTempSpell ${1stPart}
                }
                /if (${3rdPart.Find[ Rk.]}) {
                    /varset PTempBuff ${3rdPart.Left[${Math.Calc[${3rdPart.Find[ Rk.]}-1]}]}
                } else {
                    /varset PTempBuff ${3rdPart}
                }
                DEBUGN CheckPetBuffs ${i} ${Me.PetBuff[${PTempBuff}]} ${PetBuffs[${i}]} ${PTempBuff}
                /for j 1 to 50
                    /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) {
                        /varset FoundPetBuff 1
                        /break
                    }
                /next j
                /if (!${FoundPetBuff}) {
                    | Vebrose
                    /call CastWhat "${1stPart}" ${Me.Pet.ID} Pet-nomem ${CondNo} 0
                    /delay 20
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Buffing ${Me.Pet.CleanName}, my pet, with ${1stPart}
                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${1stPart}.
                        /varset PetBuffs[${i}] Null
                        
                    }
                    /continue
                }
            } else /if (${FindItem[=${1stPart}].ID}) {
                /varset PTempSpell ${1stPart}
                /varset PTempBuff ${3rdPart}
                DEBUGN CheckPetBuffs ${FindItem[=${1stPart}].Spell} ${Me.PetBuff[${FindItem[=${1stPart}].Spell}]} ${Me.PetBuff[${3rdPart}]}
                /if (${Me.PetBuff[${FindItem[=${PTempSpell}].Spell}]}>0) /continue
                /if (${Me.PetBuff[${PTempBuff}]}>0) /continue
                DEBUGN CheckPetBuffs - Dual - ${1stPart} - ${3rdPart}
                /for j 1 to 50
                    /if (${Me.PetBuff[${j}].Name.Find[${PTempBuff}]}) {
                        /varset FoundPetBuff 1
                        /break
                    }
                /next j
                /if (!${FoundPetBuff}) {
                    |Vebrose
                    /call CastWhat "${1stPart}" ${Me.Pet.ID} Pet ${CondNo} 0
                    /delay 20
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Buffing ${Me.Pet.CleanName}, my pet, with (${3rdPart})
                    } else /if (${Macro.Return.Equal[CAST_COMPONENTS]}) {
                        /echo You are missing components. Turning off ${1stPart}.
                        /varset PetBuffs[${i}] Null
                    }
                    /continue
                }
            } else /if (${1stPart.Equal[pettoys]} && ${2ndPart.Equal[begfor]}) {
                DEBUGN CheckPetBuffs begfor toys
                /if (${CondNo} && ${If[${Cond[${CondNo}]},0,1]}) /continue 
                /if (${Defined[PetBuff${i}]}) {
                    /if (${PetBuff${i}}) /continue
                }
                /call BroadCast o "PetToysPlease ${Me.Pet.Name}"
                /if (!${Defined[PetBuff${i}]}) {
                    /declare PetBuff${i} timer outer 900
                } else {
                    /varset PetBuff${i} 900
                }
            }
            /varset FoundPetBuff 0
        /next i
        DEBUGN CheckPetBuffs Pet Height: ${Me.Pet.Height}
        /if (${Me.Pet.Height}>1.35 && ${PetShrinkOn}) {
            /call CastWhat "${PetShrinkSpell}" ${Me.Pet.ID} Pet 0 0
            /delay 20
        }
        /if (${Target.ID}==${Me.Pet.ID}) /squelch /target clear
        DEBUGN CheckPetBuffs Leave
    /return
| ----------------------------------------------------------------------------
| SUB: CastPetToys
| ----------------------------------------------------------------------------
    Sub CastPetToys(string PetToySpell0)
        /declare retryCount int local 1
        /declare cancelFlag int local 0
        /while (1) {
            /varcalc retryCount ${retryCount}+1
            /call CastWhat "${PetToySpell0}" ${Me.ID} Pet-nomem 0 0
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo Casting pet toy spell >> ${PetToySpell0} <<
                /break
            } else /if (${Macro.Return.Equal[CAST_FIZZLE]}) {
                /if (${retryCount}>4) {
                    /varset cancelFlag 1
                    /break
                }
                /if (!${Me.GemTimer[${PetToySpell0}]} && ${Me.SpellReady[${PetToySpell0}]}) {
                    /delay 5
                    /continue
                } else {
                    /while (${Me.GemTimer[${PetToySpell0}]}) {
                        /delay 5
                    }
                    /continue
                }
            } else /if (${Macro.Return.Equal[CAST_RECOVER]}) {
                /varcalc retryCount ${retryCount}-1
                /while (1) {
                    /delay 5
                    /if (${Me.SpellInCooldown}) /continue
                    /if (${Me.GemTimer[${PetToySpell0}]}) /continue
                    /if (!${Me.SpellReady[${PetToySpell0}]}) /continue
                    /break
                }
                /continue
            }
            /varset cancelFlag 1
            /break
        }
    /return ${cancelFlag}
| ----------------------------------------------------------------------------
| SUB: Pick Up item
| ----------------------------------------------------------------------------
    Sub PickUpItem(string p_ItemName, p_AddToList)
        /declare itemSlot int local
        /declare itemSlot2 int local
        /if (!${FindItemCount[=${p_ItemName}]}) /return
        /varset itemSlot ${FindItem[=${p_ItemName}].ItemSlot}
        /varset itemSlot2 ${FindItem[=${p_ItemName}].ItemSlot2}
        /if (${itemSlot}>22) /varcalc itemSlot ${itemSlot}-22
        /if (${itemSlot2}>-1) /varcalc itemSlot2 ${itemSlot2}+1

        /if (!${PetToyList.Length}) {
            /varset PetToyList ${p_ItemName}@${itemSlot}@${itemSlot2}
        } else {
            /varset PetToyList ${PetToyList}|${p_ItemName}@${itemSlot}@${itemSlot2}
        }
        /if (${itemSlot2}<0) {
            /nomodkey /itemnotify pack${itemSlot} leftmouseup
        } else {
            /nomodkey /itemnotify in pack${itemSlot} ${itemSlot2} leftmouseup
        }
        /delay 20 ${Cursor.ID}
    /return
| ----------------------------------------------------------------------------
| SUB: Check PetToys
| ----------------------------------------------------------------------------
    Sub PetToys(string petName)
        /if (!${Me.Pet.ID}) /return w
        DEBUGPET PetToys Enter
        /declare i            int    local
        /declare j            int    local
        /declare GrabItem     int    local 0
        /declare PetToySpell  string local 0
        /declare FullText     string local
        /declare 2ndPart      string local
        /declare LastPart     string local
        /declare PetToysTemp  string local ${Ini[${IniFileName},Pet,PetToysGave]}
        /declare PetToyCheck  string local
        /declare GaveItem     int    local 1
        /declare CondNo       int    local 0
        /declare pCount1      int    local 0
        /declare pCount2      int    local 0
        /declare pIdx         int    local 0
        /declare isMyPet      int    local 0
        /declare retryCount   int    local 0
        /declare cancelFlag   int    local 0
        /declare SlotOpen     int    local 0
        /declare CastFlag1    int    local 0
        
        /varset BagNum 0
        /call OpenInvSlot
        /declare petID        int    local ${Spawn[pet ${petName}].ID}
        /declare petLevel     int    local ${Spawn[id ${petID}].Level}
        /if (!${Defined[PetToysOn]}) /return
        /if (!${PetToysOn}) /return 0
        /if (${BagNumLast}==99) {
            /echo Inventory is full
            /varset PetToysOn 0
            /return X
        }
        /if (${BagNum}==0) {
            /echo You must have an empty Top Inventory slot for Pet Toys to work.
            /varset PetToysOn 0
            /return X
        }
        | reset if different pet name only on my pet
        /if (${Me.Pet.CleanName.Equal[${petName}]}) {
            /varset isMyPet 1
            /if (!${PetToysTemp.Find[${petName}]}) {
                /ini "${IniFileName}" "Pet" "PetToysGave" "${petName}"
                /varset PetToysTemp ${petName}
            }
        } else {
            /varset PetToysTemp 
        }
        /if (!${Window[InventoryWindow].Open}) /varset GaveItem 0
        /for i 1 to ${PetToys.Size}
            DEBUGPET CHECKING: ${i} - ${PetToys[${i}]}
            /if (${ConOn} && ${PetToys[${i}].Find[|cond]}) {
                /varset CondNo ${PetToys[${i}].Mid[${Math.Calc[${PetToys[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            /if (${DebugPet}) {
                /echo \atPetDebug PetToys 1: ${PetToys[${i}]}
                /echo \atPetDebug PetToys 2: ${PetToysTemp}
                /echo \atPetDebug PetToys 3: ${PetToys[${i}].Equal[Null]} || ${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToys[${i}]}]}
                /echo \atPetDebug PetToys 4: ${If[${CondNo},${Cond[${CondNo}]},0]}
            }
            /if (${CondNo}) {
                /if (${If[${Cond[${CondNo}]},0,1]}) /continue
            }
            | Had to add pet name check else it will always skip giving weapons to OTHER pets.
            DEBUGPET PetToys ${i} ${PetToys[${i}].Equal[Null]} SkipPetToy 1
            /if (${PetToys[${i}].Equal[Null]}) /continue
            /if (${PetToys[${i}].Find[|cond]}) {
                /varset FullText ${PetToys[${i}].Left[${Math.Calc[${PetToys[${i}].Find[|cond]}-1]}]}
            } else {
                /varset FullText ${PetToys[${i}]}
            }
            | Are we handing weapons to the pet
            /varcalc pCount1 ${FullText.Count[|]}+1
            /varset PetToySpell ${FullText.Arg[1,|]}
            /if (${pCount1}>1) {
                /varset pIdx 2
                /varset 2ndPart ${FullText.Arg[${pIdx},|]}
                /varset LastPart ${FullText.Arg[${Math.Calc[${pIdx}+1]},|]}
                /if (${2ndPart.Length} && ${2ndPart.NotEqual[null]} && ${LastPart.Equal[${2ndPart}]}) {
                    /varset PetToyCheck :${2ndPart}2
                } else {
                    /varset PetToyCheck :${2ndPart}1
                }
            } else {
                /varset pIdx 1
                /varset PetToySpell ${FullText}
                /varset 2ndPart
                /varset PetToyCheck ${PetToySpell}:
            }
            /varset LastPart
            DEBUGPET PetToys ${isMyPet} - ${2ndPart.Length} - ${PetToysTemp.Find[PetToyCheck]} - ${Spell[${PetToySpell}].Level} SkipPetToy 2
            /if (${isMyPet}) {
                /if (${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToyCheck}]}) /continue
                | Check if spell level less than 76 because mage pets auto equipped after that.
                /if (${petLevel}>=76 && (${PetToySpell.Find[muzzle]} || ${PetToySpell.Find[visor]} || ${PetToySpell.Find[belt]} || ${PetToySpell.Find[plate]})) /continue
            }
            | Check for pet toy spells in book to prevent double casting of items
            /if (${Me.Book[${PetToySpell}]} || (${PetToySpell.Equal[inventory]} && ${FindItemCount[=${2ndPart}]})) {
                | Cast to get Item
                /if (${Me.Book[${PetToySpell}]}) {
                    /call CastPetToys "${PetToySpell}"
                    /if (${Macro.Return.Equal[1]}) /continue
                    /delay 15s ${Cursor.ID}
                    /if (!${Cursor.ID}) /return 0
                }    
                | If it is a Bag we need to drop it into inventory
                /if (${Cursor.Container} || ${Cursor.Name.Find[Folded]}) {
                    | If item is in Inv Slot exchange it with bag on cursor
                    /varset CastFlag1 0
                    /if (${Me.Inventory[pack${BagNum}].ID}) {
                        /varset SlotOpen 0
                    } else {
                        /varset SlotOpen 1
                    }
                    /nomodkey /itemnotify pack${BagNum} leftmouseup
                    /while (1) {
                        /if (!${SlotOpen}) {
                            /delay 30 ${Cursor.ID}
                        } else {
                            /delay 20 !${Cursor.ID}
                        }
                        | Drop bag or item into inventory
                        /if (${Cursor.ID}) {
                            /if (!${Cursor.Container}) {
                                /autoinventory
                            } else {
                                /nomodkey /itemnotify pack${BagNum} leftmouseup
                            }
                        }
                        /delay 20 !${Cursor.ID}
                        | Drop exchanged item into inventory after bag is dropped
                        /if (${Cursor.ID}) /autoinventory
                        | If folded pack right click to convert to phantom satchel
                        /if (${Me.Inventory[pack${BagNum}].Name.Find[folded]}) {
                            /nomodkey /itemnotify pack${BagNum} rightmouseup
                            /echo Opening ${Me.Inventory[pack${BagNum}].Name}
                            /delay 10
                            /delay 30 ${Window[CastingWindow].Open}
                            /varset SlotOpen 0
                        } else {
                            /delay 10
                            /break
                        }
                    }
                    /if (${Me.Inventory[pack${BagNum}].Container}) {
                        /nomodkey /itemnotify pack${BagNum} rightmouseup
                        /delay 10
                    }
                } else /if (${Cursor.Name.Find[Summoned:]}) {
                    /varset CastFlag1 1
                } else {
                    /varset CastFlag1 0
                }
                
                /while (1) {
                    /if (${FindItemCount[=${2ndPart}]}) {
                        /call GiveTo "${2ndPart}" ${petID} 0
                    } else /if (${Cursor.ID}) {
                        /varset 2ndPart ${Cursor.Name}
                        /call GiveTo "${Cursor.Name}" ${petID} 1
                    } else /if (${pIdx}==1 && !${2ndPart.Length}) {
                        /varset CastFlag1 2
                        /break
                    } else {
                        /break
                    }
                    /delay 10
                    /if (${PetToysTemp.Find[:${2ndPart}1]}) {
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}2
                    } else {
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:${2ndPart}1
                    }
                    /if (${isMyPet}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"

                    /while (1) {
                        /varset LastPart ${2ndPart}
                        /if (${pIdx}==${pCount1}) {
                            /varset 2ndPart
                            /break
                        }
                        /varcalc pIdx ${pIdx}+1
                        /varset 2ndPart ${FullText.Arg[${pIdx},|]}

                        /if (${2ndPart.Length}) {
                            /if (${2ndPart.NotEqual[null]} && ${2ndPart.Equal[${LastPart}]}) {
                                /varset PetToyCheck :${2ndPart}2
                            } else {
                                /varset PetToyCheck :${2ndPart}1
                            }
                        } else {
                            /break
                        }

                        /if (${isMyPet}) {
                            /if (${PetToysTemp.Find[${petName}]} && ${PetToysTemp.Find[${PetToyCheck}]}) /continue
                            /if (${petLevel}>=76 && (${PetToySpell.Find[muzzle]} || ${PetToySpell.Find[visor]} || ${PetToySpell.Find[belt]} || ${PetToySpell.Find[plate]})) /continue
                        }
                        /break
                    }
                    /if (!${2ndPart.Length} || ${2ndPart.Equal[null]}) /break
                    /if (${CastFlag1}==1) {
                        /if (${Window[GiveWnd].Open}) /call GiveTo "giveitems" ${petID} 1
                        /call CastPetToys "${PetToySpell}"
                        /if (${Macro.Return.Equal[1]}) /break
                        /delay 15s ${Cursor.ID}
                    }
                }
                /if (${CastFlag1}==2) {
                    /varset 2ndPart
                    /for j 1 to ${Me.Inventory[pack${BagNum}].Container}
                        /if (${PetToySpell.Find[heirloom]} && ${isMyPet} && ${j}<4) /continue
                        /if (${Me.Inventory[pack${BagNum}].Item[${j}].ID} && ${Me.Inventory[pack${BagNum}].Item[${j}].Name.Length}) {
                            /varset 2ndPart ${Me.Inventory[pack${BagNum}].Item[${j}].Name}
                            /call GiveTo "${2ndPart}" ${petID} 0
                        }
                        /delay 10
                    /next j
                    /if (${2ndPart.Length} && !${PetToysTemp.Find[${PetToySpell}]}) {
                        /varset PetToysTemp ${PetToysTemp}|${PetToySpell}:AllContents
                        /if (${isMyPet}) /ini "${IniFileName}" "Pet" "PetToysGave" "${PetToysTemp}"
                    }
                }
                /if (${Window[GiveWnd].Open}) /call GiveTo "giveitems" ${petID} 1
                /if (${Me.Inventory[pack${BagNum}].Name.Find[Phantom Satchel]} || ${Me.Inventory[pack${BagNum}].Name.Find[Pouch of Quellious]}) /call DestroyBag
            }
        /next i
        | MUST reset PetToysGave after cycle complete in order to stop calling PetToys all the time.
        /varset PetToysGave ${PetToysTemp}
        /if (${Window[InventoryWindow].Open} && !${GaveItem}) /keypress inventory
        /varset PetToysDone 1
        /call DoWeMove ${ReturnToCamp} PetToys
        DEBUGPET PetToys Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Check OpenInvSlot - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub OpenInvSlot
        DEBUGBUFF OpenInvSlot Enter
        /if (${BagNum}) /return
        /declare h int local 1
        /declare i int local 0
        /declare maxSlots int local ${Me.NumBagSlots}
        /varset BagNum 0
        /call CheckCursor OpenInvSlot 1
        /if (${Cursor.ID}) {
            /varset BagNumLast 99
            /return
        }
        /while (${h}<3 && !${BagNum}) {
            /for i 1 to ${maxSlots}
                /if (${Me.Inventory[pack${i}].Container}) /continue
                /if (${h}==1) {
                    /if (${Me.Inventory[pack${i}].ID}==0) {
                        /varset BagNum ${i}
                        /break
                    }
                } else /if (${h}==2) {
                    /if (!${Me.Inventory[pack${i}].Container}) {
                        /if (${Me.FreeInventory}>1) {
                            /varset BagNum ${i}
                        } else {
                            /varset BagNumLast 99 
                        }
                        /break
                    }
                } else {
                    /break
                }
            /next i
            /varcalc h ${h}+1
            /if (${BagNum}) /break
        }
        /if (${BagNum}) {
            /if (${BagNum}!=${BagNumLast}) {
                /varset BagNumLast ${BagNum}
                /echo Pet Toys: Inventory slot ${i} is empty using that one.
            }
        }
        DEBUGBUFF OpenInvSlot Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Check DestroyBag - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub DestroyBag
        DEBUGBUFF DestroyBag Enter
        /declare j int local
        | Make sure bag has no items other than summoned in it before deleting.
        /if (${Me.Inventory[pack${BagNum}].Items}) {
            /for j 1 to ${Me.Inventory[pack${BagNum}].Container}
                /if (${Me.Inventory[pack${BagNum}].Item[${j}].Name.Length}) {
                    /if (!${Me.Inventory[pack${BagNum}].Item[${j}].NoRent}) {
                        /echo Bag has non summoned item(s) in it. Aborting delete. Pet Toys Off
                        /varset PetToysOn 0
                        /return
                    }
                }
            /next j
        }
        /if (${Me.Inventory[pack${BagNum}].Name.Find[Phantom Satchel]} || ${Me.Inventory[pack${BagNum}].Name.Find[Pouch of Quellious]}) {
            /nomodkey /itemnotify pack${BagNum} leftmouseup
            /delay 5s ${Cursor.ID}
            /if (${Cursor.Name.Find[Phantom Satchel]} || ${Cursor.Name.Find[Pouch of Quellious]}) /destroy
            /delay 20 !${Cursor.ID}
        }
        DEBUGBUFF Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Check GiveTo - Based on code from el_nene's autobot. Used with permission.
| Autobot is available at www.Macroquest2.com VIP macro section.
| Updated and Revised for KissAssist
| ----------------------------------------------------------------------------
    Sub GiveTo(string GItem, int GTarget, int GiveNow)
        DEBUGBUFF GiveTo Enter ${GItem} ${GTarget} ${GiveNow}
        /declare ItemSummoned  int    local 0
        /declare GItemID       int    local 0
        /declare GDropCount    int    local 0
        /declare x1            int    local 0
        /declare ToyName       string local
        /declare ListItem      string local
        /if (${GItem.NotEqual[giveitems]}) {
            /if (${Target.ID}!=${GTarget}) {
                /target id ${GTarget}
                /delay 2s ${Target.ID}==${GTarget}
            }
            /if (${Target.Distance}>5 && ${Target.Distance}<=${CampRadius}) {
                /moveto id ${Target.ID} mdist 5
                /delay 50 ${MoveTo.Stopped}
            }
            /if (${Me.Mount.ID}) {
                /dismount
                /delay 20 !${Me.Mount.ID}
            }
            /if (${Me.Levitating}) {
                /removelev
                /delay 20 !${Me.Levitating}
            }
            /if (!${Cursor.ID}) {
                /if (${FindItemCount[=${GItem}]}>0) {
                    /call PickUpItem "${GItem}" 0
                } else {
                    /echo Item: ${GItem} Not Found in Inventory. Are you sure the Item Name is Correct?
                    /return
                }
            }
            /varset GItemID ${FindItem[=${GItem}].ID}
            /while (${Cursor.ID} && ${GDropCount}<4) {
                /if (${Cursor.NoRent}) {
                    /if (${Cursor.ID}==${GItemID}) {
                        /varset ItemSummoned 1
                        /nomodkey /click left target
                        /delay 20 !${Cursor.ID}
                        /varcalc ItemsGiven ${ItemsGiven}+1
                    } else {
                        /echo Item: ${GItem} Not Found on Cursor. Dropping ${Cursor} to Inventory.
                        /autoinventory
                        /delay 10
                    }
                } else {
                    /echo Item: ${Cursor} is not Summoned. Dropping to Inventory.
                    /autoinventory
                    /delay 10
                }
                /varcalc GDropCount ${GDropCount}+1
            }
            /if (${Cursor.ID}) {
                /echo Item still on Cursor. The Item is the wrong item or your inventory is full.
                /return
            }
        } else {
            /varset ItemSummoned 1
            /varset GiveNow 1
        }
        /delay 30 ${Window[GiveWnd].Open}
        /if (${Window[GiveWnd].Open}) {
            /if (${GiveNow} || ${ItemsGiven}==4) {
                /notify GiveWnd GVW_Give_Button leftmouseup
                /echo Giving Item(s) to ${Target.CleanName}
                /delay 20 !${Window[GiveWnd].Open}
                /delay 15
                /varset ItemsGiven 0
            }
        }
        | New pet patch gives back item if pet has equipped. Delete item from cursor.
        /varset GDropCount 0
        /if (${Cursor.ID}) {
            /while (${Cursor.ID} && ${GDropCount}<8) {
                /varset GItemID ${Cursor.ID}
                /varset ToyName ${Cursor.Name}
                | This came out of your inventory, so put it back where you got it.
                /if (${PetToyList.Find[${ToyName}]}) {
                    /varset x1 1
                    /while (1) {
                        /varset ListItem ${PetToyList.Arg[${x1},|]}
                        /if (!${ListItem.Length} || ${ListItem.Equal[null]}) /break
                        /if (${ListItem.NotEqual[removed]}) {
                            /if (${ListItem.Arg[1,@].Equal[${ToyName}]}) {
                                /if (${Int[${ListItem.Arg[3,@]}]}<0) {
                                    /nomodkey /itemnotify pack${ListItem.Arg[2,@]} leftmouseup
                                } else {
                                    /nomodkey /itemnotify in pack${ListItem.Arg[2,@]} ${ListItem.Arg[3,@]} leftmouseup
                                }
                                /varset PetToyList ${PetToyList.Replace[${ListItem},removed]}
                                /break
                            }
                        }
                        /varcalc x1 ${x1}+1
                    }
                } else /if (${Cursor.NoRent}) {
                    /destroy
                } else {
                    /autoinventory
                }
                /delay 20 ${Cursor.ID}
                /varcalc GDropCount ${GDropCount}+1
            }
        } else /if (${GiveNow}) {
            /varset PetToyList
        }
        DEBUGBUFF GiveTo Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Check Plugin
| ----------------------------------------------------------------------------
    Sub CheckPlugin(string pluginname, int noautoflag)
        /declare WaitTimer1 timer local 50
        DEBUGN CheckPlugin: Enter
        /if (!${Bool[${Plugin[${pluginname}]}]}) {
            /if (${noautoflag}) {
                /squelch /plugin ${pluginname} noauto
            } else {
                /squelch /plugin ${pluginname}
            }
            /echo ${pluginname} not detected! This macro requires it! Loading ...
            /while (${WaitTimer1} && !${Bool[${Plugin[${pluginname}]}]}) {
                /delay 5
            }
        }
        DEBUGN CheckPlugin: Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Load Ini
| ----------------------------------------------------------------------------
    Sub LoadIni(string sectionName, string varName, string varType, string varValue, string varArray, string FileName)
        /if (${Debug}) {
            /delay 2
            /echo \atDEBUG Sub Loadini S:${sectionName} V1:${varName} V2:${varType} V3:${varValue} V4:${varArray}
        }
        /declare rkTemp                 string      local
        /declare UtilInt                int         local        0
        /declare FileName1              string      local        ${FileName}
        /declare RezCount               int         local        0
        | Assign ini name to default ini if not defined
        /if (${FileName1.Length}==0  || ${FileName1.Equal[NULL]}) {
            /varset FileName1 ${IniFileName}
        }
        | Check if ini value is asking for an array ie buff1 to buff20
        /if (${Bool[${varArray}]}) {
            /if (${${varArray}.Size}>0) {
                /declare i int local
                /for i 1 to ${${varArray}.Size}
                    /if (${sectionName.NotEqual[KConditions]}) {
                        /if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
                            /ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
                        } else {
                            /varset ${varArray}[${i}] ${Ini[${FileName1},${sectionName},${varArray}${i}]}
                        }
                        /if (${${varArray}[${i}].NotEqual[null]} && ${${varArray}[${i}].Left[1].NotEqual[;]}) {
                            | find out if there is a Rank and fix spell name.
                            /if (${varType.Equal[string]} && ${Int[${${varArray}[${i}].Left[1]}]}==0) {
                                /call SpellRankCheck "${${varArray}[${i}]}"
                                /varset ${varArray}[${i}] ${Macro.Return}
                            }
                            | code to fix the Heal PCT for those zones Crypt of Sul, that knock your HPs down to
                            /if (${Int[${${varArray}[${i}].Arg[2,|].Left[1]}]}>0) {
                                /if (${sectionName.Equal[Heals]}) {
                                    /if (${${varArray}[${i}].Arg[3,|].Find[rez]}) {
                                        /varcalc RezCount ${RezCount}+1
                                        /if (${RezCount}<=${AutoRez.Size}) {
                                            /varset AutoRez[${RezCount}] ${${varArray}[${i}]}
                                            /varset ${varArray}[${i}] null
                                        }
                                    } else /if (${Select[${Zone.ID},795,796]}) {
                                        /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}*.7
                                        /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                                    }
                                } else /if (${sectionName.Equal[DPS]} && ${${varArray}[${i}].Arg[3,|].Equal[debuffall]}) {
                                    /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
                                    /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                                } else /if (${sectionName.Equal[Aggro]} && ${${varArray}[${i}].Arg[3,|].Equal[<<]}) {
                                    /varcalc UtilInt ${Int[${${varArray}[${i}].Arg[2,|]}]}+100
                                    /varset ${varArray}[${i}] ${${varArray}[${i}].Replace[|${${varArray}[${i}].Arg[2,|]},|${UtilInt}]}
                                }
                            } else /if (${sectionName.Equal[Heals]}) {
                                /if (${${varArray}[${i}].Arg[3,|].Find[rez]}) {
                                    /varcalc RezCount ${RezCount}+1
                                    /if (${RezCount}<=${AutoRez.Size}) {
                                        /varset AutoRez[${RezCount}] ${${varArray}[${i}]}
                                        /varset ${varArray}[${i}] null
                                    }
                                }
                            }
                        } else {
                            /varset ${varArray}[${i}] null
                        }
                        DEBUGN Loadini: ${i} - ${varArray}[${i}] - ${${varArray}[${i}]}
                    } else {
                        /if (!${Ini[${FileName1},${sectionName},${varArray}${i}].Length}) {
                            /ini "${FileName1}" "${sectionName}" "${varArray}${i}" "${varValue}"
                        } else {
                            /varset ${varArray}[${i}]  ${Ini[${FileName1},${sectionName},${varArray}${i},NULL,noparse]}
                        }
                        DEBUGN ${varArray}[${i}]  ${Ini[${FileName1},${sectionName},${varArray}${i},NULL,noparse]}
                    }
                /next i
                /return
            }
        } else {
            /if (!${Defined[${varName}]} && ${Select[${varType},string,float,int]}>0) /declare ${varName} ${varType} outer 0
                /if (!${Ini[${FileName1},${sectionName},${varName}].Length}) {
                    /if (${varValue.Length}) {
                        /ini "${FileName1}" "${sectionName}" "${varName}" "${varValue}"
                        /varset ${varName} ${varValue}
                        DEBUGN Sub Loadini /varset ${varName} ${varValue}
                    }
                } else {
                    /varset ${varName} ${Ini[${FileName1},${sectionName},${varName}]}
                }
                /if (${FileName1.Equal[${IniFileName}]}) {
                    /varset rkTemp ${${varName}}
                    | find out if there is a Rank and fix spell name.
                    /if (${varType.Equal[string]} && ${Int[${rkTemp.Left[1]}]}==0 && !${varName.Find[Help]}) {
                        /call SpellRankCheck "${${varName}}"
                        /if (${Macro.Return.NotEqual[null]}) /varset ${varName} ${Macro.Return}
                    }
                }
            DEBUGN Sub LoadIni: ${varName} - ${${varName}}
            /varset rkTemp
        }
        DEBUGN Sub LoadIni: Leave
    /return
| ----------------------------------------------------------------------------
| SUB: End Mac If
| ----------------------------------------------------------------------------
    Sub EndMacroIf
        DEBUGN EndMacroIf: Enter
        | I died wait for rez loop
        /if (${Me.Hovering}) /call PauseWhileHovering EndMacroIf
        /while (${EverQuest.GameState.NotEqual[ingame]}) {
            /delay 10
            /if (${EverQuest.GameState.Equal[CHARSELECT]}) /endmac
        }
        /while (${CampZone}!=${Zone.ID} && ${RezAcceptOn.Arg[1,|].Equal[1]} && ${IAmDead} && ${Me.ID}) {
            /if (${EverQuest.GameState.Equal[CHARSELECT]}) /endmac
            /if (${Attacking}) /call CombatReset 0 endmacroif
            /delay 10
            /if (${ClickBacktoCamp}) /call CampfireBack
            /if (${CampOnDeath}) /call DoICamp
        }
        /if (${RezAcceptOn.Arg[1,|].Equal[0]} && ${CampZone}!=${Zone.ID}) {
            /if (${CampOnDeath}) /call DoICamp
        }
        DEBUGN EndMacroIf: Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Do I Camp
| ----------------------------------------------------------------------------
    Sub DoICamp
        DEBUGN DoICamp Entered ${CampOnDeathTimer} ${CampOnDeath} ${CampZone} ${Zone.ID}
        /while (${CampOnDeathTimer} && ${CampOnDeath}==1 && ${CampZone}!=${Zone.ID}) {
            /delay 10
            DOPARSE
        }
        /if ((!${CampOnDeathTimer} || ${CampOnDeath}==2) && ${CampZone}!=${Zone.ID}) {
            /echo I am dead and not where I am suppose to be. Time to camp out.
            /if (${IAmABard}) {
                /call CastBardCheck
            }
            /docommand /camp desktop
            /delay 10s
            /endmac
        }
        DEBUGN DoICamp Leave
    /return
| ----------------------------------------------------------------------------
| SUB: New Do I Camp, Testing.
| ----------------------------------------------------------------------------
    Sub DoICampA
        DEBUGN DoICampA Entered ${CampOnDeathTimer} ${CampOnDeath} ${CampZone} ${Zone.ID}
        /if (${CampZone}!=${Zone.ID}) {
            /if (${CampOnDeath}==1) {
                /if (${CampOnDeathTimer}) {
                    /echo Camping Due to Not in Camp Zone. Waiting for ${Math.Calc[${CampOnDeathTimer}/10]} Seconds
                    /while (${CampOnDeathTimer} && ${CampZone}!=${Zone.ID}) {
                        /delay 10
                        DOPARSE
                    }
                    /if (${CampZone}==${Zone.ID}) {
                        /if (${CampOnDeathTimer}) /echo Aborting! Camping.
                        /return
                    }
                }
                /echo Time Expired. Camping Now.
            } else /if (${CampOnDeath}==2) {
                /echo I am not where I am suppose to be. Time to camp out.
            }
            /if (${IAmABard}) {
                /call CastBardCheck
            }
            /docommand /camp desktop
            /delay 10s
            /endmac
        }
        DEBUGN DoICamp Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Do Bard Stuff New
| ----------------------------------------------------------------------------
    Sub DoBardStuff
        /if (!${IAmABard}) /return
        /if (!${Twist}) {
            /varset Twisting 0
            /varset DPSTwisting 0
            /if (${Me.BardSongPlaying} && ${Me.Casting.ID} && !${Window[CastingWindow].Open}) /stopsong
        }
        /if (!${BardStartTwist} && !${Me.Invis} && !${TwistHold}) {
            /call CastBardCheck
            /if (${TwistWhat.Length} && ${TwistWhat.Find[order]}==0) /squelch /twist ${TwistWhat}
            /varset BardStartTwist 1
            /return
        } else /if (${Me.Invis} || ${TwistHold}) {
            /if (${Twist} || (${Medding} && ${MedCombat} && ${AggroTargetID})) {
                /call CastBardCheck
            }
            /return
        }
        DEBUGN DoBardStuff: Enter
        /if (!${Twist}) {
            | Handle Melee Twist
            /if (${MeleeTwistOn} && !${DPSTwisting} && (${CombatStart} || (${MeleeTwistOn}==2 && ${AggroTargetID}))) {
                /varset DPSTwisting 1
                /varset Twisting 0
                /if (${MeleeTwistWhat.Equal[Continuous]}) {
                    /if (${Me.BardSongPlaying}) {
                        /stopsong
                        /delay 5
                    }
                    /if (${Twist.List.Left[-1].Equal[${TwistWhat}]}) {
                        /if (${Me.Sitting}) {
                            /stand
                            /delay 20 !${Me.Sitting}
                        }
                        /squelch /twist
                    } else {
                        /if (${Me.Sitting}) {
                            /stand
                            /delay 20 !${Me.Sitting}
                        }
                        /squelch /twist ${TwistWhat}
                    }
                } else {
                    /if (${Me.BardSongPlaying}) {
                        /stopsong
                        /delay 5
                    }
                    /if (${Twist.List.Left[-1].NotEqual[${MeleeTwistWhat}]}) {
                        /echo == Starting melee twist
                        /if (${Me.Sitting}) {
                            /stand
                            /delay 20 !${Me.Sitting}
                        }
                        /if (${Target.ID}==${Me.ID} || ${MyTargetID}!=${Target.ID}) {
                            /if (${MyTargetID}) {
                                /target id ${MyTargetID}
                            } else {
                                /target clear
                            }
                            /delay 5
                        }
                        /squelch /twist ${MeleeTwistWhat}
                    } else {
                        /echo == Resuming melee twist
                        /if (${Me.Sitting}) {
                            /stand
                            /delay 20 !${Me.Sitting}
                        }
                        /if (${Target.ID}==${Me.ID} || ${MyTargetID}!=${Target.ID}) {
                            /if (${MyTargetID}) {
                                /target id ${MyTargetID}
                            } else {
                                /target clear
                            }
                            /delay 5
                        }
                        /squelch /twist
                    }
                    /varset DPSTwisting 2
                }
            } else /if (${TwistOn} && !${Twisting} && !${CombatStart} && (${MeleeTwistOn}!=2 || !${AggroTargetID})) {
                | Handle Normal Twist
                /varset DPSTwisting 0
                /varset Twisting 1
                /if (${Me.BardSongPlaying}) {
                    /stopsong
                    /delay 5
                }
                /if (${Me.Sitting}) {
                    /stand
                    /delay 20 !${Me.Sitting}
                }
                /squelch /twist ${TwistWhat}
                /echo == Starting normal twist
            }
        } else {
            /if (${MeleeTwistOn} && !${DPSTwisting} && (${CombatStart} || (${MeleeTwistOn}==2 && ${AggroTargetID}))) {
                /varset DPSTwisting 1
                /varset Twisting 0
                /if (${MeleeTwistWhat.Equal[Continuous]}) {
                    /echo == Continuing normal twist for melee
                    /return
                } else {
                    /if (${Twist.List.Left[-1].NotEqual[${MeleeTwistWhat}]}) {
                        /call CastBardCheck
                        /echo == Starting melee twist
                        /if (${Target.ID}==${Me.ID} || ${MyTargetID}!=${Target.ID}) {
                            /if (${MyTargetID}) {
                                /target id ${MyTargetID}
                            } else {
                                /target clear
                            }
                            /delay 5
                        }
                        /squelch /twist ${MeleeTwistWhat}
                        /varset DPSTwisting 2
                    }
                }
            } else /if (${MeleeTwistOn} && ${DPSTwisting} && ${AggroTargetID}) {
                /if (${MeleeTwistWhat.NotEqual[Continuous]} && ${DPSTwisting}==1) {
                    /echo == Continuing melee twist
                    /varset DPSTwisting 2
                }
            } else /if (${TwistOn} && !${Twisting} && !${CombatStart} && (${MeleeTwistOn}!=2 || !${AggroTargetID})) {
                /varset DPSTwisting 0
                /varset Twisting 1
                /if (${Twist.List.Left[-1].Equal[${TwistWhat}]}) {
                    /echo == Continuing normal twist
                    /return
                } else {
                    /call CastBardCheck
                    /squelch /twist ${TwistWhat}
                    /echo == Starting normal twist
                }
            } else /if (!${TwistOn} && !${CombatStart}) {
                /varset DPSTwisting 0
                /if (!${AggroTargetID}) {
                    /call CastBardCheck
                    /if (${Twist.List.Length}) /squelch /twist clear
                }
            }
        }
        DEBUGN DoBardStuff: Leave
    /return
| ----------------------------------------------------------------------------
| SUB: GroupEscape
| ----------------------------------------------------------------------------
    Sub GroupEscape
        /if (!${GroupEscapeOn}) /return
        DEBUGN GroupEscape Enter
        |- If (in combat) or (Have AgroID) AND (MA is not present) or (a corpse).
        /if ((${Me.CombatState.Equal[COMBAT]} || ${AggroTargetID}) && (!${Spawn[=${MainAssist}].ID} || ${Spawn[=${MainAssist}].Type.Equal[Corpse]})) {
            DEBUGN GroupEscape: CombatState:${Me.CombatState.Equal[COMBAT]} AggroTargetID:${AggroTargetID} MA Dead:!${Spawn[=${MainAssist}].ID}|${Spawn[=${MainAssist}].Type.Equal[Corpse]}
            /echo + The MA is dead and I'm in combat, activating Group Escape!
            /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
                |-- Druid AA or Spell group evac casting.
                /if (${Select[${Me.Class.ShortName},DRU]}) {
                    |- Drop Divine Barrier if it is up so we can exodus group!
                    /removebuff "Divine Barrier"
                    /if (${Me.AltAbilityReady[Exodus]}) {
                        /call CastWhat "Exodus" ${Me.ID} GroupEscape 0 0
                    } else /if (${Me.Book[Succor]}) {
                        /call CastWhat "Succor" ${Me.ID} GroupEscape 0 0
                    }
                }
                |-- Wizard AA or Spell group evac casting.
                /if (${Select[${Me.Class.ShortName},WIZ]}) {
                    /if (${Me.AltAbilityReady[Exodus]}) {
                        /call CastWhat "Exodus" ${Me.ID} GroupEscape 0 0
                    } else /if (${Me.Book[Evacuate]}) {
                        /call CastWhat "Evacuate" ${Me.ID} GroupEscape 0 0
                    }
                }
            }
        }
        DEBUGN GroupEscape Leave
    /return
| ----------------------------------------------------------------------------
| SUB: CheckHealth
| ----------------------------------------------------------------------------
    Sub CheckHealth(string sentFrom)
        /if (!${HealsOn} || (${Me.Invis} && !${AggroTargetID}) || (${Medding} && ${MedCombat})) /return
        DEBUGHEALS CheckHealth Enter ${sentFrom}
        /declare i                  int         local       0
        /declare MainAssistID       int         local       ${Spawn[=${MainAssist}].ID}
        /declare MostHurtName       string      local
        /declare MostHurtType       string      local
        /declare MostHurtID         int         local       0
        /declare MostHurtHP         int         local       100
        /declare MostHurtNo         int         local       0
        /declare MostHurtFlag       string      local       0
        /declare GroupHealthAvg     string      local       0
        /declare HurtClass          string      local
        /if (${IAmMA} && ${TargetSwitchingOn} && ${Target.ID} && ${Target.ID}!=${MyTargetID} && ${CombatStart}) /call CombatTargetCheck 1
        /varset HealAgain 1
        /while (${HealAgain}) {
            /varset HealAgain 0
            /varset GroupHealthAvg 0
            | Check self health
            /if (${Me.PctHPs} < ${SingleHealPoint}) {
                /call SingleHeal "${Me}" PC ${Me.PctHPs} 0 G
                /continue
            }
            /if (${HealsOn}==4) /break
            | Call MA health check for only those that can heal others. ENC for runes
            /if (${Select[${Me.Class.ShortName},BST,CLR,ENC,SHM,DRU,RNG,PAL]}) {
                | This is to target Main Assist out of group if class can heal
                /if (${Select[${HealsOn},1,3]} && ${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} && ${Spawn[${MainAssist}].ID}!=${Me.ID}) {
                    DEBUGHEALS CheckHealth:  Tank OOG: ${Spawn[${MainAssist}].PctHPs} ${Spawn[${MainAssist} ${MainAssistType}].ID}  ${Spawn[${MainAssist} ${MainAssistType}].Type.NotEqual[corpse]} ${Target.ID} ${Target.PctHPs}
                    |Add code to check if pet HP < needed.
                    /if (${Spawn[${MainAssist} ${MainAssistType}].PctHPs} < ${SingleHealPointMA}) {
                        /call SingleHeal "${MainAssist}" "${MainAssistType}" ${Spawn[${MainAssist} ${MainAssistType}].PctHPs} 6 G
                    }
                }
                /if (${AutoRezOn} && !${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck ma
                | Who is the most hurt
                /if (${Select[${HealsOn},1,2]} && (${Group} || ${XTarHeal}) && !${JustZoned} && !${JoinedParty}) {
                    /varset MostHurtName
                    /varset HurtClass
                    /varset MostHurtType
                    /varset MostHurtID 0
                    /varset MostHurtHP 100
                    /varset MostHurtNo 0
                    /if (!${XTarHeal}) {
                        /for i 0 to 5
                            /if (${Select[${HealsOn},2]} && ${Select[${Spawn[${MainAssist} ${MainAssistType}].ID},${Group.Member[${i}].ID},${Group.Member[${i}].Pet.ID}]}>0) /continue
                            /if (${Group} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].PctHPs}>=1) {
                                /if (${Group.Member[${i}].Distance}>${SingleHealPointRange}) /continue
                                /varset HurtClass ${Group.Member[${i}].Class}
                                DEBUGHEALS CheckHealth:  -- Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP}
                                /if (${HurtClass.NotEqual[berserker]} || ${Group.Member[${i}].Level} < 95) {
                                    /if (${Group.Member[${i}].PctHPs} < ${MostHurtHP}) {
                                        /varset MostHurtName ${Group.Member[${i}].CleanName}
                                        /varset MostHurtType ${Group.Member[${i}].Type}
                                        /varset MostHurtID ${Group.Member[${i}].ID}
                                        /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                                        /varset MostHurtNo ${i}
                                        /varset MostHurtFlag G
                                    }
                                } else /if (${Group.Member[${i}].PctHPs} < ${MostHurtHP} && ${Group.Member[${i}].PctHPs} < 70) {
                                    /varset MostHurtName ${Group.Member[${i}].CleanName}
                                    /varset MostHurtType ${Group.Member[${i}].Type}
                                    /varset MostHurtID ${Group.Member[${i}].ID}
                                    /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                                    /varset MostHurtNo ${i}
                                    /varset MostHurtFlag G
                                }
                                /if (${HealGroupPetsOn} && ${Select[${Group.Member[${i}].Class.Name},cleric,wizard]}==0 && ${Group.Member[${i}].Pet.ID}>0 && ${Group.Member[${i}].Pet.PctHPs} < ${MostHurtHP}) {
                                    /varset MostHurtName ${Group.Member[${i}].Pet.CleanName}
                                    /varset MostHurtType Pet
                                    /varset MostHurtID ${Group.Member[${i}].Pet.ID}
                                    /varset MostHurtHP ${Group.Member[${i}].Pet.PctHPs}
                                    /varcalc MostHurtNo ${i}+8
                                    /varset MostHurtFlag G
                                }
                            }
                        /next i
                    } else /if (${XTarHeal}==2) {
                        /for i 1 to ${XSlotTotal}
                            /if (${XTarToHeal[${i}]}==0) /break
                            /if (${XTarToHeal[${i}]}==${XTSlot}) /continue
                            /if (${Me.XTarget[${XTarToHeal[${i}]}].ID} && ${Me.XTarget[${XTarToHeal[${i}]}].Type.NotEqual[corpse]} && ${Me.XTarget[${XTarToHeal[${i}]}].PctHPs}>=1) {
                                /if (${Me.XTarget[${XTarToHeal[${i}]}].Distance}>${SingleHealPointRange}) /continue
                                DEBUGHEALS CheckHealth:  -- XTarget Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP}
                                /if (${Me.XTarget[${XTarToHeal[${i}]}].PctHPs} < ${MostHurtHP}) {
                                    /varset MostHurtName ${Me.XTarget[${XTarToHeal[${i}]}].CleanName}
                                    /varset MostHurtType ${Me.XTarget[${XTarToHeal[${i}]}].Type}
                                    /varset MostHurtID ${Me.XTarget[${XTarToHeal[${i}]}].ID}
                                    /varset MostHurtHP ${Me.XTarget[${XTarToHeal[${i}]}].PctHPs}
                                    /varset MostHurtNo ${i}
                                    /varset MostHurtFlag X
                                }
                            }
                        /next i
                    } else {
                        /for i 0 to 5
                            /if (${Select[${HealsOn},2]} && ${Select[${Spawn[${MainAssist} ${MainAssistType}].ID},${Group.Member[${i}].ID},${Group.Member[${i}].Pet.ID}]}>0) /continue
                            /if (${Group} && ${Group.Member[${i}].ID} && ${Group.Member[${i}].Type.NotEqual[corpse]} && ${Group.Member[${i}].PctHPs}>=1) {
                                /if (${Group.Member[${i}].Distance}>${SingleHealPointRange}) /continue
                                /varset HurtClass ${Group.Member[${i}].Class}
                                DEBUGHEALS CheckHealth:  -- Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP}
                                /if (${HurtClass.NotEqual[berserker]} || ${Group.Member[${i}].Level} < 95) {
                                    /if (${Group.Member[${i}].PctHPs} < ${MostHurtHP}) {
                                        /varset MostHurtName ${Group.Member[${i}].CleanName}
                                        /varset MostHurtType ${Group.Member[${i}].Type}
                                        /varset MostHurtID ${Group.Member[${i}].ID}
                                        /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                                        /varset MostHurtNo ${i}
                                        /varset MostHurtFlag G
                                    }
                                } else /if (${Group.Member[${i}].PctHPs} < ${MostHurtHP} && ${Group.Member[${i}].PctHPs} < 70) {
                                    /varset MostHurtName ${Group.Member[${i}].CleanName}
                                    /varset MostHurtType ${Group.Member[${i}].Type}
                                    /varset MostHurtID ${Group.Member[${i}].ID}
                                    /varset MostHurtHP ${Group.Member[${i}].PctHPs}
                                    /varset MostHurtNo ${i}
                                    /varset MostHurtFlag G
                                }
                                /if (${HealGroupPetsOn} && ${Select[${Group.Member[${i}].Class.Name},cleric,wizard]}==0 && ${Group.Member[${i}].Pet.ID}>0 && ${Group.Member[${i}].Pet.PctHPs} < ${MostHurtHP}) {
                                    /varset MostHurtName ${Group.Member[${i}].Pet.CleanName}
                                    /varset MostHurtType Pet
                                    /varset MostHurtID ${Group.Member[${i}].Pet.ID}
                                    /varset MostHurtHP ${Group.Member[${i}].Pet.PctHPs}
                                    /varcalc MostHurtNo ${i}+8
                                    /varset MostHurtFlag G
                                }
                            }
                        /next i
                        /for i 1 to ${XSlotTotal}
                            /if (${XTarToHeal[${i}]}==0) /break
                            /if (${XTarToHeal[${i}]}==${XTSlot}) /continue
                            /if (${Me.XTarget[${XTarToHeal[${i}]}].ID} && ${Me.XTarget[${XTarToHeal[${i}]}].Type.NotEqual[corpse]} && ${Me.XTarget[${XTarToHeal[${i}]}].PctHPs}>=1) {
                                /if (${Me.XTarget[${XTarToHeal[${i}]}].Distance}>${SingleHealPointRange}) /continue
                                DEBUGHEALS CheckHealth:  -- XTarget Most Hurt:${i} ${MostHurtNo} ${MostHurtName} ${MostHurtID} ${MostHurtHP}
                                /if (${Me.XTarget[${XTarToHeal[${i}]}].PctHPs} < ${MostHurtHP}) {
                                    /varset MostHurtName ${Me.XTarget[${XTarToHeal[${i}]}].CleanName}
                                    /varset MostHurtType ${Me.XTarget[${XTarToHeal[${i}]}].Type}
                                    /varset MostHurtID ${Me.XTarget[${XTarToHeal[${i}]}].ID}
                                    /varset MostHurtHP ${Me.XTarget[${XTarToHeal[${i}]}].PctHPs}
                                    /varset MostHurtNo ${i}
                                    /varset MostHurtFlag X
                                }
                            }
                        /next i
                    }
                    DEBUGHEALS CheckHealth: (${MostHurtHP} < ${SingleHealPoint}) "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo} ${MostHurtFlag}
                    /if (${MostHurtHP} < ${SingleHealPoint}) {
                        /call SingleHeal "${MostHurtName}" "${MostHurtType}" ${MostHurtHP} ${MostHurtNo} ${MostHurtFlag}
                    }
                }
            }
            | Rez tank check
            /if (${AutoRezOn} && !${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck ma
            | Group Heal Check only call for those clases that can group heal
            /if (${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) {
                /varset GroupHealthAvg ${Group.AvgHPs}
                DEBUGHEALS CheckHealth: Group Health Average ${GroupHealthAvg}
                | Check for group heals
                /if (${GroupHealthAvg} < 100 && ${Group} && ${Group.Injured[90]}>1) {
                    /call DoGroupHealStuff ${GroupHealthAvg}
                    | Rez tank check
                    /if (${AutoRezOn} && !${Spawn[${MainAssist} ${MainAssistType}].ID} && ${Select[${MainAssistType},Mercenary,Pet]}==0) /call RezCheck ma
                }
            }
            /if (${PetOn} && ${Me.Pet.ID} && ${Me.Pet.PctHPs} < 100) /call DoPetHealStuff
        }
        DEBUGHEALS CheckHealth leave ${sentFrom}
        /if (${AutoRezOn}) /call RezCheck group
        /call WriteDebuffs
    /return
|----------------------------------------------------------------------------
| SUB: Single Heals
|----------------------------------------------------------------------------
    Sub SingleHeal(SHealName, SHealType, int SHealHPs, int WhoNum, String SHealFlag)
        /if (!${HealsOn} || ${Me.Moving} || ${Me.Hovering} ||${Spawn[${SHealName} ${SHealType}].ID}==0 || (${Select[${SHealType},PC,Pet,Mercenary]}==0 && !${XTarHeal}) || (${Me.Invis} && !${AggroTargetID})) /return
        DEBUGHEALS SingleHeal Enter: \ayName: ${SHealName} TType: ${SHealType} Hps%: ${SHealHPs} WhoNum:${WhoNum}
        /varset GoMByPass 1
        /doevents
        /varset GoMByPass 0
        /declare i               int     local   0
        /declare SHealSpell      string  local
        /declare SHealTag        string  local
        /declare SHealThem       int     local   ${Spawn[=${SHealName} ${SHealType}].ID}
        /declare SHealClass      string  local   ${Spawn[=${SHealName} ${SHealType}].Class.ShortName}
        /declare MainAssistID    int     local   ${Spawn[=${MainAssist}].ID}
        /declare SHealRange      int     local   0
        /declare HealLoopTimer   timer   local   10
        /declare CondNo          int     local   0
        /declare RemCheck        int     local   0
        | Set MA ID to 6 to keep spell durations correct
        /if (${WhoNum}!=6 && ${SHealThem}==${MainAssistID} && ${SHealFlag.NotEqual[X]}) /varset WhoNum 6
        /if (${SHealType.Equal[corpse]} || !${Spawn[=${SHealName} ${SHealType}].ID} || ${Spawn[=${SHealName}].Type.Equal[corpse]}) /return
        /for i 1 to ${SingleHeal.Size}
            | New Conditional Check to Skip spell
            /if (${ConOn} && ${SingleHeal[${i}].Find[|cond]}) {
                /varset CondNo ${SingleHeal[${i}].Mid[${Math.Calc[${SingleHeal[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            /if (${DebugHeals}) /delay 2
            | If heal is null or off |0 or spell/aa/item not ready skip it
            DEBUGHEALS SingleHeal \awSpell ${i}: ${SingleHeal[${i}]}  ${SingleHeal[${i}].Arg[1,|]}   ${SingleHeal[${i}].Arg[2,|]}   ${SingleHeal[${i}].Arg[3,|]}
            DEBUGHEALS SingleHeal \awSpellSkip: !${SingleHeal[${i}].Length} || ${SingleHeal[${i}].Arg[2,|].Equal[0]}
            /if (!${SingleHeal[${i}].Length} || ${SingleHeal[${i}].Arg[2,|].Equal[0]}) /continue
            /varset SHealSpell   ${SingleHeal[${i}].Arg[1,|]}
            /varset SHealPct     ${SingleHeal[${i}].Arg[2,|]}
            /varset SHealTag     ${SingleHeal[${i}].Arg[3,|]}
            /varset SHealRange ${Spell[${SHealSpell}].Range}
            /call CastReady "${SHealSpell}" singleheal
            /if (!${SpellReadyL}) /continue
            /if (${Spell[${SHealSpell}].TargetType.Find[Group v]}) /varset SHealRange ${Spell[${SHealSpell}].AERange}
            /if (!${SHealRange}) /varset SHealRange 100
            | Skip Heal if pet
            /if (${Spawn[${SHealThem}].Type.NotEqual[Pet]} && ${SHealTag.Equal[pet]}) /continue
            | Skip spells marked for ME and not healing self
            /if (${SHealTag.Equal[me]} && ${SHealThem}!=${Me.ID}) /continue
            /if (${SHealTag.Equal[!me]} && ${SHealThem}==${Me.ID}) /continue
            /if (${SHealTag.Equal[class]} && ${Select[${Spawn[id ${SHealThem}].Class.ShortName},${SingleHeal[${i}].Arg[4,|]}]}==0) /continue
            /if (${SHealTag.Equal[!class]} && ${Select[${Spawn[id ${SHealThem}].Class.ShortName},${SingleHeal[${i}].Arg[4,|]}]}>0) /continue
            /if (${SHealThem}!=${MainAssistID} && (${HealGroupPetsOn} && ${SHealTag.Equal[pet]} && ${Spawn[${SHealThem}].Type.NotEqual[pet]}) || (!${HealGroupPetsOn} && ${SHealTag.Equal[pet]})) /continue
            | If tag MA/Mob and heal target not MA or tag !MA and heal target MA skip
            DEBUGHEALS SingleHeal \awTAG: ${SHealTag.Equal[MA]} && ${SHealThem}!=${MainAssistID} || ${SHealTag.Equal[Mob]} && ${SHealThem}!=${MainAssistID} || ${SHealTag.Equal[!MA]} && ${SHealThem}==${MainAssistID}
            /if ((${SHealTag.Equal[MA]} && ${SHealThem}!=${MainAssistID}) || (${SHealTag.Equal[Mob]} && ${SHealThem}!=${MainAssistID}) || (${SHealTag.Equal[!MA]} && ${SHealThem}==${MainAssistID})) /continue
            | Cleric Divine Arbitration and Epics do not work on pets or people out of group
            /if (${Spell[${SHealSpell}].TargetType.Equal[group v1]} && ${Spawn[id ${SHealThem} group].ID}==0) /continue
            /if (${Spawn[${SHealThem}].Type.Equal[Pet]}  && (${SHealSpell.Find[Aegis of Superior Divinity]} || ${SHealSpell.Find[Harmony of the Soul]} ||  ${SHealSpell.Find[Divine Arbitration]})) /continue
            /if (!${Spawn[id ${SHealThem} group].ID} && (${SHealSpell.Find[Aegis of Superior Divinity]} || ${SHealSpell.Find[Harmony of the Soul]} ||  ${SHealSpell.Find[Divine Arbitration]})) /continue
            | intervention and survival lines only work on group members
            /if (!${Spawn[id ${SHealThem} group].ID} && ${Select[${Me.Class.Name},Druid,Shaman]} && (${SHealSpell.Find[Intervention]} || ${SHealSpell.Find[Survival]})) /continue
            | Check For Life Taps
            /if (${SHealTag.Find[Tap]}) {
                /if (!${Pulled} && ${CombatStart} && ${Me.PctHPs}<=${SHealPct} && ${Target.Type.NotEqual[Corpse]} && ${Spawn[${MyTargetID}].ID} && ${Spawn[${MyTargetID}].Distance}<=${SHealRange} && ${Spell${i}GM0}==0) {
                    /call CastWhat "${SHealSpell}" ${Spawn[${MyTargetID}].ID} SingleHeal ${CondNo} 1
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast o "${SHealSpell} for  >> ${Me.CleanName} <<"
                        /if (${Spell[${SHealSpell}].Duration.TotalSeconds}>0) {
                            /varcalc Spell${i}GM0 ${Spell[${SHealSpell}].MyDuration.TotalSeconds}*10
                        } else /if (${Spell[${SHealSpell}].RecastTime}>0) {
                            /varcalc Spell${i}GM0 ${Spell[${SHealSpell}].RecastTime}/100
                        } else {
                            /varset Spell${i}GM0 10
                        }
                        DEBUGHEALS SingleHeal Assign Timer:Spell${i}GM0 ${Spell[${SHealSpell}].MyDuration.TotalSeconds} ${Spell${i}GM0} Line#: ${Macro.CurLine}
                        /return
                    } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                        /return
                    }
                }
                /continue
            }
            | Check For Nuke Heals - contributed by thenomadman
            /if (${SHealTag.Find[Mob]}) {
                /if (!${AggroTargetID}) /continue
                /while (1) {
                    /varset EventFlag 0
                    /doevents Switch
                    /if (!${EventFlag}) /break
                }
                /if (!${MyTargetID} || ${Spawn[${MyTargetID}].Type.Equal[Corpse]}) /call CombatTargetCheck 0
                /if (${MyTargetID} && ${Spawn[${MainAssist}].PctHPs}<=${SHealPct} && ${Spawn[${MyTargetID}].LineOfSight} && ${Spawn[${MyTargetID}].Distance}<=${SHealRange} && ${Spawn[${MyTargetID}].Type.NotEqual[Corpse]}) {
                    /if (!${HealAgain}) /varset HealAgain 21
                    /call CastWhat "${SHealSpell}" ${MyTargetID} SingleHeal ${CondNo} 1
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /call BroadCast o "${SHealSpell} for >>${Spawn[${SHealName} ${SHealType}].CleanName} << cast on ${Spawn[${MyTargetID}].CleanName}"
                        /varset HealAgain 1
                        /return
                    } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                        /varset HealAgain 1
                        /return
                    } else /if (${Macro.Return.Equal[CAST_NEEDMANA]}) {
                        /varset HealAgain 0
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_COND_FAILED]}) {
                        /if (${HealAgain}==21) /varset HealAgain 0
                        /continue
                    }
                }
                /continue
            }
            | Check conditons for heals
            DEBUGHEALS SingleHeal \aw${SHealHPs}<=${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange} && ${Spell${i}GM${WhoNum}}==0 ${Spell${i}XT${WhoNum}}==0
            /if (${SHealHPs}<=${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange} && ((${SHealFlag.Equal[G]} && ${Spell${i}GM${WhoNum}}==0) || (${SHealFlag.Equal[X]} && ${Spell${i}XT${WhoNum}}==0))) {
                | target has qualified for a heal
                /if (${Spell[${SHealSpell}].TargetType.Equal[Free Target]}) {
                    | Check if spalsh heal target is in line of sight
                    /if (${Target.ID}!=${SHealThem}) {
                        /target id ${SHealThem}
                        /delay 2s ${Target.ID}==${SHealThem}
                    }
                    /if (!${Target.CanSplashLand}) {
                        /echo Splash Spell will NOT land on target. Skipping.
                        /continue
                    }
                }
                /if (${Select[${EverQuest.Server},zek]} && ${Select[${Target.Type},PC]} && ${Me.Combat}) {
                    /attack off
                    /delay 25 !${Me.Combat}
                }
                /if (${SHealThem}==${MainAssistID} && ${Spawn[${MainAssist} ${MainAssistType}].ID}) {
                    /varset RemCheck ${Select[TRUE,${Bool[${Me.Song[${HealRemChk1}].ID}]},${Bool[${Me.Song[${HealRemChk2}].ID}]},${Bool[${Me.Song[${HealRemChk3}].ID}]}]}
                    /if (!${RemCheck}) /varset RemCheck ${Select[TRUE,${Bool[${Me.Buff[${HealRemChk1}].ID}]},${Bool[${Me.Buff[${HealRemChk2}].ID}]},${Bool[${Me.Buff[${HealRemChk3}].ID}]}]}
                    /if (${RemCheck}) {
                        /removebuff "${HealRemChk${RemCheck}}"
                        /echo Removing Invulnerability Buff: ${HealRemChk${RemCheck}}
                    }
                }
                /if (!${HealAgain}) /varset HealAgain 22
                /call CastWhat "${SHealSpell}" ${SHealThem} SingleHeal ${CondNo} 0
                DEBUGHEALS SingleHeal \awMR: ${Macro.Return}
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast o "${SHealSpell} on  >> ${Spawn[${SHealName} ${SHealType}].CleanName} <<"
                    /if (${SHealSpell.Find[Rune]}) {
                        /if (${SHealFlag.Equal[G]}) {
                            /varset Spell${i}GM${WhoNum} 0
                        } else {
                            /varset Spell${i}XT${WhoNum} 0
                        }
                    } else /if (${SHealSpell.Find[Promised]}) {
                        /if (${SHealFlag.Equal[G]}) {
                            /varset Spell${i}GM${WhoNum} 215
                        } else {
                            /varset Spell${i}XT${WhoNum} 215
                        }
                    } else {
                        /if (${SHealFlag.Equal[G]}) {
                            /if (${Spell[${SHealSpell}].Duration.TotalSeconds}>0) {
                            /varcalc Spell${i}GM${WhoNum} ${Spell[${SHealSpell}].MyDuration.TotalSeconds}*10
                            } else /if (${Spell[${SHealSpell}].RecastTime}>0) {
                                /varcalc Spell${i}GM${WhoNum} ${Spell[${SHealSpell}].RecastTime}/100
                            } else {
                                /varset Spell${i}GM${WhoNum} 10
                            }
                        } else {
                            /if (${Spell[${SHealSpell}].Duration.TotalSeconds}>0) {
                            /varcalc Spell${i}XT${WhoNum} ${Spell[${SHealSpell}].MyDuration.TotalSeconds}*10
                            } else /if (${Spell[${SHealSpell}].RecastTime}>0) {
                                /varcalc Spell${i}XT${WhoNum} ${Spell[${SHealSpell}].RecastTime}/100
                            } else {
                                /varset Spell${i}XT${WhoNum} 10
                            }
                        }
                    }
                    DEBUGHEALS SingleHeal Assign Timer:Spell${i}${If[${SHealFlag.Equal[G]},GM,XT]}${WhoNum} ${Spell[${SHealSpell}].MyDuration.TotalSeconds} ${Spell${i}${If[${SHealFlag.Equal[G]},GM,XT]}${WhoNum}}
                    | Prioritize heals by setting flag to check Health again
                    /if (${SHealClass.NotEqual[ber]}) /varset HealAgain 1
                    /return
                } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                    /varset HealAgain 1
                    /return
                } else /if (${Macro.Return.Equal[CAST_NEEDMANA]}) {
                    /varset HealAgain 0
                    /continue
                } else /if (${Macro.Return.Equal[CAST_COND_FAILED]}) {
                    /if (${HealAgain}==22) /varset HealAgain 0
                    /continue
                }
            | Check if target still needs a heal. spell might not be ready or timer not zero.
            } else /if (${SHealHPs}<=${SHealPct} && ${Spawn[${SHealName} ${SHealType}].Distance}<=${SHealRange}) {
                /if (${SHealClass.NotEqual[ber]}) /varset HealAgain 1
            }
        /next i
        DEBUGHEALS \aySingleHeal Leave ${HealAgain}
    /return
| ----------------------------------------------------------------------------
| SUB: Do Group Heal Stuff
| ----------------------------------------------------------------------------
    Sub DoGroupHealStuff(int GroupHealth)
        DEBUGHEALS DoGroupHealStuff Enter ${GroupHealth}
        /varset GoMByPass 1
        /doevents
        /varset GoMByPass 0
        /declare j              int     local
        /declare HealSpell      string  local
        /declare HealPct        string  local
        /declare CondNo         int     local 0
        /for j 1 to ${GroupHeal.Size}
            /if (!${Heals[${j}].Length} || ${Heals[${j}].Arg[2,|].Equal[0]}) /return
            /if (${ConOn} && ${GroupHeal[${j}].Find[|cond]}) {
                /varset CondNo ${GroupHeal[${j}].Mid[${Math.Calc[${GroupHeal[${j}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            /varset HealSpell   ${GroupHeal[${j}].Arg[1,|]}
            /varset HealPct     ${GroupHeal[${j}].Arg[2,|]}
            DEBUGHEALS DoGroupHealStuff ${HealSpell} ${HealPct}
            DEBUGHEALS DoGroupHealStuff Group Heal Spell/Item:${Spell[${HealSpell}].TargetType.Find[group v]}/${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[group v]} Spell:${HealSpell} GpAvg:${GroupHealth} HealAt:${HealPct} Timer:${SpellGH${j}}==0
            /if (${Group.Injured[${HealPct}]} > 1  && ${SpellGH${j}}==0) {
                /call CastReady "${HealSpell}" groupheal
                /call CastWhat "${HealSpell}" ${Me.ID} GroupHeal ${CondNo} 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    DEBUGHEALS DoGroupHealStuff ${HealSpell} on  >> Group <<
                    /call BroadCast o "${HealSpell} on  >> Group <<"
                    /varcalc SpellGH${j} ${Spell[${HealSpell}].MyDuration.TotalSeconds}*10
                    DEBUGHEALS DoGroupHealStuff Assign Timer:SpellGH${j} ${Spell[${HealSpell}].MyDuration.TotalSeconds} ${SpellGH${j}}
                    /varset HealAgain    1
                    /return
                }
            }
        /next j
        DEBUGHEALS DoGroupHealStuff Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: DoPetHealStuff
| -------------------------------------------------------------------------------------
    Sub DoPetHealStuff
        | Check if my pet needs healing
        /if (!${Me.Pet.ID}) /return
        DEBUGHEALS DoPetHealStuff Enter
        /declare j int local
        /for j 1 to ${SingleHeal.Size}
            /if (${SingleHeal[${j}].Arg[3,|].NotEqual[pet]} || !${SingleHeal[${j}].Length} || ${SingleHeal[${j}].Arg[2,|]}==0) /continue
            /if (${Me.Pet.PctHPs}<=${SingleHeal[${j}].Arg[2,|]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range}) {
                DEBUGHEALS DoPetHealStuff (${Me.Pet.PctHPs}<=${SingleHeal[${j}].Arg[2,|]} && ${Me.Pet.ID} && ${Me.Pet.Distance}<${Spell[${SingleHeal[${j}].Arg[1,|]}].Range})
                /call CastWhat "${SingleHeal[${j}].Arg[1,|]}" ${Me.Pet.ID} Heal 0 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast o "${SingleHeal[${j}].Arg[1,|]} on  >> ${Me.Pet.CleanName} <<"
                    /varcalc PetHealTimer${j} ${Spell[${SingleHeal[${j}].Arg[1,|]}].MyDuration.TotalSeconds}*10
                    /varset HealAgain    1
                }
            }
        /next j
        DEBUGHEALS DoPetHealStuff Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Rez With Check
| -------------------------------------------------------------------------------------
    Sub RezWithCheck(string RWCWho)
        /declare RezWithS string local notready
        /declare i int local 0
        /declare RezType string local
        DEBUGHEALS RezWithCheck Enter
        /for i 1 to ${AutoRez.Size}
            /varset RezType ${AutoRez[${i}].Arg[3,|]}
            DEBUGHEALS RezType: ${RezType} ${Me.Combat} ${RWCWho}
            /if (!${Select[${RezType},rez,rezooc,rezcombat]}) {
                /if (${RezType.NotEqual[null]}) /echo invalid Rez Tag: ${RezType} ${i}
                /break
            }
            /if (${Me.CombatState.Equal[COMBAT]} || ${SpawnCount[xtarhater radius ${MeleeDistance}]}) {
                /if (${RezType.Equal[rezooc]}) /continue
            } else {
                /if (${RezType.Equal[rezcombat]}) /continue
            }
            /call CastReady "${AutoRez[${i}].Arg[1,|]}" rezwithcheck
            /if (${Bool[${Macro.Return}]}) {
                /if (${RWCWho.NotEqual[status]}) {
                    /if (!${ConOn} || !${AutoRez[${i}].Find[|cond]} || ${If[${Cond[${AutoRez[${i}].Mid[${Math.Calc[${AutoRez[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
                        /varset RezWithS ${AutoRez[${i}].Arg[1,|]}
                        /break
                    }
                } else {
                    /varset RezWithS ${AutoRez[${i}].Arg[1,|]}
                    /break
                }
            }
        /next i
        DEBUGHEALS RezWithCheck Leave ${RezWithS} ${Macro.Return}
    /return ${RezWithS}
| -------------------------------------------------------------------------------------
| SUB: Rez Check
| -------------------------------------------------------------------------------------
    Sub RezCheck(string RCWho)
        | Don't rez if AutoRezOn=0.  AutoRezOn=1 dmzone not instanced like pok, hovering, invis and no aggro, AutoRezOn=2 and aggro(rez after combat setting)
        /if (!${AutoRezOn}) /return
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Me.Hovering}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${AutoRezOn}==2 && ${AggroTargetID}) /return
        DEBUGHEALS RezCheck Enter
        /declare i int local
        /declare j int local
        /declare CorpseCount int local
        /declare RezMeID int local
        /declare RezID int local
        /declare RezRadius int local 150
        /declare RezXTarget int local 0
        /declare RezCheck1 string local null
        /declare RezCheckID int local 0
        /declare RezCheckTries int local 0
        /declare RezWith string local notready
        /declare RezWait timer local 0
        /declare RezName string local
        /call RezWithCheck status 0
        /varset RezWith ${Macro.Return}
        /if (${RezWith.Equal[notready]}) {
            DEBUGHEALS RezCheck RezWith Not Ready.
            /return
        }
        | Does mainassist have a corpse
        /varset RezID ${Spawn[pccorpse ${MainAssist} radius ${RezRadius} zradius 50].ID}
        /if (${RezID}) {
            /call RezWithCheck MA
            /varset RezWith ${Macro.Return}
            /if (${RezWith.NotEqual[notready]}) {
                /if (${RezWith.Find[Call of]} && !${SpawnCount[pc ${Spawn[${RezID}].CleanName.Left[-9]}]}) {
                    /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                    /if (${OOCRezTimer${RezID}}==0) {
                        /target id ${RezID}
                        /delay 10 ${Target.ID}
                        /if (${Target.Distance}>${CampRadius}) /corpse
                        /delay 10
                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckMA 0 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /call BroadCast o "REZZING MA =>> ${MainAssist} <<="
                            /varset OOCRezTimer${RezID} 1m
                        }
                    }
                }
            }
        }
        /if (${RCWho.Equal[ma]}) /return
        /if (!${RezMeLast}) {
            | Do I have a Corpse
            /varset RezMeID ${Spawn[pccorpse ${Me} radius ${RezRadius} zradius 50].ID}
            /if (${RezMeID}) {
                /call RezWithCheck ME
                /varset RezWith ${Macro.Return}
                /if (${RezWith.NotEqual[notready]}) {
                    /varset CorpseCount ${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}
                    /if (!${Defined[OOCRezTimer${RezMeID}]}) /declare OOCRezTimer${RezMeID} timer outer 0
                    /if (${OOCRezTimer${RezMeID}}==0) {
                        /target id ${RezMeID}
                        /delay 10 ${Target.ID}
                        /if (${Target.Distance}>${CampRadius}) /corpse
                        /delay 10
                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckME 0 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /call BroadCast o "REZZING ME =>> ${Me} <<="
                            /varset OOCRezTimer${RezMeID} 1m
                            /varset RezWait 20
                            /while (${CorpseCount}==${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]} && ${RezWait}) {
                                /delay 5
                            }
                            /if (${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}==0 && ${MountOn} && !${Me.Mount.ID} && ${Me.CombatState.NotEqual[COMBAT]} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]})) /call CastMount
                        }
                    }
                }
            }
            /if (${RCWho.Equal[me]}) /return
        }
        | Does Group Member have a corpse?
        /for i 1 to 5
            /call RezWithCheck group
            /varset RezWith ${Macro.Return}
            DEBUGHEALS RezCheck ${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} pccorpse].Distance}<${RezRadius} ${Spawn[${Group.Member[${i}].CleanName} pccorpse].Deity.ID} ${RezWith}
            /if (${RezWith.NotEqual[notready]}) {
                /if (${Group.Member[${i}].CleanName.Equal[${MainAssist}]}) /continue
                /if (!${Spawn[${Group.Member[${i}].CleanName} pccorpse].ID} || (${RezWith.Find[Call of]} && ${Group.Member[${i}].OtherZone}==FALSE)) /continue
                | Check for group member corpses and battle rez
                /if (${BattleRezTimer${i}}==0 && ${Spawn[${Group.Member[${i}].CleanName} pccorpse].Distance}<${RezRadius}) {
                    /squelch /tar id ${Spawn[${Group.Member[${i}].CleanName} pccorpse].ID}
                    /delay 10 ${Target.ID}
                    /if (${Target.Distance}<100) {
                        /if (${Target.Distance}>${CampRadius}) /corpse
                        /delay 10
                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckG 0 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /if (${CombatStart}) {
                                /call BroadCast o "BATTLE REZZED =>> ${Group.Member[${i}]} <<="
                                /varset BattleRezTimer${i} 3m
                            } else {
                                /call BroadCast o "REZZED =>> ${Group.Member[${i}]} <<="
                                /varset BattleRezTimer${i} 1m
                            }
                            /squelch /target clear
                            /if (${RezWith.Find[Call of]}) /varset BattleRezTimer${i} 6m
                        } else {
                            /if (${Group.Member[${i}].Name.NotEqual[${MainAssist}]}) /varset BattleRezTimer${i} 1m
                        }
                    }
                }
            }
        /next i
        /if (${RezMeLast}) {
            | Do I have a Corpse
            /varset RezMeID ${Spawn[pccorpse ${Me} radius ${RezRadius} zradius 50].ID}
            /if (${RezMeID}) {
                /call RezWithCheck ME
                /varset RezWith ${Macro.Return}
                /if (${RezWith.NotEqual[notready]}) {
                    /varset CorpseCount ${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}
                    /if (!${Defined[OOCRezTimer${RezMeID}]}) /declare OOCRezTimer${RezMeID} timer outer 0
                    /if (${OOCRezTimer${RezMeID}}==0) {
                        /target id ${RezMeID}
                        /delay 10 ${Target.ID}
                        /if (${Target.Distance}>${CampRadius}) /corpse
                        /delay 10
                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckME 0 0
                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                            /call BroadCast o "REZZING ME =>> ${Me} <<="
                            /varset OOCRezTimer${RezMeID} 1m
                            /varset RezWait 20
                            /while (${CorpseCount}==${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]} && ${RezWait}) {
                                /delay 5
                            }
                            /if (${SpawnCount[pccorpse ${Me} radius ${RezRadius} zradius 50]}==0 && ${MountOn} && !${Me.Mount.ID} && ${Me.CombatState.NotEqual[COMBAT]} && (${Zone.Outdoor} || ${Select[${Zone.Type},1,2,5]})) /call CastMount
                        }
                    }
                }
            }
            /if (${RCWho.Equal[me]}) /return
        }
        | Out of Combat Rez |
        /if (!${CombatStart}) {
            | Rez Guild, Fellowship and XTarget members.
            /varset CorpseCount ${SpawnCount[pccorpse radius ${RezRadius} zradius 50]}
            /if (${CorpseCount}>0) {
                /for j 1 to ${CorpseCount}
                    /call RezWithCheck XTARGET
                    /varset RezWith ${Macro.Return}
                    /if (${RezWith.Equal[notready]}) /return
                    /varset RezID ${NearestSpawn[${j},pccorpse radius ${RezRadius} zradius 50].ID}
                    /if (${RezMeID} && ${RezMeID}==${RezID}) /continue
                    /if (${XTarHeal}) {
                        /for i 1 to ${XSlotTotal}
                            /if (${XTarToHeal[${i}]}==0) /continue
                            /if (${XTarToHeal[${i}]}==${XTSlot}) /continue
                            /if (${Me.XTarget[${XTarToHeal[${i}]}].ID} && ${Me.XTarget[${XTarToHeal[${i}]}].Type.Equal[corpse]} && ${Me.XTarget[${XTarToHeal[${i}]}].ID}==${RezID}) {
                                DEBUGHEALS CRezheck:  -- XTarget Corpse Found: ${i} ${Me.XTarget[${XTarToHeal[${i}]}].Name}
                                /varset RezXTarget ${Me.XTarget[${XTarToHeal[${i}]}].ID}
                            }
                            /if (${RezXTarget}) /break
                        /next i
                    }
                    /if (${Spawn[${RezID}].Type.Equal[corpse]}) {
                        /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                        DEBUGHEALS RezCheck ${OOCRezTimer${RezID}} ${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID} ${RezXTarget}
                        /if (${OOCRezTimer${RezID}}==0 && (${Spawn[${RezID}].Guild.Equal[${Me.Guild}]} || ${Spawn[${Me.Fellowship.Member[${Spawn[${RezID}].CleanName.Left[-9]}]} pccorpse].ID} || ${RezXTarget}==${RezID})) {
                            | If call of wild and toon in zone skip
                            /if (${RezWith.Find[Call of]} && ${SpawnCount[pc ${Spawn[${RezID}].CleanName.Left[-9]}]}) /continue
                            /target id ${RezID}
                            /delay 10 ${Target.ID}==${RezID}
                            /if (${Target.Distance}<=${RezRadius}) {
                                /varset RezName ${Target.CleanName}
                                /call CastWhat "${RezWith}" ${Target.ID} RezCheckX 0 0
                                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                    /call BroadCast o "Rezzing =>> ${RezName} <<="
                                    /varset OOCRezTimer${RezID} 3m
                                    /squelch /target clear
                                }
                            }
                        }
                    }
                /next j
            }
            /if (${AutoRezAll}) {
                /varset CorpseCount ${SpawnCount[pccorpse radius ${RezRadius} zradius 50]}
                /if (${CorpseCount}>0) {
                    /for j 1 to ${CorpseCount}
                        /call RezWithCheck rezall
                        /varset RezWith ${Macro.Return}
                        /if (${RezWith.Equal[notready]}) /return
                        /varset RezID ${NearestSpawn[${j},pccorpse radius ${RezRadius} zradius 50].ID}
                        /if (${RezMeID} && ${RezMeID}==${RezID}) /continue
                        /if (${Spawn[${RezID}].Type.Equal[corpse]}) {
                            /if (!${Defined[OOCRezTimer${RezID}]}) /declare OOCRezTimer${RezID} timer outer 0
                            /if (${OOCRezTimer${RezID}}==0) {
                                /if (${CorpseRezCheck.Find[${RezID}:]}) {
                                    /varset i 1
                                    /while (${CorpseRezCheck.Arg[${i},|].NotEqual[null]}) {
                                        /if (${CorpseRezCheck.Arg[${i},|].Find[${RezID}:]}) {
                                            /varset RezCheck1 ${CorpseRezCheck.Arg[${i},|]}
                                            /varset RezCheckID ${RezCheck1.Arg[1,:]}
                                            /varset RezCheckTries ${RezCheck1.Arg[2,:]}
                                        }
                                        /varcalc i ${i}+1
                                    }
                                } else {
                                    /varset RezCheck1 null
                                    /varset RezCheckID ${RezID}
                                    /varset RezCheckTries 0
                                }
                                /if (${RezCheckTries}<3) {
                                    /target id ${RezID}
                                    /delay 10 ${Target.ID}==${RezID}
                                    /if (${Target.Distance}<=${RezRadius}) {
                                        /varset RezName ${Target.CleanName}
                                        /call CastWhat "${RezWith}" ${Target.ID} RezCheckA 0 0
                                        /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                            /varcalc RezCheckTries ${RezCheckTries}+1
                                            /call BroadCast o "Rezzing =>> ${RezName} for the ${RezCheckTries} Time<<="
                                            /varset OOCRezTimer${RezID} 3m
                                            /if (${RezCheck1.NotEqual[null]}) {
                                                /varset CorpseRezCheck ${CorpseRezCheck.Replace[${RezCheck1}|,${RezCheckID}:${RezCheckTries}|]}
                                            } else {
                                                /varset CorpseRezCheck ${RezCheckID}:${RezCheckTries}|${CorpseRezCheck}
                                            }
                                            /squelch /target clear
                                        }
                                    }
                                }
                            }
                        }
                    /next j
                } else {
                    /varset i 1
                    /while (${CorpseRezCheck.Arg[${i},|].NotEqual[null]}) {
                        /varset RezCheck1 ${CorpseRezCheck.Arg[${i},|]}
                        /varset RezCheckID ${RezCheck1.Arg[1,:]}
                        /varset RezCheckTries ${RezCheck1.Arg[2,:]}
                        /if (${Spawn[id ${RezCheckID}].ID}==0 || (${Spawn[id ${RezCheckID}].ID} && ${Spawn[id ${RezCheckID}].Type.NotEqual[corpse]})) {
                            /varset CorpseRezCheck ${CorpseRezCheck.Replace[${RezCheck1}|,]}
                            /if (${Defined[OOCRezTimer${RezCheckID}]}) /deletevar OOCRezTimer${RezCheckID}
                        } else {
                            /varcalc i ${i}+1
                        }
                    }
                }
            }
        }
        DEBUGHEALS RezCheck Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: MassGroupBuff
| -------------------------------------------------------------------------------------
    Sub MassGroupBuff(SpellToCast1,int i1, int CondNumber)
        /if (!${SpellToCast1.Length} || ${i1}==0) /return 0
        /if (!${Spell[${SpellToCast1}].TargetType.Find[Group v]}) {
            /varset Buffs[${i1}] null
            /echo Spell ${SpellToCast1} cannot be MGB'd. Setting to null.
            /return 0
        } else /if (${Me.AltAbility[Tranquil Blessings]}==0) {
            /varset Buffs[${i1}] null
            /echo You don't have Tranquil Blessings AA. Setting ${SpellToCast1} to null.
            /return 0
        }
        /if (${Select[${Me.CombatState},active,resting]}==0) {
            /echo Your Not Resting. Will Have to Wait to cast MGB.
        } else /if (${Me.AltAbilityReady[Tranquil Blessings]} && ${Me.CurrentMana}>=${Math.Calc[${Spell[${SpellToCast1}].Mana}*2]}) {
            /if (!${CondNumber} || ${If[${Cond[${CondNumber}]},1,0]}) {
                /call CastWhat "Tranquil Blessings" ${Me.ID} Buffs-nomem 0 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo Casting Tranquil Blessings for MGB of ${SpellToCast1}
                    /call CastWhat "${SpellToCast1}" ${Me.ID} Buffs-nomem 0 0
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo MGB of ${SpellToCast1} Successful.
                    }
                }
            }
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: Loot Stuff
| -------------------------------------------------------------------------------------
    Sub LootStuff
        /if (!${LootOn} || (!${Me.UseAdvancedLooting} && ${AggroTargetID}) || (${IAmMA} && ${AggroTargetID}) || (${DMZ} && ${Me.InInstance}==FALSE) || ${Me.Invis}) /return
        DEBUGN LootStuff: Enter
        /if (${Me.FreeInventory}==0) {
            /echo Inventory is full. Looting OFF
            /varset LootOn 0
            /if (${Defined[NALStatus]}) {
                /varset NALStatus 0
            }
            /return
        }
        /doevents
        /if (${Me.UseAdvancedLooting}) {
            /if (${Bool[${Plugin[MQ2AutoLoot]}]}) {
                /if (${AutoLoot.Active}) /return
            }
            /call UseAdvLoot
        } else {
            /call LootMobs
        }
        /call DoWeMove 0 lootstuff
        DEBUGN LootStuff: Leave
    /return
| -------------------------------------------------------------------------------------
|   Sub MobRadar
| -------------------------------------------------------------------------------------
    Sub MobRadar(string RadarCheck,int CountRadius,string calledfrom)
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        DEBUGN MobRadar ${CountRadius} Enter ${calledfrom} ${RadarCheck}
        /declare NMob              int      local
        /declare i                 int      local
        /declare i_CorpseCount     int      local 0
        /if (${RadarCheck.Equal[los]}) {
            /varset MobCount ${SpawnCount[npc targetable los radius ${CountRadius} zradius 50 noalert 3]}
            /if (${MobCount}>0) {
                /for i 1 to ${MobCount}
                    /varset NMob ${NearestSpawn[${i},npc targetable los radius ${CountRadius} zradius 50 noalert 3].ID}
                    /if (${i}>${XSlotTotal}) /break
                    /if (${NMob} && (${Spawn[${NMob}].Type.Equal[Corpse]} || !${Spawn[${NMob}].ID})) {
                        |/call RemoveFromArray AddsArray ${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}
                        /varcalc i_CorpseCount ${i_CorpseCount}+1
                    }
                    |} else /if (${Select[${NMob},${AddsArray[1,1]},${AddsArray[2,1]},${AddsArray[3,1]},${AddsArray[4,1]},${AddsArray[5,1]},${AddsArray[6,1]},${AddsArray[7,1]},${AddsArray[8,1]},${AddsArray[9,1]},${AddsArray[10,1]},${AddsArray[11,1]},${AddsArray[12,1]},${AddsArray[13,1]}]}==0) {
                    |    /call AddToArray AddsArray ${NMob}
                    |}
                /next i
                /varcalc MobCount ${MobCount}-${i_CorpseCount}
            }
        } else /if (${RadarCheck.Equal[xtar]}) {
            /if (${CountRadius}>0) {
                /varset i_CorpseCount ${SpawnCount[xtarhater npccorpse radius ${CountRadius} zradius 50]}
                /varcalc MobCount ${SpawnCount[xtarhater radius ${CountRadius} zradius 50]}-${i_CorpseCount}
            } else {
                /varset i_CorpseCount ${SpawnCount[xtarhater npccorpse]}
                /varcalc MobCount ${SpawnCount[xtarhater]}-${i_CorpseCount}
            }
        } else /if (${RadarCheck.Equal[pull]}) {
            /varset i_CorpseCount ${SpawnCount[npccorpse los loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius 50 noalert 3]}
            /varcalc MobCount ${SpawnCount[npc targetable los loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius 50 noalert 3]}-${i_CorpseCount}
        }
        DEBUGN MobRadar ${calledfrom} ${RadarCheck} ${MobCount} ${i_CorpseCount} ${XTSlot} ${Me.XTarget[${XTSlot}].ID} ${Me.XTarget[${XTSlot}].Type}
        | Check if NPC Pet is on Xtarget
        /if (!${MobCount} && ${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].Type.NotEqual[corpse]}) {
            DEBUGN MobRadar MobCount=0 but Mob on Xtarget Setting Mobcount to 1
            /varset MobCount 1
        } else /if (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].TargetType.NotEqual[Auto Hater]}) {
            /varcalc MobCount ${MobCount}+1
        }
        DEBUGN MobRadar Leave ${MobCount}
    /return
| -------------------------------------------------------------------------------------
|   Sub MezRadar
| -------------------------------------------------------------------------------------
    Sub MezRadar
        /if ((${DMZ} && ${Me.InInstance}==FALSE)) /return
        DEBUGMEZ MezRadar Enter
        /declare NMMob int local 0
        /declare i int local
        /varset MezMobAECount 0
        /varset MezAEClosest 0
        /varset MezMobCount ${SpawnCount[xtarhater]}
        /varset MezMobAECount ${SpawnCount[xtarhater radius ${MezRadius}]}
        /if (${Me.XTarget[${XTSlot}].TargetType.NotEqual[Auto Hater]} && ${Me.XTarget[${XTSlot}].ID}) {
            /varcalc MezMobCount ${MezMobCount}+1
            /varcalc MezMobAECount ${MezMobAECount}+1
        }
        /if (${MezMobAECount}) {
            /for i 1 to ${MezMobAECount}
                /varset NMMob ${NearestSpawn[${i},xtarhater radius ${MezRadius}].ID}
                DEBUGMEZ MezRadar:  ${i} ${NMMob} ${Spawn[id ${NMMob}].Type}
                /if (${NMMob} && ${Select[${NMMob},${MezArray[1,1]},${MezArray[2,1]},${MezArray[3,1]},${MezArray[4,1]},${MezArray[5,1]},${MezArray[6,1]},${MezArray[7,1]},${MezArray[8,1]},${MezArray[9,1]},${MezArray[10,1]},${MezArray[11,1]},${MezArray[12,1]},${MezArray[13,1]}]}==0) {
                    DEBUGMEZ MezRadar: ADDING -> Name: ${Spawn[${NMMob}].Name} ID: ${NMMob} to mezlist
                    /call AddToArray MezArray ${NMMob}
                }
            /next i
        }
        /varset MezAEClosest ${NearestSpawn[1,xtarhater radius ${MezRadius}].ID}
        /if (${DebugMez}) /delay 5
        DEBUGMEZ MezRadar: MezMobCount: ${MezMobCount} Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Add to Array
| -------------------------------------------------------------------------------------
    Sub AddToArray(ArrayName, int AddMobID)
        /if (!${AddMobID}) /return
        DEBUGN AddToArray ${AddMobID} Enter
        /declare i int local
        |/for i 1 to 13
        /for i 1 to ${XSlotTotal}
            /if (${${ArrayName}[${i},1].Equal[NULL]}) {
                /varset ${ArrayName}[${i},1] ${Spawn[${AddMobID}].ID}
                /varset ${ArrayName}[${i},2] ${Spawn[${AddMobID}].Level}
                /varset ${ArrayName}[${i},3] ${Spawn[${AddMobID}].CleanName}
                DEBUGN ARRAY Assign >> ${${ArrayName}[${i},3]} << to ${ArrayName}${i}.
                /return
            }
        /next i
        DEBUGN AddToArray Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Remove From Array
| -------------------------------------------------------------------------------------
    Sub RemoveFromArray(RArrayName, int ArNum)
        /if (${${RArrayName}[${ArNum},1].Equal[NULL]}) /return
        /if (${ArNum}<1 || ${ArNum}>${${RArrayName}.Size}) /return
        DEBUGN RemoveFromArray ${ArNum} Enter
        DEBUGN ARRAY Remove >> ${${RArrayName}[${ArNum},3]} << from ${RArrayName}${ArNum}.
        /varset ${RArrayName}[${ArNum},1] NULL
        /varset ${RArrayName}[${ArNum},2] NULL
        /varset ${RArrayName}[${ArNum},3] NULL
        /if (${MezOn} && ${ArNum}<=13) {
            /varset MezCount[${ArNum}] 0
            /varset MezTimer${ArNum} 0
        }
        DEBUGN RemoveFromArray Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Do Mez Stuff
| -------------------------------------------------------------------------------------
    Sub DoMezStuff(string SentFrom)
        /if (${EventByPass}!=2) {
            /varset EventByPass 1
            /varset GoMByPass 1
            /while (1) {
                /varset EventFlag 0
                /doevents
                /if (!${EventFlag}) /break
            }
            |/doevents
            /varset MezBroke 0
            /varset EventByPass 0
            /varset GoMByPass 0
        }
        /varset GoMByPass 0
        /if (!${MezOn} || ${Me.Hovering} || (!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]}) || ${DMZ} && ${Me.InInstance}==FALSE) /return
        DEBUGMEZ DoMezStuff: Enter ${SentFrom}
        /declare i int local 0
        /declare j int local 0
        /declare skipFlag int local 0
        /declare mezCombat bool local False
        | Reset skip mez on health setting if tank dies to 1%
        /if (!${Spawn[=${MainAssist}].ID}) /varset MezStopHPs 1
        /if (${Me.Combat} || ${Me.CombatState.Equal[combat]} || ${DPSOn}) /varset mezCombat True
        /call MezRadar
        DEBUGMEZ DoMezStuff MezMobCount ${MezMobCount} ${mezCombat}
        /if (${MezMobCount}<2 && ${Spawn[=${MainAssist}].ID}) {
            DEBUGMEZ MezMobCount was ${MezMobCount} (so less than 2) & ${MainAssist} is alive so we return
            /varset MezMobDone 1
            /return
        }
        | Necros can't AE mez.
        | MezOn - 0=Off/1=Single & AE Mez/2=Single Mez only/3=AE Mez only.
        /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
            /if (${Select[${MezOn},1,3]} && ${MezAECount}>0 && ${MezMobAECount}>=${MezAECount} && ${MezAETimer}==0) {
                DEBUGMEZ I'm about to AEMez
                /varset MezMobAECount ${SpawnCount[npc xtarhater loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]}
                | Check if Mezzer out of group and using XTSlot to assist MainAssist. Add 1 mob to count.
                /if (${Me.XTarget[${XTSlot}].TargetType.NotEqual[Auto Hater]} && ${Me.XTarget[${XTSlot}].Type.NotEqual[pc]}) /varcalc MezMobAECount ${MezMobAECount}+1
                /if (${MezMobAECount}>=${SpawnCount[npc loc ${Spawn[id ${MezAEClosest}].X} ${Spawn[id ${MezAEClosest}].Y} radius ${Spell[${MezAESpell}].AERange}]}) /call MezMobsAE ${MezAEClosest}
            }
        }
        /for i 1 to ${XSlotTotal}
            /varset skipFlag 0
            | Every Mez test conditon is listed seperately for clarity
            DEBUGMEZ we are in the mezcondition loop i is: ${i} ${MezTimer${i}} ${Spawn[${MezArray[${i},1]}].ID}
            | Test -> Is my single mez spell ready
            /if (!${Me.SpellReady[${MezSpell}]} && !${IAmABard}) {
                /if (${MezOn}!=2) {
                    DEBUGMEZ ${MezSpell} not ready, return
                    /return
                }
                /while (!${Me.SpellReady[${MezSpell}]}) {
                    DOPARSE
                    /delay 2
                }
            }
            | Test -> array not empty,
            /if (${MezArray[${i},1].Equal[NULL]}) {
                DEBUGMEZ ${i}  MezArray[${i},1] was equal to NULL, Skip
                /continue
            }
            | Test -> Target is dead
            /if (!${Spawn[${MezArray[${i},1]}].ID} || ${Spawn[${MezArray[${i},1]}].Type.Equal[corpse]}) {
                DEBUGMEZ ${i}  ${MezArray[${i},3]} is dead, Skip
                /call RemoveFromArray MezArray ${i}
                /continue
            }
            | Is mob in MezRadius distance
            /if (${Spawn[${MezArray[${i},1]}].Distance}>=${MezRadius}) {
                DEBUGMEZ ${i}  Mob distance is greater than MezRadius: ${Spawn[${MezArray[${i},1]}].Distance} ${MezRadius} Skip
                /call RemoveFromArray MezArray ${i}
                /continue
            }
            | Test -> is target MA's current Target
            /if (${Spawn[${MezArray[${i},1]}].ID}==${MyTargetID} && ${Spawn[=${MainAssist}].ID}) {
                DEBUGMEZ ${Spawn[${MezArray[${i},1]}].Name} had the same ID(${Spawn[${MezArray[${i},1]}].ID}) as MyTargetID(${MyTargetID}) & ${MainAssist}(${Spawn[=${MainAssist}].ID}), Skip
                /call RemoveFromArray MezArray ${i}
                /continue
            }
            | Test -> is  MA's a merc skip 1st target so he attackes it.
            /if (${AggroTargetID} && !${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) {
                DEBUGMEZ AggroTargetID = ${AggroTargetID}  MyTargetID = ${MyTargetID} & Spawn[=MainAssist].ID = ${Spawn[=${MainAssist}].ID} & Spawn[=MainAssist].Type.Equal[Mercenary] was true, Skip
                /call RemoveFromArray MezArray ${i}
                /continue
            }
            | Test -> is taget above mez hps threshold
            /if (${Spawn[${MezArray[${i},1]}].PctHPs}<${MezStopHPs}) {
                DEBUGMEZ Spawn[MezArray[${i},1]].PctHPs(${Spawn[${MezArray[${i},1]}].PctHPs}) was less than MezStopHPs(${MezStopHPs}), Skip
                /call RemoveFromArray MezArray ${i}
                /continue
            }
            | Test -> is target within levels defined in ini file
            /if (${MezArray[${i},2]}>${MezMaxLevel} || ${MezArray[${i},2]}<${MezMinLevel}) {
                DEBUGMEZ MezArray[${i},2](${MezArray[${i},2]}) was greater than MezMaxLevel(${MezMaxLevel}) OR less than MezMinLevel(${MezMinLevel}), Skip
                /call RemoveFromArray MezArray ${i}
                /continue
            }
            | Test -> is the target in line of sight
            /if (!${Spawn[${MezArray[${i},1]}].LineOfSight}) {
                DEBUGMEZ I dont have LineOfSight to Spawn[MezArray[${i},1]](${Spawn[${MezArray[${i},1]}].Name} ID:${Spawn[${MezArray[${i},1]}].ID}), Skip
                /continue
            }
            | Test -> I am a bard and if the player is dumb enough to have me tank then don't mez.
            /if (${IAmABard} && ${IAmMA} && ${MyTargetID} && ${AggroTargetID} && ${MezArray[${i},1].Equal[${MyTargetID}]}) {
                DEBUGMEZ im a bard and stuff, Skip
                /continue
            }
            | Test -> is target a giant unmezzable
            /if (${Spawn[${MezArray[${i},1]}].Body.Name.Equal[Giant]}) {
                DEBUGMEZ Spawn[MezArray[${i},1]] (${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]}) is a giant, Skip
                /continue
            }
            | Test -> is target on my mez immune list
            /if (${Alert[4].Size}) {
                /for j 0 to ${Alert[4].Size}
                    /if (${Alert[4].List[${j}].Name.Equal[${MezArray[${i},3]}]} && ${Alert[4].List[${j}].Name.Length}) {
                        /if (${MMTimer${i}}==0) /call BroadCast g "MEZ Immune Detected -> ${MezArray[${i},3]} <- ID:${MezArray[${i},1]}"
                        /varset MMTimer${i} 1m
                        DEBUGMEZ ${Spawn[${MezArray[${i},1]}].Name} ID:${MezArray[${i},1]} is immune, Skip
                        /varset skipFlag 1
                        /break
                    }
                /next j
                /if (${skipFlag}) {
                    /call RemoveFromArray MezArray ${i}
                    /continue
                }
            }
            | Test -> Do i have enough mana to cast the spell
            /if (${Me.CurrentMana}<${Spell[${MezSpell}].Mana}) {
                DEBUGMEZ i didnt have enough mana to cast ${MezSpell}, Skip
                /continue
            }
            | Test -> Do i have a mez timer on the mob?
            /if (${MezTimer${i}} > 0) {
                DEBUGMEZ MezTimer${i}(${MezTimer${i}}) was greater than 0 , Skip
                /continue
            }
            | Stop mezzing last mob because pets and mercs won't attack it.
            /if (${MezMobCount}<=1 && ${Spawn[=${MainAssist}].ID} && (${Spawn[=${MainAssist}].Type.Equal[Mercenary]} || ${Spawn[=${MainAssist}].Type.Equal[Pet]})) {
                DEBUGMEZ MezMobCount(${MezMobCount}) was less or equal to 1 & ( MainAssist(${MainAssist}) was a Mercenary OR a Pet ), Skip
                /continue
            }
            /if (${Spawn[${MainAssist} ${MainAssistType} group].ID} && ${Select[${MezArray[${i},1]},XTCHECK]}==0) {
                DEBUGMEZ If tank is alive and mob not on xtarget Skip
                /continue
            }
            /if (${MezImmuneIDs.Find[|${MezArray[${i},1]}]}) {
                DEBUGMEZ Mez Immune Mob Detected: ${MezArray[${i},3]} Skip
                /call RemoveFromArray MezArray ${i}
                /continue
            }
            DEBUGMEZ MezTimer ${i} ${MezTimer${i}} ${Spawn[${MezArray[${i},1]}].ID}
            /if (${Select[${MezOn},1,2]}) {
                /doevent AttackCalled
                /if (${CalledTargetID}) {
                    /call CombatTargetCheck 0
                    /if (${MyTargetID}==${MezArray[${i},1]}) /continue
                }
                DEBUGMEZ im gonna singlemez ${MezArray[${i},1]} ${Me.Invis}
                /if (${Me.Invis}) /makemevisible
                /call MezMobs ${MezArray[${i},1]} ${i}
                /varset MezMobDone 1
                /if (${Macro.Return.Equal[CAST_CANCELLED]} && ${MezAETimer}==0 && ${MezOn}==1) {
                    DEBUGMEZ I'm about to AEMez-
                    /call MezMobsAE ${MezAEClosest}
                    /varcalc i ${i}-1
                }
            }
        /next i
        /if (!${Target.ID} || ${Target.ID}!=${MyTargetID}) {
            /if (${mezCombat}) {
                /call CombatTargetCheck 1
            } else /if (${IAmABard} && ${MeleeTwistOn} && ${CombatStart}) {
                /call CombatTargetCheck 1
            }
        }
        DEBUGMEZ DoMezStuff: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs AE
| -------------------------------------------------------------------------------------
    Sub MezMobsAE(int AEMezID)
        | Bard AE mez code
        /declare i int local 1
        /declare WasChasing int local 0
        /if (!${Me.AltAbility[${MezAESpell}]} && !${Me.Book[${MezAESpell}]}) {
            /echo Invalid AEMezSpell ${MezAESpell}. Check the spelling.
            /return
        }
        /if (${IAmABard}) {
            /if (${Target.ID}) /varset AEMezID ${Target.ID}
            /call CastWhat "${MezAESpell}" ${AEMezID} Mez 0 0
            /call BroadCast g "MEZZING-> AE Mezzing Now - ${MezAESpell} "
            /varset MezAETimer 300
        }
        | Enchanter AE mez code
        /if (${Me.Class.Name.Equal[Enchanter]}) {
            /if (${ChaseAssist}) {
                /varset ChaseAssist 0
                /varset WasChasing 1
                /squelch /stick off
                /moveto off
                /if (${PullMoveUse.Equal[nav]}) {
                    /if (${Navigation.Active}) /nav stop
                }
                /delay 30 !${Me.Moving}
            }
            /echo I AM AE MEZZING ${MezAESpell}
            /while (!${Me.SpellReady[${MezAESpell}]}) {
                /delay 2
            }
            /call BroadCast g "Casting AE Mez-> ${MezAESpell}"
            /call CastWhat "${MezAESpell}" ${AEMezID} Mez 0 0
            /if (${Select[${Macro.Return},CAST_SUCCESS,CAST_RESISTED,CAST_IMMUNE]}) {
                /echo I JUST CAST AE MEZ ${MezAESpell}
                /varset MezAETimer ${Spell[${MezAESpell}].Duration.TotalSeconds}s
                DEBUGMEZ TIMER SET ${MezAETimer}
                /call BroadCast g "AE MEZ Complete-> ${MezAESpell}"
            } else {
                /call BroadCast g "AE MEZ ${MezAESpell} Failed -> ${Macro.Return}"
                /varset MezAETimer ${Me.GemTimer[${MezAESpell}].TotalSeconds}s
            }
            /if (${WasChasing}) /varset ChaseAssist 1
        }
        | Reset all mez timers to 0 after AE Mez
        /for i 1 to 30
            /varset MezTimer${i} 0
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Mez Mobs
| -------------------------------------------------------------------------------------
    Sub MezMobs(int MobID, int TimerNum)
        DEBUGMEZ MezMobs Enter MobID:${MobID} Timer#:${TimerNum}
        /declare MezFail int local 0
        /declare MezTry int local 1
        /declare ReMez int local 0
        /if (${Me.Combat}) {
            /attack off
            /delay 25 !${Me.Combat}
        }
        | Added this check because of timing. Mob to mez was getting DOTed because of MeleeTwist. 
        /if (${IAmABard} && ${MeleeTwistOn}) /call CastBardCheck 0
        /squelch /target id ${MobID}
        /delay 20 ${Target.ID}==${MobID} && ${Target.BuffsPopulated}
        /if (${Target.ID}==${MobID}) {
            /if (${Int[${Target.Mezzed.ID}]} && ${Target.Mezzed.Name.Equal[${MezSpell}]}) {
                DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} Target Info: ${Target.Mezzed.ID} ${Target.Mezzed.Name} ${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds} Line#: ${Macro.CurLine}
                /if (${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds}>${Math.Calc[${Spell[${MezSpell}].MyDuration.TotalSeconds}*.10]}) {
                    /varcalc MezCount[${TimerNum}] 1
                    /varcalc MezTimer${TimerNum} (${Target.BuffDuration[${Target.Mezzed.Name}].TotalSeconds}*10)*.85
                    /return
                }
            }
            /if (${MezCount[${TimerNum}]}<1) {
                /call BroadCast g "MEZZING-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
            } else {
                /call BroadCast g "ReMEZZING-> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                /varset ReMez 1
            }
            | Chanter mez code
            /if (${Me.Class.Name.Equal[Enchanter]}) {
                /while (1) {
                    /call CastWhat "${MezSpell}" ${MobID} MezMobs 0 0
                    /varcalc MezFail ${MezFail}+1
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /if (!${ReMez}) {
                            /call BroadCast g "JUST MEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                        } else {
                            /call BroadCast g "JUST REMEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                        }
                        /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                        /varcalc MezTimer${TimerNum} (${Spell[${MezSpell}].MyDuration.TotalSeconds}*10)*.90
                        DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}}
                    } else /if (${Macro.Return.Equal[CAST_RESISTED]} && ${MezFail}<2) {
                        /call BroadCast g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                        | Added for Debuffing Resistant Mobs while Mezzing.
                        /if (${MezDebuffOnResist} && !${Target.Tashed.ID}) {
                            /while (${Me.SpellInCooldown}) {
                                /delay 3
                            }
                            /call CastWhat "${MezDebuffSpell}" ${MobID} MezDebuff 0 0
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /call BroadCast g "MEZ Debuffed -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                                /while (${Me.SpellInCooldown}) {
                                    /delay 3
                                }
                            }
                        }
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                        /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                        /if (${AAMezImmune}) /call Bind_AddMezImmune ${Target.CleanName}
                    } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                        /if (${CastingInterruptOn}) /return CAST_CANCELLED
                    }
                    /break
                }
            | Bard mez code
            } else /if (${IAmABard}) {
                /while (1) {
                    /call CastWhat "${MezSpell}" ${MobID} MezMobs 0 0
                    /varcalc MezFail ${MezFail}+1
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /if (!${ReMez}) {
                            /call BroadCast g "JUST MEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                        } else {
                            /call BroadCast g "JUST REMEZZED -> ${MezSpell} on ${Spawn[${MobID}].CleanName}:${MobID}"
                        }
                        /squelch /target clear
                        /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                        /varcalc MezTimer${TimerNum} (${Spell[${MezSpell}].MyDuration.TotalSeconds}*10)*.90
                        DEBUGMEZ MezTimer${TimerNum} ${MezTimer${TimerNum}} ${Macro.Return}
                    } else /if (${Macro.Return.Equal[CAST_RESISTED]} && ${MezFail}<2) {
                        /call BroadCast g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                        DEBUGMEZ Cast Resisted ${Macro.Return}
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                        /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                        /if (${AAMezImmune}) /call Bind_AddMezImmune ${Target.CleanName}
                        DEBUGMEZ Cast Immune ${Macro.Return}
                    } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                        DEBUGMEZ Cast Cancelled ${Macro.Return}
                        /if (${CastingInterruptOn}) /return CAST_CANCELLED
                    }
                    /break
                }
            | Necro mez code
            } else /if (${Me.Class.Name.Equal[Necromancer]}) {
                /while (1) {
                    /call CastWhat "${MezSpell}" ${MobID} Mez 0 0
                    /varcalc MezFail ${MezFail}+1
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /varcalc MezCount[${TimerNum}] ${MezCount[${TimerNum}]}+1
                        /varcalc MezTimer${TimerNum} (${Spell[${MezSpell}].MyDuration.TotalSeconds}*10)*.95
                        DEBUGMEZ MezMobs MezTimer${TimerNum} ${MezTimer${TimerNum}}
                        | Necro flag to release from mez loop since spell has 6 sec refresh.
                    } else /if (${Macro.Return.Equal[CAST_RESISTED]} && ${MezFail}<2) {
                        /call BroadCast g "MEZ Resisted -> ${Spawn[${MobID}].CleanName} <- ID:${MobID}"
                        /continue
                    } else /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                        /if (!${MezImmuneIDs.Find[|${Target.ID}]}) /call AddMezImmune ${Target.ID}
                        /if (${AAMezImmune}) /call Bind_AddMezImmune ${Target.CleanName}
                    }
                    /break
                }
            }
            /varset MezTry 0
        }
        DEBUGMEZ MezMobs Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Do Debuff Stuff
| -------------------------------------------------------------------------------------
    Sub DoDebuffStuff(int FirstMobID)
        /doevents
        /if (!${DebuffAllOn} || !${DebuffCount} || ${Window[RespawnWnd].Open} || (${MezOn} && !${MezMobDone})) /return
        /if ((${DMZ} && ${Me.InInstance}==FALSE) || (!${MyTargetID} && ${Spawn[=${MainAssist}].ID} && ${Spawn[=${MainAssist}].Type.NotEqual[Mercenary]})) /return
        /if (${DPSPaused}) {
            DEBUGCOMBAT DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused}
            /return
        }
        DEBUGCOMBAT DoDebuffStuff: Enter
        /declare i               int      local 0
        /declare j               int      local 0
        /declare k               int      local 0
        /declare DebuffTargetID  int      local 0
        /declare DebuffText      string   local
        /declare WasAttacking    int      local 0
        /if (${IAmABard} && ${IAmMA} && ${MyTargetID} && ${AggroTargetID}) {
            DEBUGCOMBAT im a bard and stuff so im getting out of here. Returning
            /return
        }
        /call MobRadar los ${MeleeDistance} DoDebuffStuff
        /for i 1 to ${DebuffCount}
            /if (${DBOList${i}.Length}) {
                /varset k 1
                /if (!${DBOTimer${i}}) {
                    | Reset the list with only the current DPS mob ID. So you won't try and debuff the mob again.
                    /varset DBOList${i} |${MyTargetID}
                } else {
                    |Remove mobs from list that are dead or over 200 units away.
                    /while (${DBOList${i}.Arg[${k},|].Length}) {
                        /if (!${Spawn[${DBOList${i}.Arg[${k},|]}].ID} || ${Spawn[${DBOList${i}.Arg[${k},|]}].Distance}>200 || ${Spawn[${DBOList${i}.Arg[${k},|]}].Type.Equal[Corpse]}) {
                            /varset DBOList${i} ${DBOList${i}.Replace[|${DBOList${i}.Arg[${k},|]},]}
                        } else {
                            /varcalc k ${k}+1
                        }
                    }
                }
            }
        /next i
        | For Mobs
        DEBUGCOMBAT MobCount was ${MobCount} MainAssist: ${MainAssist} FirstMobID: ${FirstMobID} MyTargetID: ${MyTargetID}
        /if (${Spawn[${FirstMobID}].Type.Equal[npc]} || (${Spawn[${FirstMobID}].Type.Equal[pet]} && ${Spawn[${FirstMobID}].Master.Type.NotEqual[pc]})) /call DebuffCast "${FirstMobID}" 1
        /for j 1 to ${XSlotTotal}
            |--- only call code for GroupEscape kick off.
            /varset DebuffTargetID ${MyTargetID}
            /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
            /if (${DPSPaused}) {
                DEBUGCOMBAT DoDebuffStuff: Return from CombatCast cause DPSPaused is ${DPSPaused}
                /return
            }
            /if (!${Me.XTarget[${j}].ID} || (${Me.XTarget[${j}].ID}==${FirstMobID})) /continue
            | Every Debuff test conditon is listed seperately because Maskoi forgets why he does anything.
            DEBUGCOMBAT DoDebuffStuff: we are in the debuffcondition loop j is: ${j}
            | Is Xtarget type not of type auto hater
            /if (${Me.XTarget[${j}].TargetType.NotEqual[Auto Hater]} || ${Spawn[${Me.XTarget[${j}].ID}].Type.Equal[Corpse]}) {
                DEBUGCOMBAT XTarget Type: ${Me.XTarget[${j}].TargetType} Spawn Type: ${Spawn[${Me.XTarget[${j}].ID}].Type}
                /continue
            }
            | Is mob in spell Radius distance
            /if (${Spawn[${Me.XTarget[${j}].ID}].Distance}>=${MeleeDistance}) {
                DEBUGCOMBAT DoDebuffStuff: ${j}  Mob distance is greater than MeleeDistance: ${Spawn[${Me.XTarget[${j}].ID}].Distance}
                /continue
            }
            | Test -> is the target in line of sight
            /if (!${Spawn[${Me.XTarget[${j}].ID}].LineOfSight}) {
                DEBUGCOMBAT DoDebuffStuff: I dont have LineOfSight to Spawn[${Me.XTarget[${j}].ID}] ${Spawn[${Me.XTarget[${j}].ID}].Name} so im going to Skip Mob
                /continue
            }
            /if (${Spawn[${Me.XTarget[${j}].ID}].Type.Equal[pc]} || (${Spawn[${Me.XTarget[${j}].ID}].Type.Equal[pet]} && ${Spawn[${Me.XTarget[${j}].ID}].Master.Type.Equal[pc]})) {
                DEBUGCOMBAT DoDebuffStuff: Target is a PC or Pet of a PC. Skipping.
                /continue
            }
            /varset DebuffTargetID ${Me.XTarget[${j}].ID}
            DEBUGCOMBAT DoDebuffStuff Target: ${DebuffTargetID}=${Target.ID} DebuffAllOn: ${DebuffAllOn} J: ${j}
            /if (${MeleeOn} && ${Me.Combat} && (!${IAmMA} || ${DebuffTargetID}!=${Target.ID})) {
                /attack off
                /delay 10 !${Me.Combat}
                /varset WasAttacking 1
            }
            | ****************  For Spells  *****************************
            /if (${DebuffAllOn}==2 && !${BurnCalled}) {
                /call DebuffCast "${DebuffTargetID}" 1
            } else {
                /call DebuffCast "${DebuffTargetID}" 0
            }
            DEBUGCOMBAT DoDebuffStuff 4.0
            | Reset values if 3rd value in dps for All
            | ************ Next Mob ***************
        /next j
        /varset DebuffTargetID ${MyTargetID}
        /if (${Target.ID}!=${MyTargetID}) {
            /if (${Spawn[${MyTargetID}].Type.NotEqual[Corpse]}) {
                /target id ${MyTargetID}
                /delay 1s ${Target.ID}==${MyTargetID}
                /if (${WasAttacking}) /squelch /attack on
            }
        }
        DEBUGCOMBAT DoDebuffStuff: Leave
    /return
|--------------------------------------------------------------------------------
| SUB: DebuffCast
| -------------------------------------------------------------------------------------
    Sub DebuffCast(int DebuffTargetID, int FWait)
        /declare ActionReady     int      local 0
        /declare c               int      local 0
        /declare CastCount       int      local 0
        /declare CastRange       int      local 0
        /declare DebuffText      string   local
        /declare echoTimer1      timer    local 0
        /declare echoTimer2      timer    local 0
        /declare echoTimer3      timer    local 0
        /declare f               int      local 0
        /declare g               int      local 0
        /declare i               int      local 0
        /declare MezCheckFlag    int      local 0
        /declare Tag1            string   local
        /declare Tag2            string   local
        /declare TempTimer       timer    local 0
        /declare WaitTimerDC     timer    local 0
        | ****************  For Spells  *****************************
        DEBUGCOMBAT DebuffCast Enter.
        | g  - is control variable for remaining in loop while checking for mobs to debuff and spell is ready to cast.
        | c  - is to tell if the current mob is NOT on the Debuffed List or the debufftimer has runout. c=1 mob needs debuff, c=0 Mob can be skipped
        | f  - is a flag that is changed if we find a mob to debuff, but the current Spell or AA is not ready for casting, f=1 Spells/AA's were ready, f=0 Spell/AA not ready.
        | i  - is the index of the debuff to cast.
        | !${c} This mob has all debuffs, !${f} There is a debuff that was not ready for this mob.
        /while (1) {
            /varset TempTimer 70
            /varset g 1
            /while (${g} && ${TempTimer}) {
                /varset c 0
                /varset f 1
                /if (${i}==${DebuffCount}) {
                    | We should wait for spell ready. Debuffing is more important.
                    /if (${FWait}) {
                        /varset i 0
                        | We have tried every debuff even after waiting, so we need to leave.
                        /if (${CastCount}>=${DebuffCount}) /varset f 0
                    } else {
                        | We checked every debuff, and I am not waiting any longer. DPS is more important
                        /varset f 0
                    }
                }
                /while (${f} && ${i}<${DebuffCount}) {
                    /varset ActionReady 0
                    /varcalc i ${i}+1
                    /varset DebuffText ${DPS[${i}].Arg[1,|]}
                    /if (${Int[${Spell[${DebuffText}].Range}]}>=${Int[${Spell[${DebuffText}].AERange}]}) {
                        /varset CastRange ${Spell[${DebuffText}].Range}
                    } else {
                        /varset CastRange ${Spell[${DebuffText}].AERange}
                    }
                    DEBUGCOMBAT ${DebuffText} ${DPS[${i}].Length} ${DebuffText.NotEqual[null]} ${DBOList${i}.Find[|${DebuffTargetID}]} ${DBOTimer${i}} ${i} ${DebuffCount} ${TempTimer}
                    |If mob not on list or debuff timer expired then increment counter of mobs needing debuff.
                    /if (${DPS[${i}].Length} && ${DebuffText.NotEqual[null]} && (!${DBOList${i}.Find[|${DebuffTargetID}]} || ${DBOTimer${i}}==0)) {
                        /varset c 1
                        | is spell or AA ready to cast? If ready set flag to drop out of loop.
                        /if (${Select[TRUE,${Me.SpellReady[${DebuffText}]},${Me.AltAbilityReady[${DebuffText}]},${Me.ItemReady[=${DebuffText}]}]}) {
                            /varset f 0
                        } else {
                            /if (${FWait}) {
                                /varset ActionReady ${Select[TRUE,${Bool[${Me.Book[${DebuffText}]}]},${Bool[${Me.AltAbility[${DebuffText}]}]},${Bool[${FindItem[=${DebuffText}].ID}]}]}
                                | This is a spell.
                                /if (${ActionReady}==1) {
                                    /if (${Me.SpellInCooldown}) {
                                        /if (${Int[${Me.Gem[${DebuffText}]}]}) {
                                            /if (!${Me.GemTimer[${DebuffText}]}) {
                                                /varset f 0
                                                /break
                                            }
                                        }
                                    } else /if (${Int[${Me.Gem[${DebuffText}]}]} && ${Me.GemTimer[${DebuffText}]} && !${echoTimer1}) {
                                        /echo Waiting on Spell: ${DebuffText} to Refresh. Time Remaining: ${Me.GemTimer[${DebuffText}].TotalSeconds} Seconds.
                                        /varset echoTimer1 ${Me.GemTimer[${DebuffText}]}
                                        /if (${Me.GemTimer[${DebuffText}]}<36) {
                                            /varset f 0
                                            /varset WaitTimerDC ${Me.GemTimer[${DebuffText}]}
                                            /break
                                        }
                                    }
                                | This is an AltAbility
                                } else /if (${ActionReady}==2) {
                                    /if (${Math.Calc[${Me.AltAbilityTimer[${DebuffText}].TotalSeconds}*10]}<=${TempTimer}) {
                                        /if (!${echoTimer2}) {
                                            /echo Waiting on AltAbility To Cast ${DebuffText}
                                            /varset echoTimer2 ${TempTimer}
                                        }
                                        /if (${Math.Calc[${Me.AltAbilityTimer[${DebuffText}].TotalSeconds}*10]}<36) {
                                            /varset f 0
                                            /varset WaitTimerDC ${Math.Calc[${Me.AltAbilityTimer[${DebuffText}].TotalSeconds}*10]}
                                            /break
                                        }
                                    } else {
                                        /echo Skipping AltAbility. Wait time is to long for ${DebuffText}
                                        /if (${DBOTimer${i}}==0) /varcalc DBOTimer${i} ${Me.AltAbilityTimer[${DebuffText}].TotalSeconds}*10
                                    }
                                | This is an Item
                                } else /if (${ActionReady}==3) {
                                    /if (${Math.Calc[${FindItem[=${DebuffText}].TimerReady}*10]}<=${TempTimer}) {
                                        /if (!${echoTimer3}) {
                                            /echo Waiting on Item To Cast ${DebuffText}
                                            /varset echoTimer3 ${TempTimer}
                                        }
                                        /if (${Math.Calc[${FindItem[=${DebuffText}].TimerReady}*10]}<36) {
                                            /varset f 0
                                            /varset WaitTimerDC ${Math.Calc[${FindItem[=${DebuffText}].TimerReady}*10]}
                                            /break
                                        }
                                    } else {
                                        /echo Skipping Item. Wait time is to long for ${DebuffText}
                                        /if (${DBOTimer${i}}==0) /varcalc DBOTimer${i} ${FindItem[=${DebuffText}].TimerReady}*10
                                    }
                                }
                            }
                            /if (${HealsOn}) {
                                /if (!${LastHealCheck}) {
                                    /call CheckHealth DebuffCast1
                                    /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
                                }
                            }
                        }
                    }
                }
                DEBUGCOMBAT ${c} ${f} ${FWait}
                /if (!${c} || !${f} || (${f} && !${FWait})) /varset g 0
            }
            DEBUGCOMBAT DebuffCast 0 DebuffTargetID: ${DebuffTargetID} ${i} C: ${c} F: ${f} FWait: ${FWait}
            /if (${MezOn}) /varset MezBroke 0
            /varset GoMByPass 1
            /doevents
            /varset GoMByPass 0
            /if (${HealsOn}) {
                /if (!${LastHealCheck}) {
                    /call CheckHealth DebuffCast1
                    /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
                }
            }
            /if (${DPSPaused}) {
                DEBUGCOMBAT DebuffCast: Return from DebuffCast cause DPSPaused is ${DPSPaused}
                /return
            }
            /if (!${c} || ${g} || (${f} && !${FWait})) {
                DEBUGCOMBAT DebuffCast Exit.
                /return
            }
            DEBUGCOMBAT DebuffCast 1 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}}
            /if (${GroupEscapeOn} && ${Select[${Me.Class.ShortName},WIZ,DRU]} && (${Raid.Members}==0)) /call GroupEscape
            /if (${MezOn} && !${MezBroke}) {
                /call DoMezStuff DebuffCast
                /varset MezCheckFlag 1
            }
            /varset TempTimer 0
            /varset Tag1 ${DPS[${i}].Arg[4,|]}
            /varset Tag2 ${DPS[${i}].Arg[5,|]}
            /if (${Tag1.Equal[always]}) /varset Tag2 always
            | Test -> Do i have enough mana to cast the spell
            /if (${Me.CurrentMana}<${Spell[${DebuffText}].Mana}) {
                DEBUGCOMBAT DebuffCast: i didnt have enough mana to cast ${DebuffText} so im going to Skip Cast
                /varcalc CastCount ${CastCount}+1
                /continue
            }
            /if (${Spawn[${DebuffTargetID}].Type.Equal[Corpse]} || ${Int[${Spawn[${DebuffTargetID}].ID}]}==0) /return
            /if (${Target.ID}!=${DebuffTargetID}) {
                /squelch /target clear
                /delay 10 !${Target.ID}
                /squelch /target id ${DebuffTargetID}
                /delay 20 ${Target.ID}==${DebuffTargetID} && ${Target.BuffsPopulated}
            }
            DEBUGCOMBAT DebuffCast: Debuff: ${DebuffText} TargetID: ${Target.ID} DebuffTargetID: ${DebuffTargetID} : ${Target.Buff[${DebuffText}].ID} ${Target.Buff[${DebuffText}].Caster} ${Me.SpellInCooldown} ${Tag1} ${Tag2} ${Target.BuffsPopulated}
            /while (1) {
                | Check Target for Buffs
                /if (${Target.BuffCount}) {
                    | Does the Target have the debuff I am about to cast
                    /if (${Target.Buff[${DebuffText}].ID}) {
                        /if (${Target.Buff[${DebuffText}].Caster.Equal[${Me.CleanName}]} || (${Target.Buff[${DebuffText}].Caster.NotEqual[${Me.CleanName}]} && ${Tag2.NotEqual[always]})) {
                            /varcalc TempTimer ${Target.BuffDuration[${DebuffText}].TotalSeconds}*10
                        }
                    }
                    | If timer didn't get set above then check this
                    /if (${TempTimer}==0) {
                        | Does the mob have one of the following debuffs if so lets skip casting
                        /if (${Tag1.Equal[strip]} && (${Int[${Target.Beneficial.ID}]}==0 || ${Select[${Int[${Target.Beneficial.ID}]},38728,38727,10080]})) {
                            /varset TempTimer 70
                        } else /if (${Tag2.NotEqual[always]}) {
                            /if (${Tag1.Equal[slow]} && ${Target.Slowed.ID}) {
                                |/if (${Target.Slowed.SlowPct}>=${Spell[${DebuffText}].SlowPct}) { 
                                |    /varcalc TempTimer ${Target.BuffDuration[${Target.Slowed.Name}].TotalSeconds}*10
                                |}
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Slowed.Name}].TotalSeconds}*10
                            } else /if (${Tag1.Equal[tash]} && ${Target.Tashed.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Tashed.Name}].TotalSeconds}*10
                            } else /if (${Tag1.Equal[malo]} && ${Target.Maloed.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Maloed.Name}].TotalSeconds}*10
                            } else /if (${Tag1.Equal[crip]} && ${Target.Crippled.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Crippled.Name}].TotalSeconds}*10
                            } else /if (${Tag1.Equal[snare]} && ${Target.Snared.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Snared.Name}].TotalSeconds}*10
                            } else /if (${Tag1.Equal[root]} && ${Target.Rooted.ID}) {
                                /varcalc TempTimer ${Target.BuffDuration[${Target.Rooted.Name}].TotalSeconds}*10
                            }
                        }
                    }
                    /if (${TempTimer}) {
                        /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                        /break
                    }
                    DEBUGCOMBAT DebuffCast: DebuffTargetID: ${DebuffTargetID} Slowed: ${Target.Slowed.ID} Tashed: ${Target.Tashed.ID} Maloed: ${Target.Maloed.ID} Crippled: ${Target.Crippled.ID} Tag1: ${Tag1} Tag2: ${Tag2} TempTimer: ${TempTimer}
                }
                /if (${HealsOn}) {
                    /if (!${LastHealCheck}) {
                        /call CheckHealth DebuffCast3
                        /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
                        /if (${Target.ID}!=${DebuffTargetID}) {
                            /if (${Spawn[${DebuffTargetID}].Type.Equal[Corpse]} || ${Int[${Spawn[${DebuffTargetID}].ID}]}==0) /return
                            /squelch /target clear
                            /delay 10 !${Target.ID}
                            /squelch /target id ${DebuffTargetID}
                            /delay 10 ${Target.BuffsPopulated}
                        }
                    }
                }
                | When you get here you won't want to cast Eradicate Magic if the mob has NO Beneficial Buffs
                /if (${Tag1.Equal[strip]} && ${Int[${Target.Beneficial.ID}]}==0) {
                    /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                    /varset TempTimer 70
                    /break
                }
                | Wait here for a sec, your spell bar may still be in global cool down.
                /if (${Me.SpellInCooldown} || ${WaitTimerDC}) {
                    /delay 5
                }
                | Conditional Check Added.
                /if (${ConOn} && ${DPS[${i}].Find[|cond]} && ${If[${Cond[${DPS[${i}].Mid[${Math.Calc[${DPS[${i}].Find[|cond]}+5]},3]}]},0,1]}) /break
                | Everything is ready, lets debuff this mob
                /call CastWhat "${DebuffText}" ${DebuffTargetID} DebuffCast 0 0
                DEBUGCOMBAT DebuffCast: Return From CastWhat: ${Macro.Return}
                /if (${Macro.Return.Equal[CAST_RESISTED]}) {
                    /echo ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - RESISTED
                } else /if (${Macro.Return.Equal[CAST_TAKEHOLD]}) {
                    /echo ** ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << - DID NOT TAKE HOLD
                    /varset TempTimer 3m
                } else /if (${Macro.Return.Equal[CAST_IMMUNE]}) {
                    /echo ** ${Spawn[${DebuffTargetID}].CleanName} is IMMUNE to - ${DebuffText}
                    /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                    /varset TempTimer 3m
                } else /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /echo ** Debuffing: ==> ${DebuffText} on >> ${Spawn[${DebuffTargetID}].CleanName} << DebuffTargetID: ${DebuffTargetID} Target: ${Target.ID} DBOList: ${DBOList${i}}
                    /if (!${DBOList${i}.Find[|${DebuffTargetID}]}) /varset DBOList${i} ${DBOList${i}}|${DebuffTargetID}
                    | Timers for items
                    /if (${FindItemCount[=${DebuffText}]}) {
                        /varcalc TempTimer ${FindItem[=${DebuffText}].Spell.Duration.TotalSeconds}*10
                        | Timers for AltAbilities
                    } else /if (${Me.AltAbility[${DebuffText}]}) {
                        /if (${Me.AltAbility[${DebuffText}].Spell.Duration.TotalSeconds}) {
                            /varcalc TempTimer ${Me.AltAbility[${DebuffText}].Spell.Duration.TotalSeconds}*10
                        } else /if (${Me.AltAbility[${DebuffText}].Spell.Trigger.Duration.TotalSeconds}) {
                            /varcalc TempTimer ${Me.AltAbility[${DebuffText}].Spell.Trigger.Duration.TotalSeconds}*10
                        }
                        | Timers for spells
                    } else /if (${Me.Book[${DebuffText}]}) {
                        | - Custom timer for counterbias
                        /if (${Me.Class.Name.Equal[Shaman]} && ${DebuffText.Find[counterbias]}) {
                            /varset TempTimer 1.5m
                            | Custom timer for Chanter suffocation
                        } else /if (${Me.Class.Name.Equal[enchanter]} && ${DebuffText.Find[suffocation]}) {
                            /varset TempTimer 1m
                            | Custom timer for Beastlord Feralgia Timer
                        } else /if (${Me.Class.Name.Equal[Beastlord]} && ${DebuffText.Find[feralgia]}) {
                            /varset TempTimer 1.5m
                            | Regular spells
                        } else /if (${Spell[${DebuffText}].Duration}>0) {
                            /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                            | Spells with no timers assign DPS interval
                        } else {
                            /varset TempTimer ${DPSInterval}s
                        }
                        | AA and disc timers
                    } else /if (${Spell[${DebuffText}].Duration}>0) {
                        /varcalc TempTimer ${Spell[${DebuffText}].Duration.TotalSeconds}*10
                        | AA and disc with no timers assign DPS interval
                    } else {
                        /varset TempTimer ${DPSInterval}s
                    }
                }
                /if (${MezOn} && !${MezCheckFlag} && ${Me.XTarget[${XTSlot2}].ID}) {
                    /call DoMezStuff DebuffCast
                    /varset MezCheckFlag 1
                }
                /break
            }
            | Check Debuff Timer not set and the Temp Timer has been set.
            | You only want to set the DBOTimer for the first mob you get the Debuff to land on. Don't need a timer for every mob.
            /if (!${DBOTimer${i}} && ${TempTimer}) {
                /varcalc DBOTimer${i} ${TempTimer}*.95
            }
            | ************ Next Spell ***********
            /varcalc CastCount ${CastCount}+1
            DEBUGCOMBAT DebuffCast 2 DebuffTargetID: ${DebuffTargetID} ${i} Find: ${DBOList${i}.Find[|${DebuffTargetID}]} Timer: ${DBOTimer${i}} List: ${DBOList${i}} ${CastCount}
        }
        DEBUGCOMBAT DebuffCast leave.
    /return
| -------------------------------------------------------------------------------------
| SUB: Event MezCheck
| -------------------------------------------------------------------------------------
    Sub MezCheck(sentFrom)
        DEBUGMEZ MezCheck Enter - ${sentFrom} ${MyTargetID}
        /varset EventByPass 1
        /varset MezBroke 0
        /while (1) {
            /varset EventFlag 0
            /doevents MezBroke
            /if (!${EventFlag}) /break
        }
        /varset EventByPass 0
        /varset GoMByPass 1
        /call CombatTargetCheck 1
        /call DoMezStuff MezCheck
        /varset GoMByPass 0
        DEBUGMEZ MezCheck Leave - ${MyTargetID}
    /return    
| -------------------------------------------------------------------------------------
| SUB: Event MezBroke
| -------------------------------------------------------------------------------------
    Sub Event_MezBroke1(meztext,mezmob,mezbreaker)
        /declare i int local
        /varset EventFlag 1
        DEBUGMEZ event mezbroke Enter - ${mezmob} ${mezbreaker} ${MyTargetID}
        /if (!${MezOn}) /return
        | Get out of here. DoMezStuff triggered this call after being called from here. See Below.
        /if (${EventByPass}==2) /return
        /if (${Spawn[${mezbreaker}].CleanName.Equal[${MainAssist}]}) {
            /if (${MainAssist.Equal[${Me}]}) /return
            /assist ${MainAssist}
            /delay 1s ${Me.AssistComplete}==TRUE
            /if (${Target.ID}!=${MyTargetID}) {
                /varset MyTargetID ${Target.ID}
                /varset MyTargetName ${Target.CleanName}
            } else {
                /call BroadCast g ">> MainAssist - ${Spawn[=${mezbreaker}].CleanName} << has awakened -> ${mezmob}<- ${MyTargetName}"
                /for i 1 to 30
                    DEBUGMEZ ${MezArray[${i},3]} - ${MezArray[${i},1]} - ${MezArray[${i},2]}
                    /if (${MezArray[${i},3].Equal[${mezmob}]} && ${MezArray[${i},1].NotEqual[null]} && ${MezArray[${i},2]}!=${MyTargetID}) {
                        /echo Resetting Mez Timer ${mezmob} ID: ${MezArray[${i},1]}
                        /varset MezTimer${i} 0
                    }
                /next i
            }
            /if (${XTarAutoSet} && !${Group.Member[${MainAssist}].Index} && !${IAmMA} && ${Me.XTarget[${XTSlot}].ID}!=${Target.ID} && ${Target.Type.NotEqual[PC]}) /xtarget set ${XTSlot} currenttarget
            /return
        }
        /if (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[${MainAssist}].Master.CleanName.Equal[${mezbreaker}]}) /return
        /call BroadCast g ">> ${Spawn[=${mezbreaker}].CleanName} << has awakened -> ${mezmob}<-"
        /for i 1 to 30
            DEBUGMEZ ${MezArray[${i},3]} - ${MezArray[${i},1]}
            /if (${MezArray[${i},3].Equal[${mezmob}]} && ${MezArray[${i},1].NotEqual[null]}) {
                /echo Resetting Mez Timer ${mezmob} ID: ${MezArray[${i},1]}
                /varset MezTimer${i} 0
            }
        /next i
        /doevents flush MezBroke
        /varset EventFlag 0
        | Get Out of here and return back to DoMezStuff. This event was triggered by DoMezStuff.
        /if (${EventByPass}==1) /return
        /varset GoMByPass 1
        /varset EventByPass 2
        /call CombatTargetCheck 1
        /call DoMezStuff Event_MezBroke
        /varset EventByPass 0
        /varset GoMByPass 0
        | Set MezOn = 2 to let us know that the event was triggered. Will be set back to 1 in other location
        /varset MezBroke 1
        DEBUGMEZ event mezbroke Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Event MezBroke
| -------------------------------------------------------------------------------------
    Sub Event_MezBroke(meztext,mezmob,mezbreaker)
        /declare i int local
        /varset EventFlag 1
        DEBUGMEZ event mezbroke Enter - ${mezmob} ${mezbreaker} ${MyTargetID}
        /if (!${MezOn}) /return
        | Get out of here. DoMezStuff triggered this call after being called from here. See Below.
        /if (${EventByPass}==2) /return
        /if (${Spawn[${mezbreaker}].CleanName.Equal[${MainAssist}]}) {
            /if (${MainAssist.Equal[${Me}]}) /return
            /assist ${MainAssist}
            /delay 1s ${Me.AssistComplete}==TRUE
            /if (${Target.ID}!=${MyTargetID}) {
                /varset MyTargetID ${Target.ID}
                /varset MyTargetName ${Target.CleanName}
            } else {
                /call BroadCast g ">> MainAssist - ${Spawn[=${mezbreaker}].CleanName} << has awakened -> ${mezmob}<- ${MyTargetName}"
                /for i 1 to 30
                    DEBUGMEZ ${MezArray[${i},3]} - ${MezArray[${i},1]} - ${MezArray[${i},2]}
                    /if (${MezArray[${i},3].Equal[${mezmob}]} && ${MezArray[${i},1].NotEqual[null]} && ${MezArray[${i},1]}!=${MyTargetID}) {
                        /echo Resetting Mez Timer-1${mezmob} ID: ${MezArray[${i},1]} - ${MyTargetID}
                        /varset MezTimer${i} 0
                        /varset MezBroke 1
                    }
                /next i
            }
            /if (${XTarAutoSet} && !${Group.Member[${MainAssist}].Index} && !${IAmMA} && ${Me.XTarget[${XTSlot}].ID}!=${Target.ID} && ${Target.Type.NotEqual[PC]}) /xtarget set ${XTSlot} currenttarget
            /return
        }
        /if (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[${MainAssist}].Master.CleanName.Equal[${mezbreaker}]}) /return
        /call BroadCast g ">> ${Spawn[=${mezbreaker}].CleanName} << has awakened -> ${mezmob}<-"
        /for i 1 to 30
            DEBUGMEZ ${MezArray[${i},3]} - ${MezArray[${i},1]}
            /if (${MezArray[${i},3].Equal[${mezmob}]} && ${MezArray[${i},1].NotEqual[null]} && ${MezArray[${i},1]}!=${MyTargetID}) {
                /echo Resetting Mez Timer-2 ${mezmob} ID: ${MezArray[${i},1]} - ${MyTargetID}
                /varset MezTimer${i} 0
                /varset MezBroke 1
            }
        /next i
        | Get Out of here and return back to DoMezStuff. This event was triggered by DoMezStuff.
        /if (${EventByPass}==1) /return
        /varset GoMByPass 1
        /varset EventByPass 2
        /call CombatTargetCheck 1
        /call DoMezStuff Event_MezBroke
        /varset EventByPass 0
        /varset GoMByPass 0
        | Set MezOn = 2 to let us know that the event was triggered. Will be set back to 1 in other location
        DEBUGMEZ event mezbroke Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Event MezImmune
| -------------------------------------------------------------------------------------
    Sub Event_MezImmune(int MezID)
        /varset EventFlag 1
        /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
        | Assign temp var MezImmune list
        /declare ImmuneAdd string local ${MezImmune}
        | If mezimmune default text with the word null in it assign var spawn clean name
        /if (${ImmuneAdd.Find[null]}) {
            /varset ImmuneAdd ${Spawn[${MezID}].CleanName}
        } else {
            /varset ImmuneAdd ${ImmuneAdd},${Spawn[${MezID}].CleanName}
        }
        /if (!${MezImmune.Find[${Spawn[${MezID}].CleanName}]}) /ini "${InfoFileName}" "${Zone}${If[${Me.InInstance},_I,]}" "MezImmune" "${ImmuneAdd}"
        /call BroadCast g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Adding to MezImmune list."
        | Reassign mezimmune var the new list
        /varset MezImmune ${ImmuneAdd}
    /return
| -------------------------------------------------------------------------------------
| SUB: AddMezImmune
| -------------------------------------------------------------------------------------
    Sub AddMezImmune(int MezID)
        /if (${Select[${Me.Class.ShortName},Brd,Enc,Nec]}==0) /return
        /if (${MezImmuneIDs.Find[|${MezID}]}) /return
        /varset MezImmuneIDs ${MezImmuneIDs}|${MezID}
        /call BroadCast g "MEZ Immune -> ${Spawn[${MezID}].CleanName} <- ID:${MezID} Skipping."
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind AddMezImmune
| -------------------------------------------------------------------------------------
    Sub Bind_AddMezImmune(MTImmune)
        /if (!${MTImmune.Length} || ${MTImmune.Find[null]} || ${Spawn[${MTImmune}].ID}==${Me.ID} ) {
            /echo No NPCs detected. Nothing added to list.
            /return
        }
        | Assign temp var MezImmune list
        /declare MezImmuneAdd string local ${MezImmune}
        /declare NameToUse string local
        /declare s_SpawnName string local ${Spawn[${MTImmune}].CleanName}
        /if (${s_SpawnName.Equal[null]}) {
            /echo ERROR: No Mob with ${MTImmune} in Name detected.
            /return
        }
        | If MobsToPull default text with the word null in it assign var spawn clean name
        /if (${Spawn[${MTImmune}].Name.Find[#]}) {
            /varset NameToUse #${s_SpawnName}
        } else /if (${s_SpawnName.Right[-10].Find[corpse]}) {
            /varset NameToUse ${s_SpawnName.Right[-8]}
        } else {
            /varset NameToUse ${s_SpawnName}
        }
        | If mob is on the list no need to add it again.
        /if (${MezImmune.Find[${NameToUse}]}) {
            /echo >> ${NameToUse} << already on Mez Immune List.
            /return
        }
        | If MezImmune default text with the word null in it assign var spawn clean name
        /if (${MezImmuneAdd.Find[null]} && ${MezImmune.Find[null]}) {
            /varset MezImmuneAdd ${NameToUse}
        } else {
            /varset MezImmuneAdd ${MezImmune},${NameToUse}
        }
        /ini "${InfoFileName}" "${ZoneName}" "MezImmune" "${MezImmuneAdd}"
        /echo MezImmune -> ${NameToUse} <- Adding to Mez Immune list.
        | Reassign MezImmune var the new list
        /varset MezImmune ${MezImmuneAdd}
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind AddToIgnore
| -------------------------------------------------------------------------------------
    Sub Bind_AddToIgnore(MTIgnore, int byID)
        | Take the targeted mob as a parameter for mob to ignore.
        /if (!${Defined[MTIgnore]}) /declare MTIgnore string local null
        /if (${MTIgnore.Equal[null]} || ${MTIgnore.Length}==0) /varset MTIgnore ${Target.CleanName}
        /if (!${byID}) {
            /if (${MTIgnore.Equal[null]} || ${Spawn[${MTIgnore}].Type.NotEqual[NPC]} || ${Spawn[${MTIgnore}].CleanName.Equal[null]}) {
                /echo No NPCs named (${MTIgnore}) detected. Nothing added to list. ${byID}
                /return
            }
            | Assign temp var   list
            /declare IgnoreAdd string local ${MobsToIgnore}
            /declare NameToUse string local
            /declare s_SpawnName string local ${Spawn[${MTIgnore}].CleanName}
            /if (${Spawn[${MTIgnore}].Name.Find[#]}) {
                /varset NameToUse #${s_SpawnName}
            } else /if (${s_SpawnName.Right[-10].Find[corpse]}) {
                /varset NameToUse ${s_SpawnName.Right[-8]}
            } else {
                /varset NameToUse ${s_SpawnName}
            }
            | If mob is on the list no need to add it again.
            /if (${MobsToIgnore.Find[${NameToUse}]}) {
                /echo >> ${NameToUse} << already on Ignore List.
                /return
            }
            | If MobsToIgnore default text with the word null in it assign var spawn clean name
            /if (${IgnoreAdd.Find[null]}) {
                /varset IgnoreAdd ${NameToUse}
            } else {
                /varset IgnoreAdd ${IgnoreAdd},${NameToUse}
            }
            | Remove's corpse if closest match is a mob corpse
            /ini "${InfoFileName}" "${ZoneName}" "MobsToIgnore" "${IgnoreAdd}"
            /echo AddToIgnore -> ${NameToUse} <- Adding to Ignore list.
            | Reassign MobsToIgnore var the new list
            /varset MobsToIgnore ${IgnoreAdd}
        } else {
            /if (${MTIgnore.Equal[null]} || ${Spawn[id ${MTIgnore}].Type.NotEqual[NPC]} || ${Spawn[id ${MTIgnore}].CleanName.Equal[null]}) {
                /echo No NPCs with ID: (${MTIgnore}) detected. Nothing added to list. ${byID}
                /return
            }
            /if (${Int[${MTIgnore}]}>0 && !${MobsToIgnoreByID.Find[${MTIgnore}|]}) {
                /varset MobsToIgnoreByID ${MTIgnore}|${MobsToIgnoreByID}
            }
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind AddToPull
| -------------------------------------------------------------------------------------
    Sub Bind_AddToPull(MTPull)
        /if (!${MTPull.Length} || ${MTPull.Find[null]} || ${Spawn[${MTPull}].ID}==${Me.ID}) {
            /echo No NPCs detected. Nothing added to list.
            /return
        }
        | Assign temp var MobsToPull list
        /declare PullAdd string local ${MobsToPull}
        /declare NameToUse string local
        /declare s_SpawnName string local ${Spawn[${MTPull}].CleanName}
        /if (${s_SpawnName.Equal[null]}) {
            /echo ERROR: No Mob with ${MTPull} in Name detected.
            /return
        }
        | If MobsToPull default text with the word null in it assign var spawn clean name
        /if (${Spawn[${MTPull}].Name.Find[#]}) {
            /varset NameToUse #${s_SpawnName}
        } else /if (${s_SpawnName.Right[-10].Find[corpse]}) {
            /varset NameToUse ${s_SpawnName.Right[-8]}
        } else {
            /varset NameToUse ${s_SpawnName}
        }
        | If mob is on the list no need to add it again.
        /if (${MobsToPull.Find[${NameToUse}]}) {
            /echo >> ${NameToUse} << already on Pull List.
            /return
        }
        /if (${PullAdd.Find[all]}) {
            /varset PullAdd ${NameToUse}
        } else {
            /varset PullAdd ${PullAdd},${NameToUse}
        }
        /ini "${InfoFileName}" "${ZoneName}" "MobsToPull" "${PullAdd}"
        /echo AddToPull-> ${NameToUse} <- Adding to Pull list.
        | Reassign MobsToPull var the new list
        /varset MobsToPull ${PullAdd}
    /return
| ----------------------------------------------------------------------------
| SUB: Add a friend to mq2posse list
| ----------------------------------------------------------------------------
    Sub Bind_AddAFriend
        /declare AFriend string local ${Target.CleanName}
        /if (!${Target.ID} || ${Spawn[${Target.ID}].Type.NotEqual[pc]} || ${Target.ID}==${Me.ID}) {
            /echo --ADDFRIEND: Target a PC to add your Posse list.
            /return
        }
        /docommand /posse add ${AFriend}
        /docommand /posse save
        /docommand /posse load
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind_ToggleVariable  Check whenever the player is changing any variable via /echo
| -------------------------------------------------------------------------------------
    Sub Bind_ToggleVariable(string Command, string Command2, string Command3)
        DEBUGN ${Command} ${Defined[${Command}]} ${Command2} ${Command3}
        /declare i int local
        /declare OnOff local
        | Toggle Variables & Set Variables
        /if (${Defined[${Command}]}) {
            DEBUGN ${Command}:${${Command}} ${Defined[${Command}]} ${Command2} ${Command3}
            /if (${Select[${Command2},0,1,on,off]}) {
                /if (${Select[${Command2},0,off]}) {
                    /varset ${Command} 0
                    /varset OnOff Off
                    DEBUGN ${OnOff} 1
                } else /if (${Select[${Command2},1,on]}) {
                    /varset ${Command} 1
                    /varset OnOff On
                    DEBUGN ${OnOff} 2
                }
            } else /if (${${Command}}) {
                /varset ${Command} 0
                /varset OnOff Off
                DEBUGN ${OnOff} 3
                /if (!${ChaseAssist} && ${Stick.Active}) /squelch /stick off
            } else {
                /varset ${Command} 1
                /varset OnOff On
                DEBUGN ${OnOff} 4
            }
            /if (${Command.Equal[ChaseAssist]}) {
                /if (${OnOff.Equal[on]}) {
                    /if (${Command3.NotEqual[null]} && ${Command3.Length}>0 && ${WhoToChase.NotEqual[${Command3}]}) {
                        /varset WhoToChase ${Command3}
                        /echo I Will Now Chase ${WhoToChase}
                    }
                    /if (${ReturnToCamp}) /varset ReturnToCamp 0
                    /if (${Me.Pet.ID} && ${Me.Pet.Stance.NotEqual[follow]}) /pet follow
                } else {
                    /if (${Stick.Active}) /squelch /stick off
                }
            | Turn on return to camp & set new y,x coord
            } else /if (${Command.Equal[ReturnToCamp]} && ${OnOff.Equal[on]}) {
                /varset CampXLoc ${Me.X}
                /varset CampYLoc ${Me.Y}
                /varset CampZLoc ${Me.FloorZ}
                /varset LookForward ${Me.Heading.DegreesCCW}
                | Turn off ChaseAssist if on
                /if (${ChaseAssist}) {
                    /varset ChaseAssist 0
                    /ini "${IniFileName}" "General" "ChaseAssist" "0"
                    /if (${Stick.Active}) /squelch /stick off
                    /echo >> ChaseAssist Off
                }
                /if (${CampZone}!=${Zone.ID}) /varset CampZone ${Zone.ID}
                /echo >> New camp set ${Me.Y}, ${Me.X}
            } else /if (${Command.Equal[AutoRezAll]}) {
                /if (${OnOff.Equal[off]}) {
                    /varset CorpseRezCheck null
                    /echo No longer Rezing Everyone.
                } else {
                    /echo Now Rezing Everyone.
                }
            } else /if (${Command.Equal[dpsmeter]}) {
                /if (${DPSMeter}) {
                    /call CheckPlugin MQ2DPSAdv 1
                    /if (!${Macro.IsTLO[DPSAdv]}) {
                        /echo DPSAdv TLO not found. Turning off DPS meter. 
                        /varset DPSMeter 0
                    }
                }
            } else /if (${Command.Equal[looton]}) {
                /if (${OnOff.Equal[off]}) {
                    /if (${Defined[NALStatus]}) {
                        /varset NALStatus 0
                    }
                } else {
                    /if (${Defined[NALStatus]}) {
                        /varset NALStatus 1
                    }
                }
            } else /if (${Command.Equal[targetswitchingon]}) {
                /if (${OnOff.Equal[on]}) {
                    /if (!${IAmMA}) {
                        /varset ${Command} 0
                        /varset OnOff off
                    } 
                }
            }
            DEBUGN ${Command} ${Command2} ${Command3}
            /echo >> Setting: (${Command}) to (${If[${Select[${OnOff},on,1]}>0,On,Off]})
        } else /if (${Command.Equal[waithere]}) {
            /varset ChaseAssist 0
            /varset ReturnToCamp 0
            /if (${Stick.Active}) /squelch /stick off
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: DoMiscStuff
| -------------------------------------------------------------------------------------
    Sub DoMiscStuff
        /if (!${ChainPull} && (${CombatStart} || ${AggroTargetID})) /return
        DEBUGN DoMiscStuff Enter
        | Accept trades
        /if (${Window[TradeWnd].Open} && ${Window[TradeWnd].HisTradeReady} && !${Cursor.ID}) /notify TradeWnd TRDW_Trade_Button leftmouseup
        | Accept group invite
        /if (${Window[GroupWindow].Child[GW_FollowButton]} && ${AcceptInvitesOn}) /invite
        | Ditch wizards familiar
        /if (${Me.Pet.CleanName.Equal[${Me.Name}`s familiar]} && ${Me.Class.ShortName.Equal[Wiz]}) /pet get lost
        | Drop random items on cursor like drive by mod rods into inventory after 30s min
        /if (${Cursor.ID}) /call CheckCursor DoMiscStuff 0
        | Paint the radius's on the map.
        /if (!${MapSet}) {
            /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
                /call PullRangeSet
                /call PaintMap
            } else {
                /varset MapSet 1
            }
        }
        /if (${PullPause.Arg[1,|].NotEqual[0]}) {
            /if (!${PullHold} && !${PullWaitTimer2}) {
               /varset PullWaitTimer1 ${PullPause.Arg[1,"|"]}m
               /varset PullWaitTimer2 ${PullPause.Arg[2,"|"]}m
            }
            /if (!${PullWaitTimer1}) {
                /if (${PullWaitRemaining} && ${PullHold}==2) /varset PullHold 0
                /if (!${PullHold}) {
                    /if (!${PullWaitRemaining}) {
                        /echo Pausing Pulls for ${PullPause.Arg[2,"|"]} Minutes.
                    } else {
                        /echo Resuming Medding after interrupt.
                    }
                    /if (${ReturnToCamp}) /call DoWeMove 1 DoMiscStuff
                    /varset PullHold 2
                    /varset PullWaitTimer1 ${PullPause.Arg[2,"|"]}m
                    /call DoWeMed 1 0 "" 100
                } else /if (${PullHold}==2) {
                    /echo Resetting Pull Timer for ${PullPause.Arg[1,"|"]} Minutes.
                    /varset PullHold 0
                    /varset PullWaitTimer1 ${PullPause.Arg[1,"|"]}m
                    /varset PullWaitTimer2 ${PullPause.Arg[2,"|"]}m
                }
            }
        }
        DEBUGN DoMiscStuff Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Can I do Stuff  - Check if invis moving ducked etc
| -------------------------------------------------------------------------------------
    Sub CanIDoStuff
        /if ((${CombatStart} || ${AggroTargetID} || ${Me.CombatState.NotEqual[COMBAT]})) /return
        DEBUGN CanIDoStuff Enter
        /declare DoLoop int local 1
        /if (${IAmDead} && ${CampZone}==${Zone.ID} && (${Me.Buff[Resurrection Sickness].ID} || ${SpawnCount[pccorpse ${Me}]}==0)) {
            /varset IAmDead 0
            /if (${IAmABard}) {
                /call CastBardCheck
                /varset Twisting 0
                /varset DPSTwisting 0
            }
        }
        | Turn off twist while invis
        /if (${Me.Invis} && ${IAmABard}) {
            /if (${Twist}) /call CastBardCheck 0
        }
        | Assign Master looter
        /if (${Select[${Me},${Group.Leader}]}==1) /call AssignLooter
        /while (${DoLoop}) {
            /while (1) {
                /varset EventFlag 0
                /doevents
                /if (!${EventFlag}) /break
            }
            /call WriteDebuffs
            /call RogueStuff
            /delay 2
            /call EndMacroIf
            /if (${Debug} && ${Me.Invis}) /echo You are invisible.
            /if (${Me.Moving} || ${Me.State.Equal[feign]} || (${ChaseAssist}==0 && ${AggroTargetID}==0 && ${Me.Invis} && ${Me.Class.Name.NotEqual[Rogue]}) || ${Me.Stunned} || ${Me.Ducking}  || (${Me.State.Equal[BIND]} && !${Window[LootWnd].Open})) /continue
            /if (${Window[MerchantWnd]} || ${Window[GiveWnd]} || ${Window[SpellBookWnd]} || ${Window[BigBankWnd]} || ${Window[BankWnd]} || ${Window[GuildBankWnd]}  || ${Window[TributeMasterWnd]} || ${Window[GuildTributeMasterWnd]}) /continue
            /varset DoLoop 0
        }
        DEBUGN CanIDoStuff Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Mercs Do What
| -------------------------------------------------------------------------------------
    Sub MercsDoWhat
        /if (!${MercOn}) /return
        /if (${Group.Member[1].Owner.Name.Equal[${Me}]}) /varset MyMerc ${Group.Member[1].Name}
        DEBUGN MercsDoWhat Enter
        /if (${Mercenary.State.Equal[Active]}) /varset MercInGroup 1
        | Revive the merc if dead and previously detected in group
        /if (${MercInGroup} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled} && ${Mercenary.State.Equal[DEAD]}) /notify MMGW_ManageWnd MMGW_SuspendButton LeftMouseUp
        /if (!${MercAssisting}) {
            /if (${MercAssistAt}>=${Spawn[${MyTargetID}].PctHPs} && ${Mercenary.State.Equal[Active]} && (${CombatStart} || ${Select[${Role},Puller]} && ${Pulled})) {
                /mercassist
                DEBUGCOMBAT MercsDoWhat1 ${Spawn[${MyTargetID}].CleanName} %:${Spawn[${MyTargetID}].PctHPs} ID:${Spawn[${MyTargetID}].ID}
                /varset MercAssisting ${MyTargetID}
            }
        } else /if (${MyTargetID} && ${MercAssisting}!=${MyTargetID}) {
            /mercassist
            DEBUGCOMBAT MercsDoWhat2 ${Spawn[${MyTargetID}].CleanName} %:${Spawn[${MyTargetID}].PctHPs} ID:${Spawn[${MyTargetID}].ID}
            /varset MercAssisting ${MyTargetID}
        } else /if (!${MyTargetID}) {
            /varset MercAssisting 0
        }
        DEBUGN MercsDoWhat Leave
    /return
| -------------------------------------------------------------------------------------
| Sub Assign Main Assist
| -------------------------------------------------------------------------------------
    Sub AssignMainAssist(string AssignTarget)
        DEBUGN AssignMainAssist Enter ${Role}
        /if (${AssignTarget}) {
            /if (${Select[${Role},pettank,pullerpettank,hunterpettank,tank,pullertank,hunter]}) {
                /target id ${Me.ID}
                /delay 10 ${Target.ID}==${Me.ID}
            } else /if (${Select[${Role},assist,offtank,puller,petassist]}) {
                /if (!${MainAssist.Length} || ${MainAssist.Equal[null]}) {
                    /if (${Target.ID}) {
                        /if (${Target.ID}==${Me.ID}) {
                            /echo Invalid Role(${Role}) for you to be the MA. Please provide a proper target and/or change your Role, and restart the macro.
                            /beep
                            /endmacro
                        } else /if (!${Select[${Target.Type},Mercenary,PC,Pet]}) {
                            /echo ERROR: You have >> ${Target.CleanName} << targeted. Please target a Mercenary, PC or Pet for Main Tank and restart the macro.
                            /beep
                            /endmacro
                        }
                    } else {
                        /echo No MainAssist Target. Please target Main Tank and restart macro.
                        /beep
                        /endmacro
                    }
                } else {
                    /if (${Spawn[=${MainAssist} pc].ID}) {
                        /tar id ${Spawn[=${MainAssist} pc].ID}
                        /delay 10 ${Target.ID}==${Spawn[=${MainAssist} pc].ID}
                    } else {
                        /echo Mainassist ${MainAssist} is no where to be found. Ending Macro.
                        /beep
                        /endmacro
                    }
                }
            } else /if (${Role.NotEqual[manual]}) {
                /echo Invalid Role: ${Role} Ending Macro.
                /beep
                /endmacro
            }
        }
        /varset MainAssist ${Target.CleanName}
        /varset MainAssistType ${Target.Type}
        /varset MainAssistClass ${Target.Class.ShortName}
        DEBUGN AssignMainAssist Leave
    /return
| -------------------------------------------------------------------------------------
| Sub Check Roles
| -------------------------------------------------------------------------------------
    Sub CheckRoles(int specialK)
        DEBUGN CheckRoles Enter
        /if (${Select[${Role},pettank,pullerpettank,hunterpettank]}) {
            | Make pet if it isn't up already !!!!
            /if (!${Me.Pet.ID}) {
                /echo My role is (${Role}), but I have no active pet.
                /echo Making my pet!
                /call DoPetStuff
            }
        }
        /if (${Select[${Role},assist,offtank]}) {
            DEBUGN Looks like I am ${Role}ing.
            /if (${UseMQ2Melee}) {
                /squelch /melee aggro=0
                /stick mod 0
            } else {
                /if (${MeleeOn} || ${DPSOn}) {
                    /if (${DStickHow.Equal[auto]}) {
                        /varset StickHow snaproll
                        /stick mod 0
                    } else {
                        /varset StickHow ${DStickHow}
                        /stick mod 0
                    }
                } else {
                    /varset StickHow 0
                }
            }
            /if (${Me.Pet.ID} && ${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
        } else /if (${Role.Equal[tank]}) {
            DEBUGN Looks like I am Main Tank. Wish me luck.
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset AssistAt 100
            /if (${UseMQ2Melee}) {
                /squelch /melee aggro=1
            } else {
                /if (${DStickHow.Equal[auto]}) {
                    /varset StickHow snaproll front moveback
                    /stick mod -2
                } else {
                    /varset StickHow ${DStickHow}
                    /stick mod -2
                }
            }
            /if (${Me.Pet.ID} && ${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
        } else /if (${Role.Equal[puller]}) {
            DEBUGPULL role puller
            DEBUGPULL Looks like I am Puller.
            /if (${UseMQ2Melee}) {
                /squelch /melee aggro=0
            } else {
                /if (${DStickHow.Equal[auto]}) {
                    /varset StickHow snaproll
                    /stick mod 0
                } else {
                    /varset StickHow ${DStickHow}
                    /stick mod 0
                }
            }
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID}) {
                /if (${Me.Pet.Distance}<=${CampRadius}) {
                    /pet guard
                } else {
                    /pet follow
                }
                /if (${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
            }
        } else /if (${Role.Equal[pullertank]}) {
            DEBUGPULL role pullertank
            DEBUGPULL Looks like I am Puller and Tank.
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /if (${DStickHow.Equal[auto]}) {
                /varset StickHow snaproll front moveback
                /stick mod -2
            }
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Pet.ID}) {
                /if (${Me.Pet.Distance}<=${CampRadius}) {
                    /pet guard
                } else {
                    /pet follow
                }
                /if (${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
            }
        } else /if (${Select[${Role},hunter]}) {
            DEBUGPULLL role hunter
            DEBUGPULLL Looks like I am Hunting.
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /if (${UseMQ2Melee}) /squelch /melee aggro=1
            /varset AssistAt 100
            /if (${StickHow.Equal[auto]}) {
                /varset StickHow moveback
                /stick mod -2
            }
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${ReturnToCamp}) {
                /varset ReturnToCamp 0
                /varset StayPut 0
            } else {
                /varset StayPut 1
                /varset PullOnReturn 1
            }
            /if (${Pet.ID}) {
                /pet follow
                /if (${Pet.Taunt} && !${PetTauntOverride}) /pet taunt off
            }
        } else /if (${Role.Equal[hunterpettank]}) {
            DEBUGPULL role hunterpettank
            DEBUGPULL Looks like I am Hunting and my pet is tanking.
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange ${PetAttackDistance}
            /if (${ReturnToCamp}) {
                /varset ReturnToCamp 0
                /varset StayPut 0
            } else {
                /varset StayPut 1
                /varset PullOnReturn 1
            }
            /varset ChaseAssist 0
            /varset MountOn 0
            /if (${Pet.ID}) {
                /pet follow
                /if (!${Pet.Taunt}) /pet taunt on
            }
            /varset PetAssistAt 100
        } else /if (${Select[${Role},petassist]}) {
            DEBUGPULL role petassist
            DEBUGPULL Looks like I am assisting a pet.
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
        } else /if (${Select[${Role},pettank]}) {
            DEBUGPULL role pettank
            DEBUGPULL Looks like my pet is tanking.
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset AssistAt 100
            /varset PetTanking 1
            /varset PetAttackRange ${PetAttackDistance}
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Me.Pet.ID} && !${Pet.Taunt}) /pet taunt on
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend} && ${specialK}) /call PetStateCheck
            /varset PetAssistAt 100
        } else /if (${Select[${Role},pullerpettank]}) {
            DEBUGPULL role pullerpettank
            DEBUGPULL Looks like I am pulling and my pet is tanking.
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset AssistAt 100
            /varset MeleeOn 0
            /varset PetTanking 1
            /varset PetAttackRange ${PetAttackDistance}
            /varset ReturnToCamp 1
            /varset ChaseAssist 0
            /varset MountOn 0
            /varcalc CampRadiusExceed ${MaxRadius}+200
            /if (${Me.Pet.ID} && !${Pet.Taunt}) /pet taunt on
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) /pet guard
            /if (${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /pet follow
            /if (${PullRoleToggle} && ${Group.Leader.ID}!=${Me.ID}) {
                /echo You are set to toggle puller mode but are NOT the group leader.
                /echo Please correct this and restart KissAssist.
                /endmacro
            }
            |- Function to determine pet active state and suspended pet state if enabled.
            /if (${PetSuspend} && ${specialK}) /call PetStateCheck
            /varset PetAssistAt 100
        } else /if (${Role.Equal[manual]}) {
            /if (${UseMQ2Melee}) /squelch /melee aggro=0
            /varset MeleeOn 0
            /varset ReturnToCamp 0
            /varset ChaseAssist 0
            /varset DPSOn 0
            /varset BuffsOn 0
            /varset DebuffAllOn 0
            /if (${Defined[HealsOn]}) /varset HealsOn 0
            /if (${Defined[MezOn]}) /varset MezOn 0
        }
        /if (${TargetSwitchingOn} && !${IAmMA}) /varset TargetSwitchingOn 0
        /if (${StickHow.Equal[null]} || ${StickHow.Equal[auto]}) /varset StickHow 0
        /if (${Select[${Role},puller,pullerpet]}==0 && ${ChainPull}) /varset ChainPull 0
        /if (!${Role.Find[puller]} && !${Role.Find[hunter]}) /varset PullPause 0
        /if (!${PetAttackRange} && ${PetAttackDistance}) /varset PetAttackRange ${PetAttackDistance}
        /if (${MezOn}) {
            /if (${MezDebuffOnResist}) {
                /if (!${Me.AltAbility[${MezDebuffSpell}]} && !${FindItem[=${MezDebuffSpell}].ID} && !${Me.Book[${MezDebuffSpell}]}) {
                    /varset MezDebuffOnResist 0
                    /echo Setting MezDebuffOnResist off. Could not Find MezDebuffSpell: ${MezDebuffSpell}.
                }
            }
        }
        DEBUGN CheckRoles Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: PullRangeSet
| -------------------------------------------------------------------------------------
    Sub PullRangeSet
        DEBUGPULL PullRange Enter
        /declare PullItemRange int local
        /if (${FindItemCount[=${PullWith.Arg[1,|]}]} && ${Redguides}) {
            /if (${Select[${FindItem[=${PullWith.Arg[1,|]}].Type},Archery,Throwing,Throwingv1,Throwingv2,ammo]}) {
                /varset PullItem ${PullWith.Arg[1,|]}
                /varset PullItemRange ${FindItem[=${PullWith.Arg[1,|]}].Range}
                /if (!${PullItemRange}) /varset PullItemRange 50
                /if (${FindItem[=${PullWith.Arg[2,|]}].WornSlot[ammo]} && ${FindItemCount[=${PullWith.Arg[2,|]}]}) {
                    /varset PullAmmo ${PullWith.Arg[2,|]}
                    | If pullitem is a bow add arrow range to bow for total range
                    /if (${FindItem[=${PullWith.Arg[1,|]}].Type.Equal[Archery]}) {
                        /varcalc PullItemRange ${PullItemRange}+${FindItem[=${PullWith.Arg[2,|]}].Range}
                    }
                    /call PullVars ${Math.Calc[${PullItemRange}*(${PullRadiusToUse}/100)]} Ranged ${PullItemRange}
                } else {
                    /echo I can't find any ammo defaulting to Melee for PullWith
                    /varset PullWith Melee
                    /call PullVars 15 Melee 15
                }
                DEBUGPULL PullWith=(${PullWith}) PullItem=(${PullItem}) PullItemRange=(${PullItemRange}) PullItemCount=(${FindItemCount[=${PullWith.Arg[1,|]}]}) PullAmmo=(${PullAmmo})
            } else /if (${FindItemCount[=${PullWith}]} && !${PullWith.Arg[2,|].Length}) {
                /varset PullItemRange ${FindItem[=${PullWith}].Spell.Range}
                /call PullVars ${Math.Calc[${PullItemRange}*(${PullRadiusToUse}/100)]} "${PullWith}" ${PullItemRange}
            }
        } else /if (${Me.CombatAbility[${PullWith}]} || ${Me.Book[${PullWith}]} || ${Me.AltAbility[${PullWith}]}) {
            /if (${Me.AltAbility[${PullWith}]}) {
                DEBUGPULL ${Math.Calc[${Me.AltAbility[${PullWith}].Spell.Range}*(${PullRadiusToUse}/100)]} "${PullWith}" ${Me.AltAbility[${PullWith}].Spell.Range}
                /call PullVars ${Math.Calc[${Me.AltAbility[${PullWith}].Spell.Range}*(${PullRadiusToUse}/100)]} "${PullWith}" ${Me.AltAbility[${PullWith}].Spell.Range}
            } else {
                DEBUGPULL ${Math.Calc[${Spell[${Spell[${PullWith}].ID}].MyRange}*(${PullRadiusToUse}/100)]} "${PullWith}" ${Spell[${PullWith}].MyRange}
                /call PullVars ${Math.Calc[${Spell[${PullWith}].MyRange}*(${PullRadiusToUse}/100)]} "${PullWith}" ${Spell[${PullWith}].MyRange}
            }
        } else /if (${PullWith.Equal[Pet]}) {
            /if (${Role.Equal[hunterpettank]}) {
                /call PullVars ${Math.Calc[${PetAttackRange}*.80]} Pet ${Math.Calc[${PetAttackRange}*.80]}
            } else {
                /call PullVars 185 Pet 185
            }
        } else /if (${PullWith.Equal[Melee]}) {
            /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                /beep
                /beep
                /beep
                /popup You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                DEBUGPULL ${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}
                /echo You can't pull with MQ2Advpath and Melee. Please change PullWith to a Spell/AA/Disc/Ranged Weapon.
                /endmac
            } else {
                /call PullVars 15 Melee 15
            }
        } else /if (!${Select[${PullWith},Ranged]}) {
            /echo Unknown PullWith setting. Please see Kiss Instructions.
        }
        DEBUGPULL PullRange PullWith: ${PullWith} - CA:${Me.CombatAbility[${PullWith}]}/SPELL:${Me.Book[${PullWith}]}/ AA: ${Me.AltAbility[${PullWith}]}
        DEBUGPULL PullRange Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: PaintMap
| -------------------------------------------------------------------------------------
    Sub PaintMap
        DEBUGPULL PaintMap Enter - ${MapSet} - ${Math.Distance[${CampYLoc},${CampXLoc}]} - ${CampRadius}
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
            /if (${Bool[${Plugin[MQ2Map]}]}) {
                /if (!${MapSet}) {
                    /squelch /mapfilter CastRadius ${PullRange}
                    /squelch /mapfilter SpellRadius ${MaxRadius}
                    /squelch /mapfilter PullRadius ${MaxRadius}
                    /squelch /mapfilter CampRadius ${CampRadius}
                }
            }
            /varset MapSet 1
        }
        DEBUGPULL PaintMap Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: PullVars
| -------------------------------------------------------------------------------------
    Sub PullVars(int pRange, pType, int pRange2)
        DEBUGPULL PullVars Enter
        /varset PullRange ${pRange}
        /varset PullWith ${pType}
        /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) /varcalc MaxRadius ${TempMaxRadius}+${PullRange}
        DEBUGPULL MaxRadius is now ${MaxRadius}
        DEBUGPULL PullVars Leave
    /return
| -----------------------------------------------------------------------------------------------------------
| SUB: FindMobToPull(int ReadyToPullFlag) (NEW VERSION) ReadyToPullFlag 1 - Find mob and pull  0 - Check to see if there is a mob
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobToPull(int ReadyToPullFlag,int Piterations, int UseCampLoc)
        DEBUGPULL FindMobToPull PreCheck ${DMZ} ${Me.InInstance} ${ReadyToPullFlag} Pulled: ${Pulled} ${AggroTargetID} ${ChainPull} Invis: ${Me.Invis} ${PullHold} ${DPSPaused} ${Me.Buff[Resurrection Sickness].ID} ${Me.Buff[Revival Sickness].ID}
        /if ((${DMZ} && ${Me.InInstance}==FALSE) || !${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]} || ${Pulled} || (${AggroTargetID} && !${ChainPull})) /return 0
        /if (${Me.Invis} || ${PullHold} || ${DPSPaused} || ${Me.Buff[Resurrection Sickness].ID} || ${Me.Buff[Revival Sickness].ID}) /return 0
        /if (${CheckOnReturn} && ${ReadyToPullFlag}) /varset CheckOnReturn 0
        /call MobRadar pull 0 FindMobToPull
        /if (${ChainPull} && (${MobCount}>1 || ${Me.XTarget[${XTSlot2}].ID})) /return 0
        /if (${ReadyToPullFlag}) {
            /if (${ChainPull}) {
                /if (${Target.ID}==${Me.ID}) {
                    /squelch /target clear
                    /delay 10
                }
                /if (${Me.XTarget[${XTSlot}].ID} && ((!${MyTargetID} && !${Target.ID}) || ${Target.PctHPs}>=${ChainPullHP} || (${MyTargetID} && ${Spawn[${MyTargetID}].PctHPs}>=${ChainPullHP}))) /return 0
                /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>75) /return 0
            }
        }
        /if (${ReadyToPullFlag}) {
            /if (!${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]} || ${Me.Buff[Resurrection Sickness].ID} || ${Me.Buff[Revival Sickness].ID} || ${IAmDead}) /return 0
            /if (${PetRampPullWait} && !${Me.CombatState.Equal[COMBAT]} && ${Select[${Role},pullerpettank]} && ${Select[${Me.Class.ShortName},MAG,NEC,BST]}) /call CheckRampPets
        }    
        DEBUGPULL FindMobToPull Enter ${ReadyToPullFlag}
        /call PullRangeSet
        /while (1) {
            /varset EventFlag 0
            /doevents
            /if (!${EventFlag}) /break
        }
        /declare BeginSearchX    int    local 0
        /declare MobsNearCamp    int    local
        /declare MobsToPullList  int    local
        /declare ModsReturnCheck int    local 0
        /declare PullAttempts    int    local 3
        /declare PullCount       int    local
        /declare LastCount       int    local 1
        /declare Pindex          int    local 1
        /declare PTempRadius     int    local 0
        /declare vstStr1         string local
        /varset Pulling 0
        /call GroupWatch
        /if (${PullHold}) /return 0
        /if (!${Piterations}) /varset Piterations 1
        /if (${ReadyToPullFlag}) {
            /if (!${FailCounter}) /echo Looking for Close Range Mobs
        } else {
            /if (!${SpamTimer}) {
                /echo Checking for Close Range Mobs
                /varset SpamTimer 50
            }
        }
        | Clear alert list 1, add mobs to ignore alert list1, set timer to keep alert list manageable for pulling no alert 1
        /if (!${PullAlertTimer}) {
            /varset PullIgnore1 null
            | Add Ignore Mob list to alert list
            /call AlertAddToList 1 "${MobsToIgnore}" "null"
            /varset PullAlertTimer 5m
        } else {
            /call PullIgnoreCheck 1 c
        }
        | Advpath searches for mobs along the path using Pullwith radius not Maxradius
        | FindAdvPath Routine searches and returns first valid mob along path.
        | Does not require additional code for searching.
        /if (${PullMoveUse.Equal[advpath]}) {
            /call FindMobAdvPath ${ReadyToPullFlag}
            /return ${Macro.Return}
        }
        /if (${Select[${Role},hunter,hunterpettank]}) {
            /if (${PullMoveUse.Equal[nav]}) {
                /varset vstStr1 npc
            } else {
                /varset vstStr1 npc los
            }
            /if (${UseCampLoc}) /varset vstStr1 ${vstStr1} loc ${CampXLoc} ${CampYLoc}
        } else {
            /if (${PullMoveUse.Equal[nav]}) {
                /varset vstStr1 npc loc ${CampXLoc} ${CampYLoc}
            } else {
                /varset vstStr1 npc los loc ${CampXLoc} ${CampYLoc}
            }
        }
        |To keep from taking to long to find the next mob. Have the search break the area into smaller sizes.
        |PullAttempts=3 All mobs in MaxRange. PullAttempts=1 Use range that will find 25 mobs at a time.
        /if (${SpawnCount[${vstStr1} radius ${MaxRadius} zradius ${MaxZRange} targetable ${SearchType}]}>${PullMaxCount}) /varset PullAttempts 1
        /while (1) {
            /varset PullCount 0
            /varset Pindex 1
            /varset Piterations 1
            /if (${PullAttempts}<3) {
                /varcalc ModsReturnCheck ${PullAttempts}*25
            } else {
                /varset ModsReturnCheck 10000
            }
            /while (!${PullCount} && (${Pindex}<=${Piterations})) {
                /if (${Pindex}==${Piterations}) {
                    /varset PTempRadius ${MaxRadius}
                    /varcalc Pindex ${Piterations}+1
                } else {
                    /varcalc PTempRadius (${MaxRadius}/${Piterations})*${Pindex}
                    /varcalc Pindex ${Pindex}+1
                }
                /varset PullCount ${SpawnCount[${vstStr1} radius ${PTempRadius} zradius ${MaxZRange} targetable ${SearchType}]}
                /if (${PullCount}>${ModsReturnCheck}) {
                    /varcalc Piterations ${Piterations}+1
                    /varcalc Pindex ${Pindex}-1
                    /varset PullCount 0
                    /continue
                }
                /varset MobsNearCamp ${SpawnCount[${vstStr1} radius ${MeleeDistance} zradius ${MaxZRange} targetable ${SearchType}]}
                DEBUGPULL FindMobToPull: Checking to temp radius \at${PTempRadius}\ax and found \at${PullCount}\ax mobs \at${Pindex} - ${Piterations}\ax 
            }
            /if (${Bool[${Plugin[MQ2Map]}]}) /squelch /mapfilter SpellRadius ${PTempRadius}
            DEBUGPULL FindMobToPull ReadyToPullFlag:${ReadyToPullFlag} Pullcount: ${LastCount} : ${PullCount} MobsNearCamp: ${MobsNearCamp} Pull How: ${PullMoveUse} Attempt: ${PullAttempts} Search Type: ${SearchType} vstStr1: ${vstStr1}
            /if (!${ReadyToPullFlag}) { 
                | Are we Chain Pulling and Last Mob Pulled still out of melee range?
                /if (${PullCount}>0 && ${Spawn[${LastMobPullID}].Distance}>=${MeleeDistance}) /return 0
                | We are chain Pulling so recalc PullCount based on PullCount - Mobs in MelleDistance.
                /varcalc PullCount ${PullCount}-${MobsNearCamp}
            }
            | If PullCount is NOT zero then lets find a valid mob to pull.
            /if (${PullCount}) {
                /if (!${ReadyToPullFlag} && ${MobsNearCamp}) {
                    /if (${LastCount}<2) {
                        /varset BeginSearchX 2
                    } else {
                        /varset BeginSearchX ${LastCount}
                    }
                } else {
                    /varset BeginSearchX ${LastCount}
                }
                /if (${PullMoveUse.Equal[nav]}) {
                    /call FindMobNAV ${ReadyToPullFlag} ${BeginSearchX} ${PullCount} "${vstStr1}"
                } else /if (${PullMoveUse.Equal[los]}) {
                    /call FindMobLOS ${ReadyToPullFlag} ${BeginSearchX} ${PullCount} "${vstStr1}"
                }
                /varset LastCount ${PullCount}
                /if (!${PullMob}) /varset ChainPullTemp 0
            } else {
                | There were no mobs to pull based on PullCount.
                /varset ChainPullTemp 0
                /varset PullMob 0
                /break
            }
            /if (${PullAttempts}==3 || ${PullMob}) /break
            /varcalc PullAttempts ${PullAttempts}+1
        }
        DEBUGPULL FindMobToPull: ReadyToPullFlag: ${ReadyToPullFlag} Name: ${Spawn[${PullMob}].CleanName} MobID: ${PullMob} PullCount: ${PullCount}
        DEBUGPULL FindMobToPull Leave
    /return ${PullMob}
| -----------------------------------------------------------------------------------------------------------
| SUB: Find Mob Using Advanced Path.
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobAdvPath(int PFlag)
        /declare i int local
        /declare k int local
        /declare l int local
        /declare PullMobName string local 0
        /declare PullMobDistance float local 0
        /declare PullMobValid int local 0
        /declare DistanceCheck int local
        /declare WPMobCount int local
        | Advpath searches for mobs along the path using Pullwith radius not Maxradius
        DEBUGPULL FindMobAvdPath Enter ${PFlag}
        /if (${Target.ID}) /squelch /target clear
        /varset PullMobValid 0
        | loop through pathwaypoints and check for mobs
        /for k 1 to ${PullPathWpCount}
            /varset WPMobCount 0
            /varset PullMob 0
            /if (${UseWayPointZ}) {
                /varset WPMobCount ${SpawnCount[npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${PullPathArrayZ[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable ${SearchType}]}
            } else {
                /varset WPMobCount ${SpawnCount[npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable ${SearchType}]}
            }
            /if (${WPMobCount}) {
                /varset i 0
                /for l 1 to ${WPMobCount}
                    /if (${UseWayPointZ}) {
                        /varset PullMob ${NearestSpawn[${l}, npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${PullPathArrayZ[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable ${SearchType}].ID}
                    } else {
                        /varset PullMob ${NearestSpawn[${l}, npc loc ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} radius ${PullRange} zradius ${MaxZRange} targetable ${SearchType}].ID}
                    }
                    DEBUGPULL FindMobAdvPath 1: WP: ${k} MobID ${PullMob} LOS ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]} YXZ ${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}
                    DEBUGPULL FindMobAdvPath 1.0: WP: ${k} MobID ${PullMob} UseWaypointZ: ${UseWayPointZ} WP Z: ${PullPathArrayZ[${k}]} Spawn Z: ${Spawn[id ${PullMob}].Z} Distance From Z: ${Math.Distance[${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Z}]}
                    /if (${DebugPull}) /delay 1
                    /if (${PullMob} && ${LineOfSight[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                        /varset DistanceCheck ${Math.Distance[${PullPathArrayY[${k}]},${PullPathArrayX[${k}]},${PullPathArrayZ[${k}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                        /if (${k}<${PullPathWpCount}) {
                            /varcalc i ${k}+1
                            /while (${i}<=${PullPathWpCount} && ${DistanceCheck}>${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}) {
                                /varset DistanceCheck ${Math.Distance[${PullPathArrayY[${i}]},${PullPathArrayX[${i}]},${PullPathArrayZ[${i}]}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
                                /varset k ${i}
                                /varcalc i ${i}+1
                            }
                        }
                        DEBUGPULL FindMobAdvPath: WP ${k} MobCount ${l} ${WPMobCount}
                        /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
                        /varset PullMobDistance ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                        /varcalc AdvpathPointNum ${k}
                        /varset AdvpathPointX ${PullPathArrayX[${k}]}
                        /varset AdvpathPointY ${PullPathArrayY[${k}]}
                        /varset AdvpathPointZ ${PullPathArrayZ[${k}]}
                        DEBUGPULL FindMobAdvPath 2: WP: ${k} Pullmob ${PullMob} Waypoint: ${AdvpathPointNum} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]} ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]}<${PullRange}
                        DEBUGPULL FindMobAdvPath 2: AdvPull: Pullmob: ${PullMobName} ID ${PullMob} Waypoint: ${PullPathWpCount} XY: ${PullPathArrayX[${k}]} ${PullPathArrayY[${k}]}
                        /call PullValidate ${PullMob} ${PFlag}
                        /varset PullMobValid ${Macro.Return}
                        /if (${PullMobValid}) /return ${PullMob}
                    }
                /next l
            }
        /next k
        /varset PullMob 0
        DEBUGPULL FindMobAdvPath: Mob Not Found. AdvPull: ReadyToPullFlag: ${PFlag} Role: ${Role} ID: ${PullMob} PullRange: ${PullRange}
        DEBUGPULL FindMobAdvPath: ReadyToPullFlag: ${PFlag} Leave
        | Check for mobs in max pull radius for normal,MQ2nav pulling
    /return 0
| -----------------------------------------------------------------------------------------------------------
| SUB: Find Mob Using Navigation.
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobNAV(int PFlag, int BCount, int MobsInRadius, string SpawnFilter)
        /declare p int local
        /declare PullMobName string local 0
        /declare PullMobValid int local 0
        /declare MobID          int     local   0
        /declare PathLength     float   local   0
        /declare MobIDDistance  float   local   0
        /declare PathCount      int     local   1
        /declare PathShortest   float   local   0
        /if (!${BCount}) /varset BCount 1
        DEBUGPULL FindMobNAV Enter ${PFlag} ${MobID}
        /for p ${BCount} to ${MobsInRadius}
            DEBUGPULL FindMobNAV: ${SpawnFilter} ${Spawn[${MobID}].Distance} ${PathShortest} ${PathCount}
            /varset MobID ${NearestSpawn[${p}, ${SpawnFilter} radius ${MaxRadius} zradius ${MaxZRange} targetable ${SearchType}].ID}
            /if (${Spawn[${MobID}].Distance}>${PathShortest} && ${PathCount}>1) {
                /continue
            }
            
            DEBUGPULL FindMobNAV: Call PullValidate ${MobID} ${PFlag}
            /call PullValidate ${MobID} ${PFlag}
            DEBUGPULL FindMobNAV: ${p}.${MobID} Macro.Return ${Macro.Return}
            /if (!${Macro.Return}) {
                DEBUGPULL FindMobNAV: ${MobID} not valid pull ${Macro.Return}
                /continue
            }

            /varset PathLength ${Navigation.PathLength[id ${MobID}]}
            DEBUGPULL FindMobNAV: Sorting Mobs by nav pathlength
            /if (${PathLength} > 0) {
                /varset ChainPullTemp ${MobID}
                DEBUGPULL FindMobNAV: ${MobID} Valid pull - ${PathLength} 
                /if (${PathCount}==1) {
                    /varset PullMob ${MobID}
                    /varset PathShortest ${PathLength}
                } else /if (${PathLength} < ${PathShortest}) {
                    /varset PullMob ${MobID}
                    /varset PathShortest ${PathLength}
                }
                /varcalc PathCount ${PathCount}+1 
            } else {
                DEBUGPULL FindMobNAV: ${MobID} not valid pull - ${PathLength}
            }
        /next p
        /if (${PullMob}) {
            /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
        } else {
            /varset PullMob 0
            /varset PullMobName
        }
        DEBUGPULL FindMobNAV: ${PullMob} PullMobName ${PullMobName} ReadyToPullFlag: ${PFlag} Leave
    /return ${PullMob}
| -----------------------------------------------------------------------------------------------------------
| SUB: Find Mob Using LOS.
| -----------------------------------------------------------------------------------------------------------
    Sub FindMobLOS(int PFlag, int BCount, int ECount, SpawnFilter)
        /declare i int local
        /declare p int local
        /declare PullMobName string local 0
        /declare PullMobValid int local 0
        DEBUGPULL FindMobLOS Enter ${PFlag}
        /for i ${BCount} to ${ECount}
            DEBUGPULL FindMobLOS 1.0:  ReadyToPullFlag: ${PFlag} Pullcount: ${ECount}
            /varset PullMob ${NearestSpawn[${i}, ${SpawnFilter} radius ${MaxRadius} zradius ${MaxZRange} targetable noalert 1].ID}
            /if (${PullMob}) /varset PullMobName ${Spawn[id ${PullMob}].CleanName}
            DEBUGPULL FindMobLOS: ReadyToPullFlag: ${PFlag} Normal Name: ${PullMobName} ID: ${PullMob} LOS: ${LineOfSight[${CampYLoc},${CampXLoc},${CampZLoc}:${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X},${Spawn[id ${PullMob}].Z}]}
            /varset PullMobValid 0
            /if (${PullMob}) {
                /call PullValidate ${PullMob} ${PFlag}
                DEBUGPULL FindMobLOS: ${i}.${PullMob} Macro.Return ${Macro.Return}
                /if (${Macro.Return}) {
                    /varset PullMobValid 1
                    /varset ChainPullTemp ${PullMob}
                }
            }
            /if (${PullMobValid}) /return ${PullMob}
        /next i
        /varset PullMob 0
        DEBUGPULL FindMobLOS: ReadyToPullFlag: ${PFlag} Leave
    /return ${PullMob}
| -----------------------------------------------------------------------------------------------------------
| SUB: PullCheck PullMob is Mob ID of mob to pull.
| -----------------------------------------------------------------------------------------------------------
    Sub PullCheck
        DEBUGPULL PullCheck Enter ${PullMob}
        DEBUGPULL PullCheck: 1.0: Name: ${Spawn[${PullMob}].CleanName} MobID: ${PullMob} ${PullMoveUse}
        /if (${ChainPull}==2) /varset ChainPull 1
        /if (${PullOnReturn} && ${CheckOnReturn}) /varset CheckOnReturn 0
        /if (${PullHold} || ${DPSPaused} || ${Me.Buff[Resurrection Sickness].ID} || ${Me.Buff[Revival Sickness].ID} || ${CampZone}!=${Zone.ID} || ${Me.Invis}) /return 0
        /if (${PullMob} && ${Select[${PullMoveUse},los,nav]}>=1 && (${Spawn[${PullMob}].Distance3D}<=360 || ${Spawn[${PullMob}].LineOfSight})) {
            /target id ${PullMob}
            /delay 20 ${Target.ID}==${PullMob}
        }
        /if (${PullMob} && ${Spawn[${PullMob}].ID}) {
            /varset Pulling 1
            | Advpath skill validate mob
            /if (${PullMoveUse.Equal[advpath]}) {
                /varset MyTargetID ${PullMob}
                /varset MyTargetName ${Spawn[${PullMob}].CleanName}
                /target id ${PullMob}
                /delay 20 ${Target.ID}==${PullMob}
                | Is mob really in range. check for spawn lag
                /if (${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]}>${PullRange}) {
                    /call PullIgnoreCheck ${PullMob} a
                    /echo Mob is OOR after targeting. Trying Again. ${PullMob} ${Math.Distance[${Spawn[id ${PullMob}].Y},${Spawn[id ${PullMob}].X}:${AdvpathPointY},${AdvpathPointX}]} ${PullRange} - ${AdvpathPointY} ${AdvpathPointX}
                    /squelch /target clear
                    /varset Pulling 0
                    /return 0
                }
            }
            /call ValidateTarget ${PullMob}
            DEBUGPULL PullCheck: Target: ${Spawn[${PullMob}].CleanName} Valid: ${ValidTarget} MacReturn ${Macro.Return}
            /if (${ValidTarget}==0 || (${Target.ID} && ${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}>${MaxRadius})) {
                /call PullIgnoreCheck ${PullMob} a "PullChecknav${Macro.Return}"
                /squelch /target clear
                /varset Pulling 0
                /return 0
            }
            /varcalc ColorIdx ${Select[${Spawn[${PullMob}].ConColor.Replace[ ,_]},grey,green,light_blue,blue,white,yellow,red]}+1
            /varset ConColor ${ColorList.Mid[${ColorIdx},1]}
            /if (${BroadCastSay.Equal[bc]}) {
                /call BroadCast t "PULLING-> [+${ConColor}+]${Spawn[${PullMob}].CleanName}[+t+] <- ID:${PullMob} at ${Int[${Math.Distance[${Spawn[${PullMob}].Y},${Spawn[${PullMob}].X}:${CampYLoc},${CampXLoc}]}]} feet."
            } else {
                /if (${ConColor.EqualCS[W]}) /varset ConColor -${ConColor.Lower}
                /call BroadCast t "PULLING-> \a${ConColor}${Spawn[${PullMob}].CleanName}\at <- ID:${PullMob} at ${Int[${Math.Distance[${Spawn[${PullMob}].Y},${Spawn[${PullMob}].X}:${CampYLoc},${CampXLoc}]}]} feet."
            }
            /varset MyTargetID ${PullMob}
            /varset MyTargetName ${Spawn[${PullMob}].CleanName}
            /if (${Pulling} && ${MyTargetID}) {
                /while (1) {
                    /if (${PullWith.Equal[Pet]} && ${Me.Pet.ID}) {
                        /if (${Me.Pet.Combat}) /pet back off
                        /if (${Me.Pet.Stance.NotEqual[FOLLOW]}) /pet follow
                    } else /if (${PullWith.Equal[melee]}) {
                        /varcalc PullRange ${Spawn[id ${MyTargetID}].MaxRangeTo}*.90
                    }
                    /if (${Target.ID} && ${Target.ID}!=${PullMob}) {
                        /if (${Me.Combat}) /attack off
                        /squelch /target clear
                    }
                    /call Pull
                    /varset Pulled 0
                    /if (${PullPause.Arg[1,|].NotEqual[0]}) /varset PullWaitTimer2 ${Math.Calc[${PullPause.Arg[2,"|"]}+1]}m
                    /if (${Macro.Return.Equal[oor]}) {
                        /varset CheckOnReturn 1
                        /return oor
                    } else /if (${Macro.Return.Equal[lma]}) {
                        /echo I got here2: ${MyTargetID} ${PullMob} ${Pulling} ${Pulled}
                        /varset Pulling 1
                        /continue
                    } else /if (${Macro.Return.Equal[dcbtc]} || ${Macro.Return.Equal[micd]}) {
                        /varset Pulling 0
                        /if (${ReturnToCamp}) /call DoWeMove 1 pullcheck
                    } else /if (${Macro.Return.Equal[iad]}) {
                        /while (1) {
                            /varset EventFlag 0
                            /doevents
                            /if (!${EventFlag}) /break
                        }
                        /return IAD
                    } else {
                        /return 0
                    }
                    /break
                }
            }
        } else /if (!${PullMob}) {
            /varcalc FailCounter ${FailCounter}+1
            DEBUGPULL PullCheck: No Valid Target in Range ${MaxRadius} - ${FailCounter} Time(s)
            /if (${FailCounter}>=${FailMax}) {
                /call AlertClearList 1 PullCheck
                /varset FailCounter 0
                /varset PullAlertTimer 0
                /if (${Select[${Role},hunter,hunterpettank]} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15) {
                    DEBUGPULL PullCheck Returning hunter to camp
                    /echo ${Role}: There are no mobs within ${MaxRadius}.
                    /if (${StayPut}) {
                        /echo ===> Waiting here for respawn.
                    } else {
                        /echo ===> Returning to camp.
                        /call DoWeMove 1 pullcheck
                    }
                }
                /if (${PullWait} && !${AggroTargetID}) {
                    /call BroadCast t "PULLING-> Waiting ${PullWait} seconds for mobs to respawn."
                    /call PullDelay ${PullWait}
                }
                /return 0
            }
        }
        DEBUGPULL PullCheck:  Leave
    /return 0
| -------------------------------------------------------------------------------------
| SUB: PullDelay
| -------------------------------------------------------------------------------------
    Sub PullDelay(int TimerAmount)
        DEBUGPULL PullDelay ${TimerAmount} Enter
        /declare PDTimer timer local ${TimerAmount}s
        /varset Pulling 0
        /varset Pulled 0
        /if (${MedOn} && !${Me.Mount.ID} && ${Me.Standing} && !${Me.Moving}) /sit
        /while (${PDTimer} && !${AggroTargetID}) {
            /doevents
            /delay 2
            DOPARSE
        }
        /if (${AggroTargetID}) {
            /if (${DPSOn} || ${MeleeOn}) {
                /call CheckForCombat 0 PullDelay1 0
            } else {
                /call CheckForCombat 1 PullDelay2 0
            }
        }
        DEBUGPULL PullDelay Leave
    /return
| ----------------------------------------------------------------------------
| SUB: PullValidate
| ----------------------------------------------------------------------------
    Sub PullValidate(PVPullMob, int PFlag)
        /declare j int local
        /declare skipFlag int    local 0
        /declare mobCheck string local 
        /if (${MobsToPull.NotEqual[all]}) {
            /for j 1 to 25
                /if (!${MobsToPull.Arg[${j},,].Length}) /break
                /varset mobCheck ${MobsToPull.Arg[${j},,]}
                DEBUGPULL PullValidate: PFlag: ${PFlag} ${j} ${PVPullMob} PullList ${Spawn[id ${PVPullMob}].CleanName}/${MobsToPull.Arg[${j},,]} ${Spawn[id ${PVPullMob}].CleanName.Equal[${MobsToPull.Arg[${j},,]}]}
                /if (${mobCheck.Find[*]}) {
                    /varset mobCheck ${mobCheck.Replace[*,]}
                    /if (${Spawn[id ${PVPullMob}].CleanName.Find[${mobCheck}]}) /varset skipFlag 1
                } else {
                    /if (${mobCheck.Find[#]}) /varset mobCheck ${mobCheck.Replace[#,]}
                    /if (${Spawn[id ${PVPullMob}].CleanName.Equal[${mobCheck}]}) /varset skipFlag 1
                }
                /if (${skipFlag}) /break
            /next j
            /if (!${skipFlag}) {
                DEBUGPULL PullValidate ${Spawn[id ${PVPullMob}].CleanName} NOT on MobsToPull List
                /return 0
            }
        }
        | If mob found on ignore list
        /if (${MobsToIgnore.Find[${Spawn[${PVPullMob}].CleanName}]}) /return 0
        /if (${MobsToIgnoreByID.Find[${PVPullMob}|]}) /return 0
        /if (${PullIgnore1.Find[${PVPullMob}|]}) /return 0
        /if (${PullLocsOn}) {
            /for j 1 to ${PullLocs.Size}
                /if (!${Bool[${PullLocs[${j}]}]}) /break
                /if (${Math.Distance[${Spawn[id ${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${PullLocs[${j}].Arg[1,|]}]}<=${PullLocs[${j}].Arg[2,|]}) {
                    DEBUGPULL PullValidate ${Spawn[id ${PVPullMob}].CleanName} is in Invalid PullLocs Location.
                    /return 0
                }
            /next j
        }
        DEBUGPULL PullValidate Pulling: ${Spawn[id ${PVPullMob}].CleanName}
        | Check spawn for out of range - macro start point as epicEnter
        /if (${Select[${PullMoveUse},los,nav]}>=1 && ${Math.Distance[${Spawn[id ${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${CampYLoc},${CampXLoc}]}>${MaxRadius}) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Out of Range
            /return 0
        }
        | Check spawn for eye of zomm/tallon ${SpawnCount[pc ${PVPullMob.Right[${Math.Calc[${PVPullMob.Length}-7]}]}]}
        /if (${Spawn[${PVPullMob}].CleanName.Find[Eye of]} && ${SpawnCount[pc ${Spawn[${PVPullMob}].CleanName.Right[${Math.Calc[${Spawn[${PVPullMob}].CleanName.Length}-7]}]}]}) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Eye of Zomm/Tallon
                /return 0
        }
        | Check spawn for line of sight - no mq2nav
        /if (${Select[${Role},puller,pullertank,pullerpettank]} && !${Spawn[${PVPullMob}].LineOfSight} && ${PullMoveUse.Equal[los]}) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No line of sight
                /return 0
        }
        | Check spawn for Level Range
        /if (${Spawn[${PVPullMob}].Level}<${PullMin} || ${Spawn[${PVPullMob}].Level}>${PullMax}) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].Level} invalid target Reason: Invalid NPC Level
            /return 0
        }
        | Check if any PC/toon is near the mob
        /if (${SpawnCount[notid ${Me.ID} loc ${Spawn[${PVPullMob}].X} ${Spawn[${PVPullMob}].Y} radius 30 pc nogroup]}>0 && ${Pulling}) {
        |/if (${SpawnCount[loc ${Spawn[${PVPullMob}].X} ${Spawn[${PVPullMob}].Y} radius 15 pc]}>=1 && ${Pulling} && ${Math.Distance[${Spawn[${PVPullMob}].Y},${Spawn[${PVPullMob}].X}:${Me.Y},${Me.X}]}>=16) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: PCs near mob
            /return 0
        }
        /if (${PullArcWidth}>0) {
            /call FigureMobAngle ${Int[${PVPullMob}]}
            /if (${Macro.Return.Equal[0]}) {
                DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} ${PullLSide} ${Spawn[id ${PVPullMob}].HeadingTo[${CampYLoc},${CampXLoc}].Degrees} ${PullRSide} invalid target Reason: Mob not in Pull Area
                /return 0
            }
        }
        | Check spawn for 100% health
        /if (${Spawn[${PVPullMob}].PctHPs}<=99 && ${Spawn[${PVPullMob}].Distance}>=${MeleeDistance}) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: Mob not 100% health ${Spawn[${PVPullMob}].PctHPs}
            | If chain pulling then target mob to update server.
            /if (${PFlag} && ${Spawn[${PVPullMob}].Distance}<=360 && ${Target.ID}!=${PVPullMob}) {
                /Echo Mob not at 100% HPs Double checking for server lag PFlag: ${PFlag} PVPullMob: ${PVPullMob} - ${Spawn[${PVPullMob}].CleanName} MobCount: ${MobCount}
                /target id ${Spawn[${PVPullMob}].ID}
                /delay 20 ${Target.ID}==${PVPullMob} && ${Target.BuffsPopulated}
                /if (${Target.PctHPs}>99) {
                    /return 1
                } else {
                    /call PullIgnoreCheck ${PVPullMob} a pullvalidate
                }
            }
            /return 0
        }
        /if (${Spawn[${PVPullMob}].Named} && ((${PFlag} && ${MobCount} && ${Me.XTarget[${XTSlot}].ID}) || !${PFlag})) {
            DEBUGPULL PullValidate: PFlag: ${PFlag} ${Spawn[${PVPullMob}].CleanName} invalid target Reason: No Pull Names with Mobs in Camp
            /return 0
        }
    /return 1
|--------------------------------------------------------------------------------
|SUB: CheckRampPets - Writtten by Trehuggindruid for KissAssist
|--------------------------------------------------------------------------------
    Sub CheckRampPets
        /declare i int local
        /declare DoLoop int local 1
        /if (!${Me.CombatState.Equal[COMBAT]}) {
            | Wait for rampage pets to poof before pulling.
            /for i 0 to 20
                /if (${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /echo +++ My rampage pet is up: (${Spawn[${Me.CleanName}`s_pet0${i}]}|${Spawn[${Me.CleanName}`s_pet0${i}].ID}), HOLDING . . .
                /while (${DoLoop}) {
                    /delay 1
                    /if (!${Me.CombatState.Equal[COMBAT]} && ${Spawn[${Me.CleanName}`s_pet0${i}].ID}) /continue
                    /varset DoLoop 0
                }
            /next i
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: Pull
| -------------------------------------------------------------------------------------
    Sub Pull
        /if (${DMZ} && ${Me.InInstance}==FALSE) /return
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}==0) /return
        /if (!${Pulling}) /return
        /if (${DPSPaused} || ${Me.Invis}) /return
        /if (${PullHoldCond}) {
            /if (!${SpamTimer1}) {
                /echo Holding Pulls Due to Pull Hold Condition.
                /varset SpamTimer1 50
            }
            /return 0
        }
        DEBUGPULL Pull Enter
        /declare PullAttempts       int    local 0
        /declare StuckCount         int    local 0
        /declare PullDist           float  local ${PullRange}
        /declare AdvpathPaused      int    local 0
        /declare WPCurrent          int    local 0
        /declare AdvpathDirection   string local
        /declare X1                 int    local
        /declare Y1                 int    local
        /declare X2                 int    local
        /declare Y2                 int    local
        /declare AdjustHeadingTimer timer  local 0
        /declare WasInRange         int    local 0
        /declare PullStatusFlag     int    local 0
        /declare ReturnStat         string local 0
        /declare TryPetFirst        int    local 0
        /varset Pulled 0
        /varset PullTooFar 0
        /varset PullTimer 50
        /varset CantHit 0
        /varset ToClose 0
        /if (${Role.Equal[hunterpettank]}) /varset TryPetFirst 1
        | PullStatusFlag: 1-Normal Pull, 2-You are OOR Mob may be pullable, 3-Mob is OOR and may be pullable, 4-Don't even try pulling the mob, 5-I am OOR and I need to go back to camp.
        /if (${GroupWatchOn}) /call GroupWatch
        DEBUGPULL Pull: PullWith: ${PullWith} PullDist: ${PullDist} PullUsing: ${PullMoveUse}
        DEBUGPULL Check Ability: ${AggroTargetID} ${PullAggroTargetID} ${ChainPull} ${Select[${PullWith},Melee,Pet,Ranged]} ${Me.SpellReady[${PullWith}]} ${Me.AltAbilityReady[${PullWith}]} ${Me.CombatAbilityReady[${PullWith}]} ${Me.ItemReady[${PullWith}]} ${PullWith} ${PullWith.Equal[Ranged]} ${Me.RangedReady}
        | Set autofire setting off during pulls if not using ranged item to pull
        /if (${Me.AutoFire}) /autofire
        /if (${IAmABard}) {
            /if (!${PullTwistOn} && ${Twist}) /call CastBardCheck 0
        }
        /if (!${Me.Mount.ID} && (${Me.Sitting} || ${Me.Feigning})) /stand
        /if (${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}!=${Me.ID}) {
            /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X},${Spawn[${MyTargetID}].Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}>${CampRadius}) /call PullModeToggle TurnOn
        }
        /varset BeginMobID ${Me.XTarget[${XTSlot}].ID}
        /while (1) {
            /varset PullStatusFlag 1
            /varset ReturnStat 0
            /while (1) {
                /varset EventFlag 0
                /doevents
                /if (!${EventFlag}) /break
            }
            /if (${CorpseRecoveryOn}) {
                /if (!${DragCorpse} && ${SpawnCount[pccorpse ${Me} radius ${MaxRadius}]}) {
                    /call GrabCorpse 1
                    /if (${DragCorpse}) {
                        /return dcbtc
                    }
                }
            }
            /if (${DPSPaused}) /return
            | vars used to determine if we are stuck
            /varset X1 ${Int[${Me.X}]}
            /varset Y1 ${Int[${Me.Y}]}
            /if (${PullAggroTargetID}) {
                DEBUGPULL Pulling 1.1
                /varset Pulled 1
                /varset MyTargetID ${AggroTargetID}
                /varset MyTargetName ${Spawn[${AggroTargetID}].CleanName}
                /call StopMoving
                DEBUGPULL Pull Aggro detected
                /break
            }
            /if (((${AggroTargetID} && !${ChainPull}) || (${Me.XTarget[${XTSlot2}].ID} && ${ChainPull})) && ${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius}) {
                /echo Looks like mobs in camp aborting pull.
                /call PullReset
                DEBUGPULL Pull Mobs in camp detected
                /return micd
            }
            | Exit pull and reset if timed out or wandered too far from camp
            DEBUGPULL Pulling 1.2 PullTimer: ${PullTimer} Distance: ${Math.Distance[${CampYLoc},${CampXLoc}]} Distance3D: ${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} MaxRadius: ${Math.Calc[${MaxRadius}*.90]} PullAttempts: ${PullAttempts} MyTargetID: ${Spawn[${MyTargetID}].ID}  Target LOS: ${Spawn[${MyTargetID}].LineOfSight}
            /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X},${Spawn[${MyTargetID}].Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}>${Math.Calc[${MaxRadius}+${PullRange}]}) {
                /varset PullStatusFlag 4
            } else /if (${PullTimer}==0 || (${PullAttempts}>=7 && !${Spawn[${MyTargetID}].LineOfSight}) || !${Spawn[${MyTargetID}].ID}) {
                /varset PullStatusFlag 4
            } else /if (${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]} >= ${Math.Calc[${MaxRadius}*.95]}) {
                /varset PullStatusFlag 5
            }
            /if (${PullStatusFlag}!=1) {
                /varset ReturnStat btcr
            }
            /if (${PullWith.Equal[Ranged]}) {
                /call PullWithRanged ${PullDist} 0
            }
            | - Filter to prevent pulling until AA/Disc/Spell/Item is ready.
            DEBUGPULL Pull Starting ${PullDist} ${PullMoveUse} ${PullStatusFlag} ${ReturnStat}
            /varset PullAttempts 0
            | Set group role puller to adjust for merc running up while pulling if soloing
            /if (${Group}==1 && !${Group.Puller.Name.Equal[${Me}]} && ${Select[${Role},puller]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]}) /call AssignGroupRole set "${Me.CleanName}" 3
            /while (1) {
                /if (${PullStatusFlag}!=1) /break
|------------------------------------------------------------------------Pull Begin Move-------------------------------------------------------------------------------------------|
                /if ((${Spawn[${MyTargetID}].Distance3D}>${PullDist} || !${Spawn[${MyTargetID}].LineOfSight}) && ${Math.Distance[${Me.Y},${Me.X},${Me.Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}<${MaxRadius}) {
|------------------------------------------------------------------------MQ2AdvPath-------------------------------------------------------------------------------------------|
                    | Advpath pull does not use max pull radius. It uses pullwith radius
                    /if (${PullMoveUse.Equal[advpath]}) {
                        /call PullUsingAdvPath ${MyTargetID} ${PullDist}
                        /if (${Macro.Return.Equal[btcr]}) {
                            /varset ReturnStat btcr
                            /varset PullStatusFlag 2
                            /break
                        }
                        /if (!${MyTargetID}) /return 0
|------------------------------------------------------------------------MQ2Nav-------------------------------------------------------------------------------------------|
                    } else /if (${PullMoveUse.Equal[nav]}) {
                        /call PullUsingNav ${MyTargetID} ${PullDist}
                        /if (${Macro.Return.Equal[huntpr]}) { 
                            /varset ReturnStat btcr
                            /varset PullStatusFlag 5
                            /break
                        } else /if (${Macro.Return.Equal[btcr]}) {
                            /varset ReturnStat btcr
                            /varset PullStatusFlag 2
                            /break
                        } else /if (${Macro.Return.Equal[dcbtc]}) {
                            /return dcbtc
                        }
|------------------------------------------------------------------------LOS-------------------------------------------------------------------------------------------|
                    | We are pulling by LOS.
                    } else /if (${Spawn[${MyTargetID}].LineOfSight}) {
                        /if (${Me.FeetWet}) {
                            /if (${X2}==0) /varcalc PullDist ${PullDist}-(${Spawn[${MyTargetID}].Distance3D}-${Spawn[${MyTargetID}].Distance})
                            /moveto id ${MyTargetID} mdist ${PullDist} uw
                        } else {
                            /moveto id ${MyTargetID} mdist ${PullDist}
                        }
                        /delay 10
                        /varset X2 ${Int[${Me.X}]}
                        /varset Y2 ${Int[${Me.Y}]}
                        DEBUGPULL Pull LOS ${Spawn[${MyTargetID}].LineOfSight} ${PullDist}
|------------------------------------------------------------------------Mob OOR Return to Camp-------------------------------------------------------------------------------------------|
                    } else {
                        /if (${X2}!=0) {
                            /if (${Math.Distance[${Me.Y},${Me.X}:${Y2},${X2}]}>200 || ${PullTimer}==0) {
                                /echo Mob is no Longer in LOS. Returning to Camp.
                                /if (${MoveTo.Moving}) /moveto off
                                /varset ReturnStat btcr
                                /varset PullStatusFlag 4
                                /break
                            } else /if ((!${Me.Moving} || !${MoveTo.Moving}) && ${PullDist}<${Spawn[${MyTargetID}].Distance}) {
                                /if (${Me.FeetWet}) {
                                    /moveto id ${MyTargetID} mdist ${PullDist} uw
                                } else {
                                    /moveto id ${MyTargetID} mdist ${PullDist}
                                }
                                /delay 10
                            }
                        }
                        DEBUGPULL Pull NO-LOS ${Spawn[${MyTargetID}].LineOfSight} ${Spawn[${MyTargetID}].Distance3D} ${PullDist}
                    }
                } else /if (${Spawn[${MyTargetID}].Distance3D}<=${PullDist} && ${Spawn[${MyTargetID}].LineOfSight}) {
                    /varset PullStatusFlag 2
                    /break
                } else /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X},${Spawn[${MyTargetID}].Z}:${CampYLoc},${CampXLoc},${CampZLoc}]}>${Math.Calc[${MaxRadius}+${PullRange}]}) {
                    /varset PullStatusFlag 4
                    /varset ReturnStat btcr
                    /break                
                }
|------------------------------------------------------------------------End Pull Move-------------------------------------------------------------------------------------------|
                /if (${Pulled} || ${PullAggroTargetID}) /break
                /if (${Spawn[${MyTargetID}].Distance3D}<=${PullDist} && (${Target.FeetWet}==${Me.FeetWet} || ${PullWith.Equal[pet]})) /varset WasInRange 1
                /varset CantSee 0
                /while (1) {
                    /varset EventFlag 0
                    /doevents
                    /if (!${EventFlag}) /break
                }
                /varcalc PullAttempts ${PullAttempts}+1
                |Checking to see if you are far from camp to try and fix the exceed to far from camp check.
                /if (${Select[${PullMoveUse},los,nav]}>0) {
                    |Have I ran to far from camp?
                    /if (${Math.Distance[${CampYLoc},${CampXLoc},${CampZLoc}]}>=${Math.Calc[${MaxRadius}*.95]}) {
                        /if (${Spawn[${MyTargetID}].Distance3D}<=${PullDist} && (${Spawn[${MyTargetID}].LineOfSight} || ${PullWith.Equal[pet]})) {
                            /varset PullStatusFlag 2
                        } else {
                            /varset PullStatusFlag 4
                        }
                        /varset ReturnStat btcr
                        /break
                    }
                    | Extending PullTimer if moving closer or target moving && !${Select[${Role},hunter]}
                    /if (${PullMoveUse.Equal[nav]}) {
                        /if ((${Navigation.Active} || ${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed}>25 && ${Spawn[${MyTargetID}].Distance3D}>${PullRange}))) /varcalc PullTimer ${PullTimer}+50
                    } else /if (${PullMoveUse.Equal[los]} && !${Select[${Role},hunter,hunterpettank]}) {
                        /if ((${Me.Moving} || ${MoveTo.Moving} || (${Spawn[${MyTargetID}].Speed}>25 && ${Spawn[${MyTargetID}].Distance3D}>${PullRange}))) /varcalc PullTimer ${PullTimer}+50
                    }
                    | Try and pull again after 7 seconds or 3 seconds if target is moving
                    /if (${PullAttempts}>=7) {
                        | Make range smaller to creep closer to mob if not los
                        /if (${Spawn[${MyTargetID}].Distance3D}<=${PullDist} && !${Spawn[${MyTargetID}].LineOfSight} && ${PullWith.NotEqual[pet]}) /varcalc PullDist ${PullDist}*.6
                        DEBUGPULL Pull PullDist: ${PullDist} - PullLoops: ${PullAttempts} LineOfSight: ${Spawn[${MyTargetID}].LineOfSight}
                        /break
                    } else /if (${PullAttempts}>=3 && ${Spawn[${MyTargetID}].Speed}>25 && ${WasInRange} && ${Spawn[${MyTargetID}].Distance3D}>${PullDist}) {
                        | Make range smaller to creep closer to mob if Mob is Moving
                        /varcalc PullDist ${PullDist}*.6
                        /varset WasInRange 0
                        DEBUGPULL Pull PullDist: ${PullDist}*.6 - PullLoops: ${PullAttempts}
                        /break
                    }
                }
                /if (${DPSPaused}) /return
                | 1s timer used in conjunction with PullAttempts to control pulling
                /delay 10
|------------------------------------------------------------------------Are We Stuck-------------------------------------------------------------------------------------------|
                | - Check to see if we are stuck
                /if ((${Int[${Me.X}]}==${X1}) && (${Int[${Me.Y}]}==${Y1})) {
                    /varcalc StuckCount (${StuckCount})+1
                    /if (${StuckCount}>=2) {
                        /if (${IAmDead} || ${Me.Hovering}) {
                            /call Stopmoving
                            /return
                        } else {
                            /call Stuck pull
                        }
                    }
                    /if (${StuckCount}>=7 && !${PullAggroTargetID}) {
                        /echo I am stuck aborting pull
                        /call StopMoving
                        /varset ReturnStat btcr
                        /varset PullStatusFlag 4
                        /break
                    }
                }
|------------------------------------------------------------------------Are We Stuck End-------------------------------------------------------------------------------------------|
                DEBUGPULL Pull Loop Count: ${PullAttempts} ${Me.Moving} ${MoveTo.Moving} ${Me.Speed} ${Spawn[${MyTargetID}].Distance3D} ${PullRange} ${PullDist}
                | Not using advpath
                /if (${Select[${PullMoveUse},los,nav]}>0) {
                    | Distance loop check until mob in range to pull
                    /if ((${Spawn[${MyTargetID}].Distance3D}>${PullRange} || !${Spawn[${MyTargetID}].LineOfSight} || ${Target.FeetWet}!=${Me.FeetWet}) && !${PullAggroTargetID}) {
                        /if (${PullWith.NotEqual[pet]} || ${Spawn[${MyTargetID}].Distance3D}>${PullRange}) {
                        /if (!${Me.Moving} || ${WasInRange}) /varcalc PullDist ${PullDist}*.8
                            DEBUGPULL Pull Decrease pull distance to ${PullDist}
                            /continue
                        }
                    } else /if (${PullAggroTargetID}) {
                        /break
                    }
                }
                /varset PullStatusFlag 2
                /break
            | end of Inner /while loop.
            }
            /if (${Pulled} || ${PullAggroTargetID}) /break
            | Back To Camp Reset was flaged, but if target is not LOS, there is no reason to try and pull it. 
            /if (${ReturnStat.Equal[btcr]}) {
                /if (${PullStatusFlag}==4) /break
                /if (${PullWith.NotEqual[pet]}) {
                    /if (!${Spawn[${MyTargetID}].LineOfSight}) /break
                } else {
                    /if (${Spawn[${MyTargetID}].Distance3D}>${PullRange}) /break
                }
                /if (${PullStatusFlag}!=5) /varset ReturnStat 0
            }
            | We are not close enough to the mob to pull
            /if (${PullStatusFlag}==1) /continue
            | We are in pull range and have LOS.
            /if (${Spawn[${MyTargetID}].ID} && (${Target.FeetWet}==${Me.FeetWet} || ${PullWith.Equal[pet]}) && !${PullAggroTargetID} && (${Spawn[${MyTargetID}].Distance3D}<${PullRange} || (${PullWith.Equal[Melee]} && ${Spawn[${MyTargetID}].Distance3D}<${Math.Calc[${PullRange}*2]}))) {
                /if (${PullMoveUse.Equal[advpath]}) /varset WasInRange 1
                /call StopMoving
                | Target mob before Aggroing
                /target id ${MyTargetID}
                /delay 20 ${Target.ID}==${MyTargetID}
                | Validate target one more time before pulling
                /call ValidateTarget
                /if (${ValidTarget}==0) {
                    /echo Aborting Pull! Target invalid now! Reason:${Macro.Return}
                    /varset ReturnStat btcr
                    /break
                }
                |/if (${CalmOn}) {
                |    /call PullCalmCheck ${Target.ID} ${CalmRadius}
                |}
                /if (${PullWith.Equal[Ranged]} && ${Spawn[${MyTargetID}].Distance3D}<30) /varset ToClose 1
|------------------------------------------------------------------------Send in Pet-------------------------------------------------------------------------------------------|
                /if (${TryPetFirst} && ${Pet.ID} && ${Spawn[${MyTargetID}].Distance3D}<${MeleeDistance}) {
                    /if (${PullWith.NotEqual[Pet]}) /echo ====>> Sending in Pet. Ignoring PullWith.
                    |/echo 1 - ${Pet.Combat}
                    /call CombatPet
                    |/echo 2 - ${Pet.Combat}
                    /if (!${Pet.Combat}) {
                        /if (${PullWith.NotEqual[Pet]}) /echo ====>> Sending in Pet Failed. Trying normal PullWith Option. 
                        /varset TryPetFirst 0
                        /continue
                    }
                    /if (${PullAggroTargetID} || ${Pet.Combat}) /varset Pulled 1
|------------------------------------------------------------------------Pull with Melee-------------------------------------------------------------------------------------------|
                | Handle pulling with Melee setting
                } else /if (${PullWith.Equal[Melee]} || (${PullWithAlt.Equal[Melee]} && ${ToClose} && !${Select[${Role},hunter,hunterpettank]})) {
                    /call PullWithMelee
|------------------------------------------------------------------------Pull with Ranged-------------------------------------------------------------------------------------------|
                | Pull with ranged
                } else /if (${PullWith.Equal[Ranged]} && !${ToClose}) {
                    /call PullWithRanged ${PullDist} 1
                    /if (${Macro.Return}>=1) /varset PullDist ${Int[${Macro.Return}]}
|------------------------------------------------------------------------Pull with Pet-------------------------------------------------------------------------------------------|
                | Pull with pet
                } else /if (${PullWith.Equal[Pet]}) {
                    /call PullWithPet
|------------------------------------------------------------------------Pull with Cast-------------------------------------------------------------------------------------------|
                | Pull with cast
                } else {
                    /call PullWithCast ${PullDist}
                    /if (${Macro.Return}>=1) {
                        /varset PullDist ${Int[${Macro.Return}]}
                        |/continue
                    }
                }
|------------------------------------------------------------------------Pull with End-------------------------------------------------------------------------------------------|
                |- Toggle puller mode off if option enabled.
                /if (${Select[${Role},pullerpettank]} && ${PullRoleToggle} && ${Group.Puller.ID}==${Me.ID}) /call PullModeToggle TurnOff
            } else /if (${PullAggroTargetID}) {
                | The else /if fixes when puller stalls because puller grabs aggro with out getting to pull.
                /varset Pulled 1
            } else /if (${PullStatusFlag}==3 || ${PullStatusFlag}==5) {
                /break
            }
            | If pull failed start over while timer > 0
            /if (${Select[${PullMoveUse},los,nav]}>0 && !${Pulled}) /continue
            /break
        | end of outer /while loop
        }
        | reset mq2moveutils dist back to 10 from pull distance to ensure correct movement
        /moveto dist 10
        /if (!${Pulled} && ${PullAggroTargetID}) {
            /varset Pulled 1
            /varset ReturnStat 0
        }
        /if (${PullWith.Equal[Ranged]}) {
            /call PullWithRanged ${PullDist} 2
        }
        /varset Pulling 0
        /if (${ReturnStat.Equal[btcr]}) {
            /if (${MyTargetID}) {
                /call PullIgnoreCheck ${MyTargetID} a pull2
                /varset MyTargetID 0
            } else /if (${Target.ID}) {
                /call PullIgnoreCheck ${Target.ID} a pull3
                /squelch /target clear
            }
            |/echo I Got Here: ----------> ${PullOnReturn} 
            /if (!${PullOnReturn}) {
                /call BackToCampReset
                /if (${Macro.Return}) /return 0
            } else {
                /return oor
            }
        }
        DEBUGPULL Pull Done Pulling ${ReturnToCamp} ${Pulled} ${PullAggroTargetID}
        /if (${ReturnToCamp}) {
            /if (${Pulled}) {
                /call DoWeMove 1 pull
                /if (${Macro.Return.Equal[iad]}) /return IAD 
                /if (!${Me.Running}) /nomodkey /keypress RUN_WALK
                /if (${Macro.Return.Equal[lma]}) {
                    /varset Pulled 0
                    /echo Returned To Pull: lma 
                    /return lma
                }
                /call WaitForMob
                /if (${Target.ID} && ${FaceMobOn}==3) /face fast nolook
                /varset Pulled 0
            } else {
                /call DoWeMove 1 pull
            }
        }
        DEBUGPULL Pull Leave Mob ID:${Spawn[${MyTargetID}].ID}
    /return
|--------------------------------------------------------------------------------------
| SUB: PullCalmCheck
|--------------------------------------------------------------------------------------
    Sub PullCalmCheck(int PCCTarget, int PCCRadius)
        /if (!${PCCRadius}) /varset PCCRadius 50
    /return
|--------------------------------------------------------------------------------------
| SUB: PullIgnoreCheck
|--------------------------------------------------------------------------------------
    Sub PullIgnoreCheck(string mobID, string Action, string sentFrom)
        /declare k int     local     0
        /if (${Int[${mobID}]}<1) /return
        /if (${Action.Equal[a]}) {
            /if (!${PullIgnore1.Find[${mobID}|]}) {
                /if (${SearchType.Equal[noalert 1]}) /squelch /alert add 1 id ${mobID}
                /varset PullIgnore1 ${mobID}|${PullIgnore1}
                /echo Added ${mobID} to ignore pull list. ${PullIgnore1} ${sentFrom}
            }
        } else /if (${Action.Equal[d]}) {
            /if (!${PullIgnore1.Find[${mobID}|]}) {
                /varset PullIgnore1 ${PullIgnore1.Replace[${mobID}|,]}
                /if (${SearchType.Equal[noalert 1]}) /squelch /alert remove 1 id ${mobID}
            }
        } else /if (${Action.Equal[c]}) {
            /varset k 1
            /while (${PullIgnore1.Arg[${k},|].Length} && ${PullIgnore1.Find[|]} && ${PullIgnore1.NotEqual[null]}) {
                DEBUGPULL PullIgnore: ${PullIgnore1} Count: ${k} Arg: ${PullIgnore1.Arg[${k},|]}
                /if ((!${Spawn[id ${PullIgnore1.Arg[${k},|]}].ID} || ${Spawn[${PullIgnore1.Arg[${k},|]}].Type.Equal[Corpse]}) && ${PullIgnore1.Arg[${k},|].NotEqual[null]}) {
                    /varset PullIgnore1 ${PullIgnore1.Replace[${PullIgnore1.Arg[${k},|]}|,]}
                    /if (${SearchType.Equal[noalert 1]}) /squelch /alert remove 1 id ${PullIgnore1.Arg[${k},|]}
                } else {
                    /varcalc k ${k}+1
                }
            }
        }
    /return
|--------------------------------------------------------------------------------------
| SUB: BacktoCampReset
|--------------------------------------------------------------------------------------
    Sub BacktoCampReset
        DEBUGPULL BacktoCampReset: Enter
        /if (${ReturnToCamp}) {
            /call DoWeMove 0 backtocampreset
        } else /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < ${CampRadius} || ${Select[${Role},hunter,hunterpettank]}) {
            /call PullReset
            /call DoWeMove 1 backtocampreset
            /return TRUE
        }
        DEBUGPULL BacktoCampReset: Leave
    /return 0
|--------------------------------------------------------------------------------------
| SUB: Stop Moving
|--------------------------------------------------------------------------------------
    Sub StopMoving
        DEBUGMOVE StopMoving: Enter
        /if (${MoveTo.Moving}) /moveto off
        /if (${Stick.Active}) /stick off
        /if (${PullMoveUse.Equal[nav]}) {
            /if (${Navigation.Active}) /nav stop
        } else /if (${PullMoveUse.Equal[advpath]}) {
            /if (${AdvPath.State}) /play off
        }
        /delay 30 !${Me.Moving}
        DEBUGMOVE StopMoving: Leave
    /return
|--------------------------------------------------------------------------------------
| SUB: Pull with Melee
|-------------------------------------------------------------------------------------
    Sub PullWithMelee
        DEBUGPULL PullWithMelee: Enter
        | Turn off mq2melee function so puller and pullertank doesn't attack mob on pull
        /if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) /squelch /melee melee=0
        /moveto id ${MyTargetID} mdist 15
        /delay 10
        /while (1) {
            /if (${PullAggroTargetID} || ${Target.PctHPs}<100) /break
            /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
            /look 0
            /if (${Target.MaxRangeTo}>=${Target.Distance3D}) {
                /if (!${Me.Moving}) {
                    /moveto id ${MyTargetID} mdist ${If[${MoveTo.ArrivalDist}>5,${Math.Calc[${MoveTo.ArrivalDist}-5]},1]}
                    /if (${PullMeleeStick} && !${PullAggroTargetID}) /stick ${MoveTo.ArrivalDist} front
                } else {
                    /moveto mdist ${If[${MoveTo.ArrivalDist}>5,${Math.Calc[${MoveTo.ArrivalDist}-5]},1]}
                    /if (${PullMeleeStick} && !${PullAggroTargetID}) /stick ${MoveTo.ArrivalDist} front
                }
                /if (!${Stick.Active} && ${PullMeleeStick} && !${PullAggroTargetID}) /stick ${MoveTo.ArrivalDist} id ${MyTargetID} front
            } else {
                /if (!${Me.Moving}) {
                    /moveto id ${MyTargetID} mdist ${If[${MoveTo.ArrivalDist}>5,${Math.Calc[${MoveTo.ArrivalDist}-5]},1]}
                    /if (${PullMeleeStick} && !${PullAggroTargetID}) /stick ${MoveTo.ArrivalDist} front
                }
            }
            /squelch /attack on
            /delay 10
            /if (${PullAggroTargetID} || ${Target.PctHPs}<100) /break
        }
        | Turn off combat so puller returns to camp. You mean run like hell.
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunterpettank]}) {
            /attack off
            /if (${Stick.Active}) /stick off
            /squelch /target clear
            | Turn on mq2melee function back on after pull
            /if (${Select[${Role},puller,pullertank]} && ${UseMQ2Melee}) /squelch /melee melee=1
        }
        /varset Pulled 1
        /varset ToClose 0
        DEBUGPULL PullWithMelee: Leave
    /return
|-------------------------------------------------------------------------------------
| SUB: Pull With Ranged
|-------------------------------------------------------------------------------------
    Sub PullWithRanged(int PullDistRanged,int RSwitch)
        DEBUGPULL PullWithRanged: Enter
        /declare TryCount int local 0
        /declare AmmoCount int local 0
        DEBUGPULL PullWithRanged: Ranged
        | Cursor check sometimes summoned items get stuck on cursor.
        /if (${Cursor.ID}) /call CheckCursor 0
        /if (${RSwitch}==0) {
            /if (${Me.Inventory[ranged].Name.NotEqual[${PullItem}]}) {
                /exchange "${PullItem}" ranged
                /varset RangedSwitch 1
            }
            /if (${Me.Inventory[ammo].Name.NotEqual[${PullAmmo}]}) {
                /exchange "${PullAmmo}" ammo
                /if (${TempAmmo.NotEqual[${PullAmmo}]}) /varset AmmoSwitch 1
            }
        } else /if (${RSwitch}==1) {
            /while (1) {
                /varcalc TryCount ${TryCount}+1
                /while (1) {
                    /varset EventFlag 0
                    /doevents
                    /if (!${EventFlag}) /break
                }
                /if (${DPSPaused}) /return
                /if (${PullAggroTargetID}) {
                    /varset Pulled 1
                    /return
                }
                /if (${CantSee}) {
                    /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
                    /delay 10
                    /varset CantSee 0
                    DEBUGPULL Could Not see Target. Trying Again.
                }
                | Mod for puller to turn back to camp after /range this saves on the puller turning AFTER mob is aggroed and turns facing camp while waiting for mob to aggro.
                /if (${Me.Combat}) {
                    /Attack off
                    /delay 20 !${Me.Combat}
                }
                /if (${Stick.Active}) /stick off
                /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
                /look 0
                /varset AmmoCount ${FindItemCount[=${PullAmmo}]}
                /delay 30 ${Me.Heading.ShortName.Equal[${Target.HeadingTo}]}
                /if (${Target.ID}==${MyTargetID} && ${Target.Distance3D}>=30) {
                    | This is where we would call the Pacification code.
                    |/echo Distance From Target: ${Target.Distance3D} ${PullDistRanged}
                    /while (${AmmoCount}==${FindItemCount[=${PullAmmo}]} && !${PullAggroTargetID} && ${Target.Distance3D}>=30 && ${Target.LineOfSight} && ${Target.FeetWet}==${Me.FeetWet}) {
                        /range
                        /doevents TooClose
                        /if (${ToClose}) {
                            /varset PullDistRanged 15
                            /return ${PullDistRanged}
                        }
                        /doevents CantHit
                        /if (${CantHit}) {
                            /varset CantHit 0
                            /varcalc PullDistRanged ${PullDistRanged}*.8
                            /return ${PullDistRanged}
                        }
                        /doevents TooFar
                        /if (${PullTooFar}) {
                            /varset PullTooFar 0
                            /varcalc PullDistRanged ${PullDistRanged}*.8
                            /return ${PullDistRanged}
                        }
                    }
                }
                /if (${Math.Distance[${CampYLoc},${CampXLoc}]} > ${CampRadius}) {
                    /delay 10 ${PullAggroTargetID}
                    /if (${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]} loc ${CampYLoc},${CampXLoc}
                }
                /if (!${PullAggroTargetID}) {
                    /delay ${Math.Calc[1+${Target.Distance}/50].Int}s ${PullAggroTargetID}
                    /varcalc PullTimer ${PullTimer}+10
                }
                DEBUGPULL Pull: ${PullTimer} !${PullAggroTargetID} ${Target.PctHPs}==100
                /if (!${PullTimer} || ${TryCount}>2 || ${PullTooFar} || ${PullAggroTargetID}) /break
            }
            /if (${PullAggroTargetID}) {
                /varset Pulled 1
                /return
            }
        } else /if (${RSwitch}==2) {
            /if (${Cursor.ID}) /call CheckCursor PullWithRanged 0
            /if (${OrigRanged.NotEqual[null]} && ${Me.Inventory[ranged].Name.NotEqual[${OrigRanged}]}) {
                /exchange "${OrigRanged}" ranged
                /varset RangedSwitch 0
            }
            /if (${TempAmmo.NotEqual[null]} && ${Me.Inventory[ammo].Name.NotEqual[${TempAmmo}]}) {
                /exchange "${TempAmmo}" ammo
                /varset AmmoSwitch 0
            }
        }
        DEBUGPULL PullWithRanged: Leave
    /return
|-------------------------------------------------------------------------------------
| SUB: Exchange Item.
|-------------------------------------------------------------------------------------
    Sub ExchangeItem(string prm_Item, string prm_exToSlot, int prm_deleteFlag, int prm_autoInvFlag, int prm_autoAttuneFlag)
        /declare int_slotNo1 int local 0
        /declare int_slotNo2 int local 0
        /declare str_slotName1 string local
        /declare str_slotName2 string local
        /declare tim_timer1 timer local 0
        /declare bol_attuneable bool local false
        /declare bol_noTrade bool local false
        /if (!${FindItemCount[=${prm_Item}]}) /return
        DEBUG ExchangeItem: Enter ${prm_Item} ${prm_exToSlot} ${prm_autoInvFlag}
        /if (${Cursor.ID}) /call CheckCursor ExchangeItem
        /if (${Cursor.ID}) {
            /beep 
            /echo Your Inventory is full. This process needs open inventory slots for this to work.
            /return
        }
        /if (!${Select[${prm_exToSlot},charm,leftear,head,face,rightear,neck,shoulder,arms,back,leftwrist,rightwrist,ranged,hands,mainhand,offsand,leftfinger,rightfinger,chest,legs,feet,waist,powersource,ammo]}) {
            /echo Invalid Item slot ${prm_exToSlot}, must be valid Equipment/Armor slot.
            /return
        }
        /if (${Me.Inventory[${prm_exToSlot}].Name.Equal[${prm_Item}]}) {
            /echo You already have item ${prm_Item} equiped.
            /return
        }
        /varcalc int_slotNo1 ${Int[${FindItem[=${prm_Item}].ItemSlot}]}
        /if (${int_slotNo1}>32) {
            /echo Item ${prm_Item} is not in your characters Inventory.
            /return
        } else /if (${int_slotNo1}<23) {
            /echo Item is already equiped in slot number ${int_slotNo1}
            /return
        }
        /if (${Me.Inventroy[${int_slotNo1}].Container}) {
            /varcalc int_slotNo2 ${Int[${FindItem[=${prm_Item}].ItemSlot2}]}+1
        } else {
            /varset int_slotNo2 0
        }
        /varcalc int_slotNo1 ${int_slotNo1}-22
        | Check if there is an item in the target Slot we are exchanging to.
        /if (${Me.Inventory[${prm_exToSlot}].ID}) {
            /varset str_slotName1 ${Me.Inventory[${prm_exToSlot}].Name}
        } else {
            /varset str_slotName1 null
        }
        |Pick up item on cursor
        /if (${int_slotNo2}) {
            /nomodkey /itemnotify in pack${int_slotNo1} ${int_slotNo2} leftmouseup
        } else {
            /nomodkey /itemnotify pack${int_slotNo1} leftmouseup
        }
        | Wait for item to show on cursor.
        /varset tim_timer1 20
        /while (!${Cursor.ID} && ${tim_timer1}) {
            DOPARSE
            /delay 5
        }
        /if (!${Cursor.ID}) {
            /echo Could Not pick up the item ${prm_Item}. Exiting.
            /return
        } else {
            /varset bol_noTrade ${Cursor.NoDrop}
            /varset bol_attuneable ${Cursor.Attunable}
        }
        |Put Item in Target Slot.
        /nomodkey /itemnotify ${prm_exToSlot} leftmouseup
        /if (${bol_attuneable} && !${bol_noTrade}) /delay 10
        | If item is attuneable then lets attune it.
        /if (${bol_attuneable} && ${Cursor.ID}) {
            /delay 20 ${Window[confirmationdialogbox].Open}
            /if (${Window[confirmationdialogbox].Open}) {
                /if (${prm_autoAttuneFlag}) {
                    /notify confirmationdialogbox CD_Yes_Button leftmouseup
                } else {
                    /notify confirmationdialogbox CD_No_Button leftmouseup
                }
                /delay 20 !${Window[confirmationdialogbox].Open}
            }
        }
        | Wait for cursor to refresh with an item or nothing.
        /varset tim_timer1 20
        /if (${str_slotName1.NotEqual[null]}) {
            /while (${Cursor.Name.NotEqual[${str_slotName1}]} && ${tim_timer1}) {
                DOPARSE
                /delay 5
            }
        } else {
            /delay 10
        }
        |If this was exchanged with another item, then put the item in the originating slot.
        /if (${Cursor.Name.Equal[${str_slotName1}]}) {
            /if (${int_slotNo2}) {
                /nomodkey /itemnotify in pack${int_slotNo1} ${int_slotNo2} leftmouseup
            } else {
                /nomodkey /itemnotify pack${int_slotNo1} leftmouseup
            }
            /delay 10
        }
        | If item stuck on cursor lets drop it in inventory.
        /if (${Cursor.ID}) /autoinventory
        DEBUG ExchangeItem: Leave
    /return
|-------------------------------------------------------------------------------------
| SUB: Pull With Casting
|-------------------------------------------------------------------------------------
    Sub PullWithCast(int PullDistCast)
        DEBUGPULL PullWithCast Enter
            DEBUGPULL PullWithCast: Casting to pull mob
            /if (${Me.Moving}) /call StopMoving
            /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
            /look 0
            /while (1) {
                /if (${PullAggroTargetID}) {
                    /varset Pulled 1
                    /return
                }
                /if (!${Spawn[${MyTargetID}].LineOfSight}) {
                    /varcalc PullDistCast ${PullDistCast}*.8
                    /return ${PullDistCast}
                }
                /if (!${Me.Moving}) /call CastWhat "${PullWith}" ${Target.ID} Pull 0 0
                /if (${Macro.Return.Equal[CAST_FIZZLE]}) /continue
                /if (${Macro.Return.Equal[CAST_SUCCESS]} || ${Macro.Return.Equal[CAST_RESISTED]} || ${PullAggroTargetID}) /varset Pulled 1
                /delay 10 ${PullAggroTargetID}
                /break
            }
        DEBUGPULL PullWithCast: Leave
    /return
|-------------------------------------------------------------------------------------
| SUB: Pull With Pet Written by TreeHuginDruid for RedGuides
|-------------------------------------------------------------------------------------
    Sub PullWithPet(int BeginMobID,float petPullDist)
        DEBUGPULL PullWithPet: Enter
        /declare int_petMoving    int local 0
        /declare int_triedSending int local 0
        /if (${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
        |- Ensure we are in pull range and pet is following!
        /if (${Me.Pet.Stance.NotEqual[FOLLOW]}) /pet follow
        | - Send in pet if I don't have a mob in extended target
        /echo Pulling with PET now !
        /while (!${PullAggroTargetID}) {
            | Send in the Pet and monitor his movement.
            /if (!${int_petMoving}) /pet attack
            /delay 10 ${PullAggroTargetID}
            /if (${PullAggroTargetID}) {
                /break
            } else {
                | Is the pet moving?
                /if (${Me.Pet.Moving}) {
                    /varset int_petMoving 1
                    /varset int_triedSending 0
                } else {
                    /varset int_petMoving 0
                    /varcalc int_triedSending ${int_triedSending}+1 
                }
            }
            | Fix for HunterPetTank
            /if (!${Spawn[${MyTargetID}].ID} || ${Spawn[${MyTargetID}].Type.Equal[corpse]}) /break
            /if (${Spawn[${BeginMobID}].Distance3D}>${petPullDist}) /break
            /if (${int_triedSending}>2) /break
        }
        | - If I have a extended target, flag as pulled.
        /if (${PullAggroTargetID}) {
            /varset Pulled 1
        }
        /if (${PetHoldOn}) /pet ${PetHold} on
        /pet back off
        DEBUGPULL PullWithPet: Leave
    /return
|-------------------------------------------------------------------------------------
| SUB: Pull Using MQ2Nav || (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${PullNavDistance}) fix spwn dist from camp not mine.
| -------------------------------------------------------------------------------------
    Sub PullUsingNav(int BeginMobNavID,float NavPullDist)
        DEBUGPULL PullUsingNav Enter Pulling ${Spawn[${BeginMobNavID}].Name} ${NavPullDist} ${Target.Distance}
        /varset PullTimer 30
        /declare PullNavTimer timer local 3m
        /varset PullNavDistance ${Navigation.PathLength[id ${BeginMobNavID}]}
        /nav id ${BeginMobNavID}
        /while (1) {
            /while (1) {
                /varset EventFlag 0
                /doevents
                /if (!${EventFlag}) /break
            }
            | Check if puller has corpse from dying on previous pull along path
            /if (${CorpseRecoveryOn}) {
                /if (!${DragCorpse} && ${SpawnCount[pccorpse ${Me} radius 89]}) {
                    /call GrabCorpse 2
                    /if (${DragCorpse}) {
                        DEBUGPULL PullUsingNav Leave found my corpse
                        /return dcbtc
                    }
                }
            }
            |Internal loop delay 1 second. No reason to loop faster than 1 second. Unless you have Bard speed on. Zooooooooooommm
            /delay 4
            | Corrects heading when mob is moving and your using Navigation.
            /if (${Spawn[${BeginMobNavID}].Speed}>25) {
                /if ((${Role.Equal[hunter]} || ${PullWith.Equal[melee]}) && ${Spawn[id ${BeginMobNavID}].LineOfSight}) {
                    /if (!${Stick.Active} && ${Target.Distance}<20) {
                        /if (${Navigation.Active}) /nav stop
                        /moveto id ${Target.ID} mdist ${NavPullDist}
                        /stick ${NavPullDist} id ${Target.ID}
                        /return 0
                    }
                }
            }
            | Check for Unexpected Aggro
            /if (!${ChainPull}) {
                /if (${AggroTargetID}) {
                    /if (${Navigation.Active}) /nav stop
                    /return 0
                }
            } else {
                /if (${Me.XTarget[${XTSlot2}].ID}) /return 0
                /if (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID}) /return 0
            }
            | Check for being to far from camp lose MyTargetID or path
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${Math.Calc[${MaxRadius}*.95]} || ${PullNavTimer}==0 || !${Spawn[${BeginMobNavID}].ID} || ${Navigation.PathLength[id ${BeginMobNavID}]}<0.01) {
                /echo We have exceeded max pulling radius or timer or lost path to mob. Returning to camp.
                /if (${Navigation.Active}) /nav stop
                /if (${Math.Distance[${Spawn[${BeginMobNavID}].Y},${Spawn[${BeginMobNavID}].X}:${CampYLoc},${CampXLoc}]}>=${Math.Calc[${MaxRadius}*.95]}) {
                    /call PullIgnoreCheck ${BeginMobNavID} a PullUsingNav
                }
                DEBUGPULL PullUsingNav Leave Max radius/no timer/no mob/nopath  (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${Math.Calc[${MaxRadius}*.95]} && ${Spawn[${BeginMobNavID}].Speed}>25) || (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${PullNavDistance}) || ${PullNavTimer}==0 || !${Spawn[${BeginMobNavID}].ID} || ${Navigation.PathLength[id ${BeginMobNavID}]}<0.01
                /if (${Select[${Role},hunter,hunterpettank]}) {
                    /call PullReset
                    /return huntpr
                } else {
                    /return btcr
                }
            }
            | Keep timer from main Pull sub alive
            /if (${Me.Moving} && ${Navigation.Active}) /varset PullTimer 30
            /if (${Spawn[${BeginMobNavID}].Distance3D}>${NavPullDist} || !${Spawn[${BeginMobNavID}].LineOfSight} || ${Spawn[${BeginMobNavID}].FeetWet}!=${Me.FeetWet}) {
                /if (${PullWith.NotEqual[pet]} || ${Spawn[${BeginMobNavID}].Distance3D}>${NavPullDist}) {
                    /if (!${ChainPull} && !${AggroTargetID}) /continue
                    /if (${ChainPull}) {
                        /if (!${Me.XTarget[${XTSlot2}].ID}) {
                            /if (!${Me.XTarget[${XTSlot}].ID}) /continue
                            /if (${Me.XTarget[${XTSlot}].ID}==${BeginMobID}) /continue
                            /if (${Me.XTarget[${XTSlot}].ID}!=${BeginMobNavID}) /continue
                        }
                    }
                }
            }
            /if (${Navigation.Active}) /nav stop
            /if (${PullWith.NotEqual[pet]} && !${Spawn[${BeginMobNavID}].LineOfSight} && ${Target.Distance}>20) {
                /squelch /nav id ${BeginMobNavID}
                /continue
            }
            /break
        }
        DEBUGPULL PullUsingNav Leave
    /return 0
|-------------------------------------------------------------------------------------
| SUB: Pull Using AdvPath
| -------------------------------------------------------------------------------------
    Sub PullUsingAdvPath(int BeginMobAPID,float APPullDist)
        /declare ReturnStat string local 0
        DEBUGPULL PullUsingAdvPath Enter
        /if (${MoveTo.Moving}) /moveto off
        /play ${PullPath} nodoor smart normal
        DEBUGPULL PullUsingAdvPath /play ${PullPath} nodoor smart normal
        /while (1) {
            /if (${DebugPull}) /delay 5
            DEBUGPULL PullUsingAdvPath /echo Waypoint: ${AdvPath.NextWaypoint} Target: ${Target.ID} MyTargetID: ${MyTargetID} Aggro: ${AggroTargetID} MobToWPDist: ${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}<${APPullDist} MeToWPDist: ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}>50 WP<NWP: ${AdvPath.NextWaypoint}>=${AdvpathPointNum}
            | Do we have aggro?
            /if (${AggroTargetID}) /break
            | Has the mob move out of range from the original way point
            /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${AdvpathPointY},${AdvpathPointX}]}>${APPullDist}) /return btcr
            | Is mob within pull range and LOS
            /if (${Math.Distance[${Spawn[id ${MyTargetID}].Y},${Spawn[id ${MyTargetID}].X}:${Me.Y},${Me.X}]}<${APPullDist} && ${Spawn[${MyTargetID}].LineOfSight} && ${Target.FeetWet}==${Me.FeetWet}) /break
            | Stop at our waypoint
            /if (${AdvPath.NextWaypoint}>=${AdvpathPointNum} && ${Math.Distance[${Me.Y},${Me.X}:${AdvpathPointY},${AdvpathPointX}]}<=5) /return btcr
        }
        /play off
        DEBUGPULL PullUsingAdvPath /play ${PullPath} nodoor smart normal
        DEBUGPULL PullUsingAdvPath Leave ${AdvPath.NextWaypoint} ${ReturnStat}
    /return ${ReturnStat}
| -------------------------------------------------------------------------------------
| SUB: Wait for Mob
| -------------------------------------------------------------------------------------
    Sub WaitForMob
        /declare MobsInCamp int local 0
        /if (${Select[${Role},hunter,hunterpettank]} || ${DPSPaused}) /return
        DEBUGPULL WaitForMob Enter
        /varset WaitTimer 45s
        /if (${Pulled}) {
            DEBUGPULL WaitForMob Waiting for mob
            /if (${ChainPull}) /varset LastMobPullID ${Target.ID}
            /if (${Me.Inventory[ranged].Name.NotEqual[${OrigRanged}]} && ${OrigRanged.NotEqual[null]}) {
                /exchange "${OrigRanged}" ranged
            }
            | When you target a mob and another mob aggros you, but your target never gets aggroed.
            /if (${PullAggroTargetID} && ${Target.ID}!=${PullAggroTargetID} && ${Target.AggroHolder.ID}==0) {
                /target id ${AggroTargetID}
            }
            /while (1) {
                /if (${FaceMobOn} && ${Target.ID} && (${Me.Standing} || ${Me.Mount.ID})) {
                    /if (${FaceMobOn}==1) {
                        /face fast nolook
                    } else /if (${FaceMobOn}==2) {
                        /face nolook
                    }
                }
                /while (1) {
                    /varset EventFlag 0
                    /doevents
                    /if (!${EventFlag}) /break
                }
                | Did the GotHit event trigger, if it did MyTargetID will be zero.
                /if (!${MyTargetID}) {
                    /call CombatTargetCheck
                    /if (!${MyTargetID}) /varset MyTargetID ${AggroTargetID}
                }
                /call MobRadar los ${CampRadius} WaitForMob
                | If NOT chain pulling and multiple mobs in camp. /return
                /if (${MobCount}>=2 && !${ChainPull}) {
                    /call PullReset
                    /return
                }
                DEBUGPULL - WaitTimer: ${WaitTimer} Target Distance: ${Target.Distance} Mob Dist from Camp: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${CampYLoc},${CampXLoc}]}>=${CampRadius} Mob Dist from tank: ${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Me.Y},${Me.X}]}>=20
                | if target lost somehow add to ignore list and continue pulls
                /if (!${AggroTargetID} || ${WaitTimer}==0) {
                    DEBUGPULL WaitForMob return no AggroTargetID
                    /if (${Target.ID}) /call PullIgnoreCheck ${Target.ID} a waitformob
                    /call PullReset
                    /return
                }
                /delay 5
                /varset MobsInCamp ${SpawnCount[xtarhater loc ${CampXLoc} ${CampYLoc} radius ${MeleeDistance} zradius ${MaxZRange}]}
                /if (${Select[${Role},pullertank]}) {
                    | Wait in camp for mob if timer active and mob is outside of camp radius and mob is farther away from tank than 20 feet
                    /if (${WaitTimer} && !${MobsInCamp}) /continue
                } else /if (${Select[${Role},puller]}) {
                    | If I am PULLER and NOT chain pulling
                    /if (!${ChainPull}) {
                        /if (!${MobsInCamp} && !${SpawnCount[xtarhater loc ${Spawn[=${MainAssist}].X} ${Spawn[=${MainAssist}].Y} radius 20 zradius ${MaxZRange}]}) /continue
                        /if (${MercOn} && ${MercAssisting}!=${MyTargetID} && ${Mercenary.State.Equal[Active]}) /call MercsDoWhat
                    } else {
                        | If I am PULLER and chain pulling
                        | Leave if multi mobs or no mobs
                        /if (${MobsInCamp}>1 || !${MyTargetID} || (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot2}].ID})) {
                            /call PullReset
                            /return
                        }
                        /if (${Math.Distance[${Spawn[${MyTargetID}].Y},${Spawn[${MyTargetID}].X}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}>20 && ${Target.ID}==${Spawn[${MyTargetID}].ID} && ${Me.TargetOfTarget.ID}==${Me.ID}) /continue
                    }
                } else /if (${Select[${Role},pullerpettank]}) {
                    | I am PULLER with PET TANK
                    |- Make sure pet is returning to camp with me.
                    /if (${Me.Pet.ID} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && ${Math.Distance[${Me.Pet.Y},${Me.Pet.X}:${Me.Y},${Me.X}]}>20) {
                        /pet back off
                        /delay 5
                        /pet follow
                    }
                    | If the mob is within pet attack distance from camp send the pet in to attack
                    /if (!${SpawnCount[xtarhater targetable loc ${CampXLoc} ${CampYLoc} radius ${PetAttackRange} zradius ${MaxZRange}]}) {
                        /continue
                    } else {
                        /varset MyTargetID ${NearestSpawn[1,xtarhater targetable loc ${CampXLoc} ${CampYLoc} radius ${PetAttackRange} zradius ${MaxZRange}].ID}
                    }
                    |/if (!${PetAttack}) /call CombatPet
                    /if (!${Pet.Combat}) /call CombatPet
                }
                /break
            }
        }
        /if (${Group}==1 && ${Select[${Role},puller]} && ${Group.Puller.Name.Equal[${Me}]} && ${Spawn[=${MainAssist}].Type.Equal[Mercenary]} && ${Spawn[${MyTargetID}].Distance}<=${MeleeDistance}) /call AssignGroupRole unset "${Me.CleanName}" 3
        /if (${MyTargetID} && !${PullAggroTargetID}) /call PullReset
        /if (${IAmABard}) /call DoBardStuff
        /varset WaitTimer 0
        /call MercsDoWhat
        DEBUGPULL WaitForMob Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Reset Pull variables
| -------------------------------------------------------------------------------------
    Sub PullReset
        DEBUGPULL PullReset Enter
        /moveto dist 10
        /varset Pulling 0
        /varset Pulled 0
        /varset MyTargetID 0
        /varset MyTargetName
        /varset ToClose 0
        /attack off
        /if (${MoveTo.Moving}) /moveto off
        /if (${PullMoveUse.Equal[nav]}) {
            /if (${Navigation.Active}) /nav stop
        }
        /varset WaitTimer 0
        /varset DragCorpse 0
        /squelch /target clear
        DEBUGPULL PullReset Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: PullModeToggle
| -------------------------------------------------------------------------------------
    Sub PullModeToggle(ToggleState)
        /if (!${Select[${Me},${Group.Leader}]} || !${SpawnCount[group mercenary]}) /return
        /if (${ToggleState.Equal[TurnOn]}) {
            /while (${Target.Distance}>${CampRadius} && ${Group.Puller.ID}!=${Me.ID}) {
                /if (${Group.Puller.ID}!=${Me.ID}) /grouproles set ${Me.CleanName} 3
                /delay 10 ${Group.Puller.ID}==${Me.ID}
                /if (${Group.Puller.ID}==${Me.ID}) /echo + You have been set to be group puller.
            }
        } else /if (${ToggleState.Equal[TurnOff]}) {
            /while (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} || ${Group.Puller.ID}==${Me.ID}) {
                /if (${Group.Puller.ID}==${Me.ID} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
                    DEBUGN KICKIT! (${Group.Puller.ID}==${Me.ID} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius})
                    /if (${Group.Puller.ID}==${Me.ID}) /grouproles unset ${Me.CleanName} 3
                } else {
                    /if (${Group.Puller.ID}==${Me.ID} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius}) /moveto loc ${CampYLoc} ${CampXLoc} mdist 10
                }
                /delay 10 ${Group.Puller.ID}!=${Me.ID}
                /if (${Group.Puller.ID}!=${Me.ID}) /echo + You are no longer group puller.
            }
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: FindMobOnReturn
| -------------------------------------------------------------------------------------
    Sub FindMobOnReturn
        DEBUGPULL FindMobOnReturn Enter ${Role} - ${PullOnReturn} - ${StayPut}
        /while (1) {
            /varset PullMob 0
            /if (${Role.Find[hunter]}) {
                /if (${PullOnReturn}) /varset CheckOnReturn 1
                /call DoWeMove 1
            } else {
                /call DoWeMove 0
            }
            /if (!${PullMob}) {
                /break
            } else {
                /call PullCheck
                /if (${Math.Distance[${CampYLoc},${CampXLoc}]} < 16) /break
                /if (${Role.Find[hunter]}) /break
            }
        }
        DEBUGPULL FindMobOnReturn Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: GroupWatch
| -------------------------------------------------------------------------------------
    Sub GroupWatch
        /if (!${GroupWatchOn} ) /return
        /if (${AggroTargetID} && !${ChainPull}) /return
        DEBUGN GroupWatch Enter
        /declare i              int local
        /declare GrpMemType     string local
        /declare GrpMemName     string local
        /declare GrpMemClass    string local
        /declare GrpMemStat     string local
        /declare GrpWatchCondNo int local
        /declare GrpMedOn       int local
        /if (!${Spawn[=${MainAssist}].ID} && !${Select[${Role},tank,pullertank,pettank,pullerpettank,hunter,hunterpettank]} && ${CampZone}==${Zone.ID}) {
            /echo I am not detecting Main Assist. Pausing.
            /while (1) {
                /doevents
                /if (${DPSOn} || ${MeleeOn}) {
                    /call CheckForCombat 0 GroupWatch1 0
                } else {
                    /call CheckForCombat 1 GroupWatch2 0
                }
                /call WaitSubs
                /if (${Spawn[=${MainAssist}].ID}) {
                    /echo Main Assist is back resuming action.
                    /break
                }
                /delay 10
            }
        }
        /if (${PullHold}==1) /varset PullHold 0
        /for i 1 to 5
            /if (!${Group.Member[${i}].ID} || ${Group.Member[${i}].Type.Equal[corpse]}) {
                /if (${ChainPull} && ${Group.Member[${i}].Type.Equal[corpse]}) /varset PullHold 1
                /continue
            }
            /if (${GroupWatchOn}==2 && !${Select[${Group.Member[${i}].Class.ShortName},CLR,DRU,SHM]}) /continue
            /varset GrpMemType ${Group.Member[${i}].Type}
            /varset GrpMemName ${Group.Member[${i}].CleanName}
            /varset GrpMemClass ${Group.Member[${i}].Class.ShortName}
            /if (${Select[${GrpMemClass},BER,MNK,ROG,WAR]}) {
                /varset GrpMemStat Endurance
            } else {
                /varset GrpMemStat Mana
            }
            /varset GrpMedOn ${MedOn}
            /if (!${MedOn}) /varset MedOn 1
            DEBUGN ${i} CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" ${GrpMemStat} ${GroupWatchPct} 90
            /call CheckStats 1 "${GrpMemName}" ${GrpMemClass} ${GrpMemType} ${GrpMemStat} ${GroupWatchPct} 90
            /if (${Select[${GrpMemClass},BST,PAL,RNG,SHD]}) /call CheckStats 1 "${GrpMemName}" "${GrpMemClass}" "${GrpMemType}" Endurance ${GroupWatchPct} 90
            /if (!${GrpMedOn}) /varset MedOn 0
        /next i
        /if (${GroupWatchCheck.Find[cond]}) {
            /varset GrpWatchCondNo ${GroupWatchCheck.Mid[${Math.Calc[${GroupWatchCheck.Find[cond]}+4]},3]}
        } else {
            /varset GrpWatchCondNo 0
        }
        /if (${ConOn} && ${GrpWatchCondNo} && ${If[${Cond[${GrpWatchCondNo}]},1,0]}) {
            /echo Pausing due to GroupWatchCheck..
            /while (1) {
                /if (${If[${Cond[${GrpWatchCondNo}]},0,1]}) /break
                /delay 10
                DOPARSE
                /if (!${MedCombat} && ${AggroTargetID}) /break
            }
            /echo Continuing from GroupWatchCheck condition.
        }
        DEBUGN GroupWatch Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: CheckStats
| -------------------------------------------------------------------------------------
    Sub CheckStats(int statcheck, charname, ckclass, cktype, stat, int pause,int resume)
        /if (!${statcheck}) /return
        /if (!${Spawn[${ckclass} ${cktype} ${charname}].ID}) /return
        /if (${Spawn[${ckclass} ${cktype} ${charname}].Current${stat}}>${pause}) /return
        /declare SearchList     string local
        /declare SearchCount    int    local
        DEBUGN CheckStats Enter
        DEBUGN statcheck ${statcheck} charname ${charname} ckclass ${ckclass} stat ${stat} pause ${pause} resume ${resume}
        /if (${Role.Equal[puller]} && ${ChainPull} ) {
            /call MobRadar los ${MeleeDistance} CheckStats
            /if (${MobCount}>0) {
                /varset PullHold 1
                /return
            }
        }
        | Add DanNet code here to get Mana/End levels and Not target character.
        |/if (${DanNetOn}) {
        |    /if (${Zone.ShortName.Find[_]}) {
        |        /varset SearchList ${DanNet.Peers[zone_${Zone.ShortName}]}
        |    } else {
        |        /varset SearchList ${DanNet.Peers[zone_${EverQuest.Server.Lower}_${Zone.ShortName}]}
        |    }
        |    /varset SearchCount ${SearchList.Count[|]}
        |    /if (${SearchCount} && ${SearchList.Find[${charname}]}) {
        |        /dquery ${charname} -q Me.Current${stat} -o DNout -t ${DanNetDelay}
        |        /if (${Int[${DNout}]}) {
        |            /if (${Int[${DNout}]}>${pause}) /return
        |        }
        |    }
        |}
        /if (${Select[${Role},puller,pullertank,hunter,hunterpettank,pullerpettank]}) {
            /call BroadCast t "Waiting for >> ${charname} << to med up to ${resume}% ${stat}."
        } else {
            /echo  Waiting for >> ${charname} << to med up to ${resume}% ${stat}.
        }
        | target toon to make sure they aren't at full mana due to lag
        /target id ${Spawn[${ckclass} ${cktype} ${charname}].ID}
        /delay 10
        /varset Pulling 0
        /call DoWeMed 2 ${Target.ID} "${stat}" ${resume}
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
            /call BroadCast t "${charname} is now above ${resume}% ${stat} resuming activity."
        } else {
           /echo ${charname} is now above ${resume}% ${stat} resuming activity.
        }
        /if (!${Me.Mount.ID} && ${Me.Sitting}) /stand
        /varset Medding 0
        /varset PullHold 0
        /if (${IAmABard} && ${TwistMed}) {
            /call CastBardCheck
        }
        /if (${PullPause.Arg[1,|].NotEqual[0]}) /varset PullWaitTimer1 ${PullPause.Arg[1,"|"]}m
        DEBUGN CheckStats Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: alert clear
| -------------------------------------------------------------------------------------
    Sub AlertClearList(int ListToClear, string SentFrom)
        DEBUGPULL AlertClearList Enter
        DEBUGPULL Clearing Alert list ${ListToClear}.
        /squelch /alert clear ${ListToClear}
        DEBUGPULL AlertClearList Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Assign Group Role
| -------------------------------------------------------------------------------------
    Sub AssignGroupRole(ASGOnOff, AGRName, AGRRole)
        DEBUGN AssignGroupRole ${ASGOnOff} ${AGRName} ${AGRRole}
        /docommand /grouproles ${ASGOnOff} ${AGRName} ${AGRRole}
        /delay 10
    /return
| -------------------------------------------------------------------------------------
| SUB: Event CantSee
| -------------------------------------------------------------------------------------
    Sub Event_CantSee
        |/varset EventFlag 1
        DEBUGN Event_CantSee
        | Reset position via stick
        /if (${Pulling}) {
           /varset CantSee 1
           /return
        }
        | need to add local variables or more Outer to figure stick command parts.
        |Start Here
        /if (${UseMQ2Melee}) {
            DEBUGN CantSee ${Attacking} ${Target.ID} ${Target.Distance} ${UseMQ2Melee} ${Stick.Active} ${Me.Moving} ${Melee} ${Melee.Status}
        } else {
            DEBUGN CantSee ${Attacking} ${Target.ID} ${Target.Distance} ${UseMQ2Melee} ${Stick.Active} ${Me.Moving}
        }
        /if (${Attacking}) {
            DEBUGN Can't See my target. Moving Closer.
            /if (${Me.Sitting}) /stand
            /if (${FaceMobOn} && ${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
            /look 0
            /if (!${UseMQ2Melee}) {
                /if (!${Select[${StickHow},0,I]}) {
                    /if (${Me.FeetWet}) {
                        /if (${Stick.Active}) /Stick off
                        /if (${FaceMobOn} && ${Target.ID}) /face
                        /moveto ${Target.MaxRangeTo} id ${Target.ID} uw
                        /delay 10
                        /if (${IAmMA}) {
                            /stick ${StickDistUW} id ${MyTargetID} moveback uw
                        } else {
                            /stick ${StickDistUW} id ${MyTargetID} behindonce moveback uw
                        }
                    } else {
                        /moveto ${Target.MaxRangeTo} id ${Target.ID}
                        /delay 10
                        /if (${IAmMA}) {
                            /stick ${StickDist} id ${MyTargetID} moveback
                        } else {
                            /stick ${StickDist} id ${MyTargetID} behindonce moveback
                        }
                    }
                } else /if (${StickHow.NotEqual[I]}) {
                    /if (${MeleeOn}) {
                        /if (${Me.FeetWet}) {
                            /stick ${StickDistUW} id ${MyTargetID} moveback uw
                        } else {
                            /if (${IAmMA}) {
                                /stick ${StickDist} id ${MyTargetID} moveback
                            } else {
                                /stick ${StickDist} id ${MyTargetID} !front moveback
                            }
                        }
                    }
                }
            }
        } else {
            /if (${FaceMobOn} && ${Target.ID}) /squelch /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
        }
        DEBUGN Leave Event_CantSee
        /doevents flush CantSee
    /return
| -------------------------------------------------------------------------------------
| SUB: Event CantHit
| -------------------------------------------------------------------------------------
    Sub Event_CantHit
        |/varset EventFlag 1
        DEBUGN Event_CantHit
        | Reset position via stick
        /if (${Pulling}) {
            /varset CantHit 1
            /if (${PullWith.Equal[Ranged]} && ${Target.Distance}<=30 && ${Target.LineOfSight}) /varset ToClose 1
        }
        DEBUGN Leave Event_CantHit
    /return
| -------------------------------------------------------------------------------------
| SUB: Event Missing
| -------------------------------------------------------------------------------------
    Sub Event_Missing
        /varset EventFlag 1
        /varset MissingComponent 1
    /return 1
| -------------------------------------------------------------------------------------
| SUB: Event Mlog Off
| -------------------------------------------------------------------------------------
    Sub Event_MLogOff
        /varset EventFlag 1
        /if (${DebugLogging}) {
            /mlog off
            /varset DebugLogging 0
        }
    /return    
| ----------------------------------------------------------------------------
| SUB: Bind Switch
| ----------------------------------------------------------------------------
    Sub Bind_Switch(int lockOnFlag, int newTargetID)
        /if (${IAmMA}) /return
        
        /declare WasAttacking int local ${Attacking}
        /if (!${newTargetID}) {
            /echo New target called! Assisting...
        } else {
            /echo New target called! ${Spawn[id ${newTargetID}].CleanName}
        }
        /call CombatReset 1 switch
        /if (!${newTargetID}) {
            /call Assist
        } else {
            /squelch /target clear
            /delay 10 !${Target.ID}
            /target id ${newTargetID}
            /delay 10 ${Target.ID}
            /if (${XTarAutoSet} && !${Group.Member[${MainAssist}].Index} && ${Me.XTarget[${XTSlot}].ID}!=${newTargetID} && ${Target.Type.NotEqual[PC]}) /xtarget set ${XTSlot} currenttarget
            /varset MyTargetID ${Target.ID}
            /varset MyTargetName ${Target.CleanName}
            /varset LastTargetID ${MyTargetID}
        }
        /if (${lockOnFlag}) /varset TargetSwitchingOn 2 
        /if (${WasAttacking}) {
            /squelch /attack on
            /varset Attacking 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind SwitchMA
| ----------------------------------------------------------------------------
    Sub Bind_SwitchMA(string newMA, string newRole, int DoWhatFlag)
        /declare newRole1 string local ${newRole}
        /declare WasAttacking int local ${Attacking}
        /if (${newMA.Length}==0 || ${newMA.Equal[null]}) /return
        /if (${newRole1.Length}==0 || ${newRole1.Equal[null]}) /varset newRole1 Tank
        /if (${DoWhatFlag}==0) {
            /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
                /bcg //switchma ${newMA} ${newRole1} 1
            } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
                /dgge /switchma ${newMA} ${newRole1} 1
            } else {
                /echo SwitchMA Command requires MQ2EQBC or DanNet Plugin to be loaded.
            }
        }
        /echo Switching Main Assist to ${newMA}
        /if (${newMA.Equal[${Me}]}) {
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset MainAssistType ${Me.Type}
            /varset MainAssistClass ${Me.Class.ShortName}
            /varset Role ${newRole1}
            /call CheckRoles 0
        } else /if (${Me.Pet.ID} && ${newMA.Equal[${Me.Pet.CleanName}]}) {
            /varset MainAssist ${Me}
            /varset IAmMA 1
            /varset MainAssistType ${Me.Type}
            /varset MainAssistClass ${Me.Class.ShortName}
            /varset Role pettank
            /call CheckRoles 0
        } else {
            /varset MainAssist ${newMA}
            /varset IAmMA 0
            /varset MainAssistType ${Spawn[=${newMA}].Type}
            /varset MainAssistClass ${Spawn[=${newMA}].Class.ShortName}
            /if (${Role.NotEqual[${MyOriginalRole}]} ) {
                /varset Role ${MyOriginalRole}
                /call CheckRoles 0
            }
        }
        /call CombatReset 0 switchma
        /if (!${IAmMA}) {
            /call Assist
        } else {
            /call GetCombatTarget
        }
        /if (${WasAttacking} && ${Target.ID}) {
            /squelch /attack on
            /varset Attacking 1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event AskForBuffs
| ----------------------------------------------------------------------------
    Sub Event_AskForBuffs(String Line, AFBCaller)
        /varset EventFlag 1
        DEBUGBUFF AskForBuffs: Enter
        /declare WorkID int local ${Int[${Spawn[${AFBCaller}].ID}]}
        /if (!${AFBCaller.Length} || ${AFBCaller.Equal[null]} || !${WorkID} || ${WorkID}==${Me.ID}) /return
        /if (${Group.Member[${AFBCaller}].Index} || ${Spawn[id ${WorkID}].Type.NotEqual[PC]}) /return
        /if (!${Raid.Member[${AFBCaller}].Group}) {
            /if (!${Me.Fellowship.Member[${AFBCaller}].Level}) {
                /if (!${Me.Guild.Equal[${Spawn[${AFBCaller}].Guild}]}) {
                    /if (!${Friends.Friend[${AFBCaller}]}) /return
                }
            }
        }
        /call Bind_TooBuffList add ${WorkID}
        DEBUGBUFF AskForBuffs: Exit
    /return
| ----------------------------------------------------------------------------
| SUB: Event AttackCalled
| ----------------------------------------------------------------------------
    Sub Event_AttackCalled(String Line, ACCaller, ACMobID)
        /varset EventFlag 1
        /echo ==> Attack Called: ${ACCaller} ${ACMobID}
        /if (!${ACMobID.Length} || ${ACMobID.Equal[null]}) {
            /varset CalledTargetID 0
            /return
        }
        /if (${IAmMA}) /return
        /if (${ACCaller.Equal[${MainAssist}]}) /varset CalledTargetID ${ACMobID}
    /return
| ----------------------------------------------------------------------------
| SUB: Event GotHit - Written by TreeHuginDruid for RedGuides
| ----------------------------------------------------------------------------
    Sub Event_GotHit(string Line, string AttackingMob)
        /varset EventFlag 1
        /declare GotHitDistChk int local 10
        /varset SitToMedTimer ${SitToMedTimer.OriginalValue}
        /varset GotHitToggle 1
        /declare AttackingMobID int local
        /if (${AggroTargetID} && !${Target.ID} && !${ReturnToCamp}) {
            /doevents flush GotHit
            /if (${DPSOn} || ${MeleeOn}) {
                /call CheckForCombat 0 Event_GotHit1 0
            } else {
                /call CheckForCombat 1 Event_GotHit2 0
            }
        }
        /if (${Select[${Role},pullertank,pettank,pullerpettank,hunterpettank]}) {
            /if (${Pulled} && ${WaitTimer} && ${Select[${Role},pullertank,pullerpettank]} && ${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}<=${CampRadius}) {
                /if (${NearestSpawn[npc los radius ${CampRadius} targetable].ID}!=${MyTargetID}) {
                    /varset MyTargetID 0
                    /varset MyTargetName
                    /if (${Target.ID}) /squelch /target clear
                }
                /varset WaitTimer 0s
                /varset AttackingMobID ${NearestSpawn[npc radius 39 targetable "${AttackingMob}"].ID}
                /echo I got hit by >>${AttackingMob}<< ID: ${AttackingMobID} while waiting for mob.
            }
            /if (${Select[${Role},pettank,pullerpettank,hunterpettank]}) {
                /doevents flush GotHit
                /varset AttackingMobID ${NearestSpawn[npc radius 39 targetable "${AttackingMob}"].ID}
                /squelch /target id ${Spawn[${AttackingMobID}].ID}
                /delay 10 ${Target.ID}==${AttackingMobID}
                |- If mob that hit me still too close, move to camp or away from mob.
                /if (${GotHitToggle} && ${AttackingMobID}>0) {
                    /echo I got hit by >>${AttackingMob}<< ID:${AttackingMobID}!
                    /moveto dist 10
                    /if (${Math.Distance[${Me.Y},${Me.X}:${CampYLoc},${CampXLoc}]}>${CampRadius} && !${Select[${Role},hunterpettank]} && ${ReturnToCamp}) {
                        |- Only move away from mob if MoveWhenHit enabled (1)
                        /if (${MoveWhenHit}) {
                            /echo Moving back to camp!
                            /moveto loc ${CampYLoc} ${CampXLoc}
                        }
                    } else {
                        |- If mob is in pet attack range from camp, send pet in.
                        /if (${Me.Pet.ID} && ${Math.Distance[${Target.Y},${Target.X}:${Me.Pet.Y},${Me.Pet.X}]}<=${PetAttackRange}) {
                            /pet attack
                            /if (!${Pet.Taunt}) /pet taunt on
                        }
                        |- Only move away from mob if MoveWhenHit enabled (1)
                        /if (${MoveWhenHit}) {
                            /echo Trying to get away from >>${AttackingMob}<<.
                            /if (${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}<=${GotHitDistChk}) /moveto loc ${Target.Y} ${Math.Calc[${Target.X}-${GotHitDistChk}]}
                        }
                    }
                }
                /if (${MoveWhenHit}) /delay 15 ${Math.Distance[${Me.Y},${Me.X}:${Target.Y},${Target.X}]}>${GotHitDistChk}
                /if (${FaceMobOn} && ${Target.ID}) /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
                /look 0
            }
        }
        /varset GotHitToggle 0
        /doevents flush GotHit
    /return
| ----------------------------------------------------------------------------
| SUB: Event Zoned
| ----------------------------------------------------------------------------
    Sub Event_Zoned(Message)
        /varset EventFlag 1
        /if (${Message.Find[Drunken Monkey]} || ${Message.Find[effects]}) /return
        /call PauseWhileZoning Event_Zoned
        /if (!${JustZoned}) /echo Just zoned
        /call CombatReset 0 zoned
        /varset JustZoned 200
        /varset CampOnDeathTimer 10m
        /if (${LastZone}!=${Zone.ID}) {
            /if (${Zone.Name.Find[,]} || ${Zone.Name.Find[']}) {
                /varset ZoneName ${Zone.ShortName}${If[${Me.InInstance},_I,]}
            } else {
                /varset ZoneName ${Zone}${If[${Me.InInstance},_I,]}
            }
        }
        /varset LastZone ${Zone.ID}
        | Shut down combat and mez in GH, GL, PoK, PoT, and Abysmal
        /if (${Select[${Zone.ID},345,344,202,203,279]}) {
            /varset DMZ 1
        } else {
            /varset DMZ 0
        }
        /if (${CampZone}!=${Zone.ID}) {
            /if (${ReturnToCamp}) {
                /varset ReturnToCamp 0
                /varset RememberCamp 1
            }
        } else {
            /if (${RememberCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]}<=150) {
                /varset ReturnToCamp 1
                /varset RememberCamp 0
            }
            /if (${IAmDead}) /varset IAmDead 0
        }
        /call WinTitle
    /return
| ----------------------------------------------------------------------------
| SUB: Event Joined 20s switch to prevent heals from firing off
| ----------------------------------------------------------------------------
    Sub Event_Joined(string Jmessage,string Joinee)
        DEBUGBUFF Event_Joined Enter ${Joinee}
        /declare i int local
        /declare j int local
        /varset EventFlag 1
        /echo ${Joinee} has joined the party.
        /varset JoinedParty 200
        /varset j ${Group.Member[${Joinee}].Index}
        /for i 1 to ${Buffs.Size}
            /varset Buff${i}GM${j} 0
            /if (${Joinee.Equal[${MainAssist}]}) /varset Buff${i}GM7 0
        /next i
        /if (${ReadBuffsTimer}) /varset ReadBuffsTimer 0
        /varset ForceBuffs 2
        DEBUGBUFF Event_Joined Exit
    /return
| ----------------------------------------------------------------------------
| SUB: Event Too Close
| ----------------------------------------------------------------------------
    Sub Event_TooClose
        |/varset EventFlag 1
        /if (${MyTargetID} && ${AutoFireOn}==1 && ${CombatStart}) {
            /if (${Me.AutoFire}) /autofire
            /varset AutoFireOn 2
            /if (${UseMQ2Melee}) /killthis
        }
        /if (${Pulling} && ${PullWithAlt.Equal[Melee]}) {
           /echo Mob Too Close for ${PullWith}... Switching to Melee.
           /varset ToClose 1
        }
        /doevents flush TooClose
    /return
| ----------------------------------------------------------------------------
| SUB: Event Camping - end macro
| ----------------------------------------------------------------------------
    Sub Event_Camping
        /varset EventFlag 1
        /if (${IAmABard}) {
            /if (${Twist}) /call CastBardCheck
        }
        /endmacro
    /return
| ----------------------------------------------------------------------------
| SUB: Event Too Far
| ----------------------------------------------------------------------------
    Sub Event_TooFar
        |/varset EventFlag 1
        /if (${CombatStart} && ((!${UseMQ2Melee} && ${StickHow.Equal[I]}) || (${UseMQ2Melee} && ${MeleeDistance}==${CampRadius}))) /return
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /if (${Math.Distance[${Target.Y},${Target.X}:${CampYLoc},${CampXLoc}]}<=${MeleeDistance} && ${MeleeOn} && ${CombatStart}) {
            /if (!${UseMQ2Melee}) {
                /if (${Me.FeetWet}) {
                    /if (${FaceMobOn}) /face
                    /if (!${Me.Moving}) /moveto id ${MyTargetID} mdist ${If[${Target.Distance}>5,${Math.Calc[${MoveTo.ArrivalDist}-5]},1]} uw
                    /delay 10
                    /if (${IAmMA}) {
                        /squelch /stick ${MoveTo.ArrivalDist} id ${MyTargetID} uw
                    } else {
                        /squelch /stick ${MoveTo.ArrivalDist} id ${MyTargetID} !front moveback uw
                    }
                } else {
                    /if (!${Me.Moving}) /moveto id ${MyTargetID} mdist ${If[${Target.Distance}>5,${Math.Calc[${MoveTo.ArrivalDist}*.90]},1]}
                    /squelch /stick ${MoveTo.ArrivalDist} id ${MyTargetID} ${StickHow}
                }
            } else {
                /if (${FaceMobOn}) /face
                /if (!${Me.Moving}) /moveto id ${MyTargetID} mdist ${If[${Target.Distance}>5,${Math.Calc[${MoveTo.ArrivalDist}-5]},1]} uw
                /delay 10
            }
        }
        /call ZAxisCheck ${ZDist} 4.1
        /if (${Select[${Role},pullertank,pullerpettank,puller]} && ${Pulling}) {
            /varset PullTooFar 1
        }
        /doevents flush TooFar
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Change Var Int resets various interger settings from ini file
| ----------------------------------------------------------------------------
    Sub Bind_ChangeVarInt(ISection, IName, IVar)
        DEBUGN Bind_ChangeVarInt ${ISection} ${IName} ${IVar}
        /echo Changing ${IName} to ${IVar}
        /varset ${IName} ${IVar}
        /ini "${IniFileName}" "${ISection}" "${IName}" "${IVar}"
        /if (${IName.Find[mezon]}) {
            /if (!${Defined[MezTimer1]}) /call CreateTimersMez
        } else /if (${IName.Find[dpson]}) {
            /if (!${Defined[DPSTimer1]}) /call CreateTimersDPS
        } else /if (${IName.Find[buffson]}) {
            /if (!${Defined[Buffs1Timer0]}) {
                /call CreateTimersBuffs
                /echo Buffs on creating timers
            }
        } else /if (${IName.Equal[ChaseAssist]}) {
            /if (${IVar}) {
                /if (${ReturnToCamp}) {
                    | Why set whotochase here. by default whotochase is set to mainassist.
                    /ini "${IniFileName}" "General" "ReturnToCamp" "0"
                    /varset ReturnToCamp 0
                }
                /if (!${Stick.Active}) /varset RebuffOn 300
                /if (${Me.Pet.ID} && ${Me.Pet.Stance.NotEqual[follow]}) /pet follow
            } else {
                /if (${Stick.Active}) /squelch /stick off
            }
        } else /if (${IName.Equal[MaxRadius]}) {
            /varcalc CampRadiusExceed ${MaxRadius}+200
        } else /if (${IName.Equal[LootOn]}) {
            /if (!${LootOn}) {
                /if (${Defined[NALStatus]}) {
                    /varset NALStatus 0
                }
            } else {
                /if (${Defined[NALStatus]}) {
                    /varset NALStatus 1
                }
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind ChaseMe
| ----------------------------------------------------------------------------
    Sub Bind_ChaseMe
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //chase on ${Me.CleanName}
        } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
            /dgge /chase on ${Me.CleanName}
        } else {
            /echo ChaseMe command requires MQ2EQBC/MQ2DanNet plugin loaded.
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind StayHere
| ----------------------------------------------------------------------------
    Sub Bind_StayHere
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //waithere
        } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
            /dgge /waithere
        } else {
            /echo Stayhere command requires MQ2EQBC/MQ2DanNet plugin loaded.
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind MakeCampHere
| ----------------------------------------------------------------------------
    Sub Bind_MakeCampHere
        /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bcg //camphere on
        } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
            /dgge /camphere on
        } else {
            /echo Makecamphere command requires MQ2EQBC/MQ2DanNet.
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event Task Update - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_TaskUpdate(Line,name)
        /varset EventFlag 1
        /call BroadCast t "Task updated...(${name})"
    /return
| ----------------------------------------------------------------------------
| SUB: Event Gain Something - EQBC message
| ----------------------------------------------------------------------------
    Sub Event_GainSomething(string Line,string text)
        /varset EventFlag 1
        /if (!${EQBCOn} && !${IRCOn} && !${DanNetOn}) /return
        /if (${Line.Find["ABILITY POINT!"]}) {
            /call BroadCast w "${Me.Name} gained an AA, now has ${Me.AAPoints} unspent"
        } else /if (${Line.Find[LEVEL]}) {
            /call BroadCast w "${Me.Name} gained a level, now is Level ${Me.Level}"
            |/if (${GMailEvents.Find[level]}) /call GmailSend "${Me.Name} gained a level, I am Level ${Me.Level}"
            | Recalculate pull when level gained
            /if (${PullLevel.Equal[auto]}) {
               /varcalc PullMin ${Me.Level}-5
               /varcalc PullMax ${Me.Level}+2
            } else /if (${PullLevel.Equal[linked]}) {
               /varcalc PullMin ${PullMin}+1
               /varcalc PullMax ${PullMax}+1
            }
            | need to add a new flag and set for memming new tombs and spells if in inventory.
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Cast - To allow calling Kiss Internal Casting Routine
| ----------------------------------------------------------------------------
    Sub Bind_KissCast(string KCastWhat, int KWhatID, int ForceInterrupt)
        | castWhat,int WhatID,string sentFrom,int CondNumber
        /if (${KCastWhat.Equal[null]} || !${KCastWhat.Length}) /return
        /if (${Me.Hovering} || ${Me.Feigning}) /return
        DEBUGCAST Bind_KissCast Enter \aw ${KCastWhat} ID: ${KWhatID} ForceInterrupt: ${ForceInterrupt}
        /declare WasCastingSpell string local null
        | I am sure we will need to add code for Bards, But not just sure what to check.
        | Will come back later and add code.
        | ******************************************************************************
        | If I am casting, then I am in the middle of the castwhat routine and need to Interrupt
        | casting current spell(ForceInterrupt==1) or I need to exit this Bind Routine.
        | Start ************************************************************************
        /if (${Me.Casting.ID} && ${Window[CastingWindow].Open}) {
            /if (${ForceInterrupt}) {
                /varset WasCastingSpell ${Me.Casting}
                /stopcast
                /delay 5
            } else {
                /echo Skipped KissCasting ${KCastWhat} I am busy casting ${Me.Casting}
                /return
            }
        }
        | End ***************************************************************************
        | If a casting target was not passed then set myself as the casting target.
        /if (!${KWhatID}) /varset KWhatID ${Me.ID}
        DEBUGCAST Bind_KissCast \aw WhatID: ${KWhatID} ForceInterrupt: ${ForceInterrupt} WasCastingSpell: ${WasCastingSpell}
        /call CastWhat "${KCastWhat}" ${KWhatID} "KissCast" 0 0
        | If previous cast interrupted we need to let spell casting routine it is no longer valid and was cancelled.
        /if (${WasCastingSpell.NotEqual[null]}) {
            /varset CastResult CAST_CANCELLED
        } else {
            /varset CastResult CAST_NO_RESULT
        }
        DEBUGCAST Bind_KissCast \awLeave ${CastResult}
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Edit - Edit ini file in MQ2NotePad
| ----------------------------------------------------------------------------
    Sub Bind_KissE
        /if (!${Bool[${Plugin[MQ2Notepad]}]}) {
            /echo This function requires MQ2Notepad to be loaded..
            /echo 1. Please copy MQUI_NotepadWindow.xml to your Everquest/UIFiles/default or custom ui folder
            /echo 2. then /Plugin MQ2Notepad
        }
        /if (${Bool[${Plugin[MQ2Notepad]}]}) {
            /docommand /notepad kissassist_${Me}.ini
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Bind Kiss Check - scan ini file for errors based on nostress KissNamechecker.mac
| ----------------------------------------------------------------------------
    Sub Bind_KissCheck
        /call ScanIni all 0
    /return
| ----------------------------------------------------------------------------
| SUB: Event Invised Mainly to turn off bard twisting while invis.
| ----------------------------------------------------------------------------
    Sub Event_Invised
        /varset EventFlag 1
        /if (${IAmABard}) {
            /if (${Twist}) /call CastBardCheck
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event ImDead
| ----------------------------------------------------------------------------
    Sub Event_ImDead(IDMessage)
        /varset EventFlag 1
        /if (${IAmDead}) /return
        /echo I have died and the Angels wept.
        |/if (${GMailEvents.Find[dead]}) /call GmailSend "I have died. EQ Said ${IDMessage} Loc ${Me.X} ${Me.Y}"
        /varset IAmDead 1
        /doevents flush ImDead
        /if (${IAmABard}) {
            /call CastBardCheck
        }
        /delay 20
        /if (${Me.Hovering}) /call PauseWhileHovering Event_ImDead
        /call CombatReset 0 ImDead
        /while (!${Zone.ID} && !${Me.ID}) {
            /delay 5
        }
        /if (${CampZone}==${Zone.ID}) /varset IAmDead 0
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM On
| ----------------------------------------------------------------------------
    Sub Event_GoMOn
        /varset EventFlag 1
        /if (${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]} || ${GoMByPass}) {
            /varset GoMByPass 0
            /doevents flush GoMOn
            /doevents flush GoMOff
            /return
        }
        /if (!${CombatStart} || ${GoMTimer}) /return
        | Release timer after trying to cast for 10 secs
        /varset GoMTimer 3s
        /declare i int local
        /declare GoMCast string local
        /declare GoMTarget string  local
        /declare GoMCastStat string ${CastResult}
        /declare CondNo local int 0
        /for i 1 to ${GoMSpell.Size}
            /if (${ConOn} && ${GoMSpell[${i}].Find[|cond]}) {
                /varset CondNo ${GoMSpell[${i}].Mid[${Math.Calc[${GoMSpell[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            /varset GoMCast ${GoMSpell[${i}].Arg[1,|]}
            /varset GoMTarget ${GoMSpell[${i}].Arg[2,|]}
            /if (${GoMCast.Equal[null]} || ${GoMCast.Find[spell]} || ${GoMSpellTimer${i}}) /continue
            /echo Gift of Mana detected! Trying to cast ${GoMCast}
            /doevents flush GoMOn
            /if (${GoMTarget.Equal[Me]} && ${Me.ID}) {
                /varset GoMTarget ${Me.ID}
            } else /if (${GoMTarget.Equal[MA]} && ${Spawn[=${MainAssist}].ID}) {
                /varset GoMTarget ${Spawn[=${MainAssist}].ID}
            } else /if (${MyTargetID}) {
                /varset GoMTarget ${MyTargetID}
            } else {
                /continue
            }
            /varset GoMActive 1
            /if (${GoMTarget.Equal[${MyTargetID}]} && (${Target.Type.Equal[Corpse]} || !${Spawn[id ${MyTargetID}].ID})) {
                DEBUGN Event_GoMOn [GoM] skipping because mob is dead or a corpse.
                /echo [GoM] being skipped, because target (${GoMTarget}) is a corpse.
                /varset GoMTimer 0
                /delay 10
                /doevents GoMOff
                /return
            }
            | Wait for global cooldown if active
            /while (${Me.SpellInCooldown}) {
                /if (${MeleeOn}) {
                    /if (${WeaveArray.Size}>0 && ${WeaveArray[1].NotEqual[null]}) /call CastWeave ${MyTargetID}
                    /if (${MashArray.Size}>0 && ${MashArray[1].NotEqual[null]}) /call MashButtons
                } else {
                    /delay 2
                }
            }
            /if (${Me.SpellReady[${GoMCast}]}) {
                /call CastWhat "${GoMCast}" ${GoMTarget} GoM ${CondNo} 0
                /if (${Macro.Return.Equal[CAST_COND_FAILED]}) /continue
                /varset LastDPSCast ${GoMCast}
            } else {
                /echo "${GoMCast}" is not ready!
                /delay 10
            }
            DEBUGN Return: ${Macro.Return}
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo Gift of Mana Casting >> ${GoMCast} <<
                /varset GoMTimer 0
                /varset GoMSpellTimer${i} ${Spell[${GoMCast}].MyDuration.TotalSeconds}*10
                /doevents flush GoMOn
                /delay 10
                /doevents GoMOff
                /varset CastResult ${GoMCastStat}
                /return
            } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                /varset CastResult CAST_CANCELLED
                /return
            }
        /next i
        /varset CastResult ${GoMCastStat}
    /return
| ----------------------------------------------------------------------------
| SUB: Event GoM Off
| ----------------------------------------------------------------------------
    Sub Event_GoMOff
        /varset EventFlag 1
        /varset GoMActive 0
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo guild meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_GUEQBC(Message,GUName,GUText)
        /varset EventFlag 1
        /if (${GUName.Equal[${Me.CleanName}]}) /return
        /if (${Macro.IsTLO[EQBC]}) {
            /if (${EQBC.Connected} && ${Select[${EQBCOn},2,4]}) /call BroadCast p "${GUName} tells Guild: ${GUText} "
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event GUEQBC - Echo fellowship meassages in EQBC
| ----------------------------------------------------------------------------
    Sub Event_FSEQBC(Message,FSName,FSText)
        /varset EventFlag 1
        /if (${FSName.Equal[${Me.CleanName}]}) /return
        /if (${Macro.IsTLO[EQBC]}) {
            /if (${EQBC.Connected} && ${Select[${EQBCOn},3,4]}) /call BroadCast p "${FSName} tells Fellowship: ${FSText} "
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Event KABegCheck
| ----------------------------------------------------------------------------
    Sub Event_KABegCheck(Message,BCWho,BCWhat,KBCExtra)
        /varset EventFlag 1
        /declare BCx int local 0
        /declare BCItem string local
        /declare BCCast string local

        /if (${Me.CleanName.Equal[${BCWho}]}) /return
        |/echo ${BCWho} ${BCWhat}
        DEBUGBUFF KABegCheck: Enter ${BCWho} ${BCWhat}
        /if (${KABegForList.Length}>2000) {
            /echo Begged For List Exceeded Max Length. May have to beg again.
            /return
        }
        /if (!${BuffsOn}) /return
        /if (!${Select[${BCWhat},BEGFORITEMS,BEGFORBUFFS]}) /return
        /declare WorkID int local ${Int[${Spawn[PC ${BCWho}].ID}]}
        /if (!${BCWho.Length} || ${BCWho.Equal[null]} || !${WorkID} || ${WorkID}==${Me.ID}) /return
        /if (${Spawn[id ${WorkID}].Type.NotEqual[PC]}) /return
        /if (!${Raid.Member[${BCWho}].Group}) {
            /if (!${Me.Fellowship.Member[${BCWho}].Level}) {
                /if (!${Me.Guild.Equal[${Spawn[${BCWho}].Guild}]}) {
                    /if (!${Friends.Friend[${BCWho}]}) /return
                }
            }
        }
        /for BCx 1 to ${Buffs.Size}
            /if (${Buffs[${BCx}].Find[|alias|${BCWhat}]}) {
                /varset BCCast ${Buffs[${BCx}].Arg[1,|]}
                /if (${Buffs[${BCx}].Arg[2,|].Equal[summon]}) {
                    /if (${Buffs[${BCx}].Arg[6,|].NotEqual[${BCWhat}]}) /continue
                    /varset BCItem ${Buffs[${BCx}].Arg[3,|]}
                } else {
                    /varset BCItem ${Buffs[${BCx}].Arg[1,|]}
                }
                /if (!${Me.Book[${BCCast}]} && !${AltAbility[${BCCast}]}) /continue
                /varset KABegActive 1
                /if (${KABegForList.Length}) {
                    /varset KABegForList ${KABegForList}|${BCWhat}:${BCWho}:${BCx}
                } else {
                    /varset KABegForList ${BCWhat}:${BCWho}:${BCx}
                }
                /break
            }
        /next BCx
        DEBUGBUFF KABegCheck: Leave ${KABegActive}
    /return
| ----------------------------------------------------------------------------
| SUB: Event EQBCIRC - Pick up commands from MQ2IRC or MQ2EQBC(todo)
| ----------------------------------------------------------------------------
    Sub Event_EQBCIRC(EIMessage,EISender,EICommand)
        /varset EventFlag 1
        /if (${EICommand.Left[1].Equal[/]} && ${EICommand.Left[2].NotEqual[/]}) /docommand ${EICommand}
        /doevents flush EQBCIRC
    /return
| ----------------------------------------------------------------------------
| SUB: AFK Tools from AHTools by Anonymous Hero
| ----------------------------------------------------------------------------
    Sub AFKTools
        /declare holding bool local
        |/if (${CampZone}!=${Zone.ID} || (${HealsOn} && ${AggroTargetID})) /return
        /if (${CampZone}!=${Zone.ID}) {
            /if (${CampOnDeath}) /call DoICampA
            /return
        }
        /if (${HealsOn} && ${AggroTargetID}) /return
        /if (${Select[${AFKToolsOn},1,2]}) {
            /if (${Macro.IsTLO[Posse]}) {
                /while (${Posse.Strangers}>=1) {
                    /if (!${holding}) {
                        /echo [AHTools] Macro on hold due to player activity in camp radius.
                        /call BroadCast r "**PCS DETECTED IN CAMP RADIUS**"
                        /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                        /varset holding 1
                    }
                    /delay 1s
                    /if (${DPSOn} || ${MeleeOn}) {
                        /call CheckForCombat 0 AFKTools1 0
                    } else {
                        /call CheckForCombat 1 AFKTools2 0
                    }
                    /doevents
                }
            } else {
                /varset holding 0
            }
        }
        /if (${Select[${AFKToolsOn},1,3]}) {
            |/if (${GMailEvents.Find[GM]} && ${SpawnCount[GM]}>=1) /call GmailSend "GM in Zone, ${Zone.ShortName}"
            /if (${SpawnCount[GM]}>=1) {
                /if (${AFKGMAction}==1) {
                    /while (${SpawnCount[GM]}>=1) {
                        /if (!${holding}) {
                            /echo [AHTools] Macro on hold due to GM Presence
                            /call BroadCast r "** GM DETECTED **"
                            /multiline ; /beep ; /timed 1 /beep ; /timed 1 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 5 /beep ; /timed 1 /beep ; /timed 1 /beep
                            /varset holding 1
                        }
                    }
                } else {
                    /varset holding 0
                }
                /if (${AFKGMAction}==2) {
                    /multiline ; /echo [AHTools] Ending Macro due to GM Presence ; /mq2log [AHTools] Ending Macro due to GM Presence ; /endmacro
                } else /if (${AFKGMAction}==3) {
                    /multiline ; /echo [AHTools] Unloading MQ2 due to GM Presence; /mq2log [AHTools] Unloading MQ2 due to GM Presence ; /unload
                } else /if (${AFKGMAction}==4) {
                    /multiline ; /echo [AHTools] Quitting out of EQ due to GM Presence ; /mq2log [AHTools] Quitting out of EQ due to GM Presence ; /quit
                }
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: BuffGroup
| ----------------------------------------------------------------------------
    Sub Bind_BuffGroup(int Flag1)
        DEBUGBUFF Bind_BuffGroup: Enter ${Flag1}
        /if (!${Flag1}) {
            /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
                /bcg //buffgroup 1
            } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
                /dgge /buffgroup 1
            } else {
                /echo BuffGroup Command requires MQ2EQBC/MQ2DanNet.
            }
        }
        /if (${BuffsOn}) {
            /varset ReadBuffsTimer 0
            /varset IniNextTimer 0
            /call CheckBuffs 1
        }
        DEBUGBUFF Bind_BuffGroup: Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Burn Section for new bind
| ----------------------------------------------------------------------------
    Sub Bind_Burn(string s_BurnWhat, string s_State)
        /declare BurnWhat int local ${Int[${s_BurnWhat}]}
        /if (${s_BurnWhat.Equal[on]} || ${s_State.Equal[on]}) {
            /varset BurnOn 1
            /varset CampZone ${Zone.ID}
            /echo Turning Burn On. ${s_BurnWhat} - ${s_State} 
        } else /if (${s_BurnWhat.Equal[off]} || ${s_State.Equal[off]}) {
            /varset BurnOn 0
            /varset BurnActive 0
            /varset BurnCalled 0
            /varset BurnID 0
            /echo Turning Burn Off.
        }
        /if (!${BurnOn}) /return
        /if (${s_BurnWhat.Equal[on]} && ${s_State.NotEqual[doburn]}) /return
        /varset BurnCalled 1
        /if (${BurnWhat}) {
            /varset BurnID ${BurnWhat}
        } else /if (${MyTargetID}) {
            /varset BurnID ${MyTargetID}
        } else /if (${Target.ID} && !${Select[${Target.Type},pc,pet,mercenary,corpse]}) {
            /varset BurnID ${Target.ID}
        }
        /call Burn ${BurnID}
    /return
| ----------------------------------------------------------------------------
| SUB: Burn Section
| ----------------------------------------------------------------------------
    Sub Burn(int EBurnWhat)
        /if (${IAmDead} || ${Me.Hovering} || ${CampZone}!=${Zone.ID} || !${BurnOn}) {
            /if (!${BurnOn}) /echo Leaving Burn. Burn is turned Off.
            /return
        }
        /declare i            int local
        /declare BurnSpell    string local
        /declare BurnTarget   string local
        /declare BurnTargetID int local
        /declare BurnArg3     string local
        /declare CondNo       int    local 0
        /declare AbortFlag    int    local 0
        /if (!${BurnActive}) /call BroadCast r "BURN ACTIVATED => Autobots Transform <="
        /if (${UseTribute} && !${Me.TributeActive}) {
           /squelch /tribute personal on
           /squelch /trophy personal on
           /varset TributeTimer 570s
        }
        /for i 1 to ${Burn.Size}
            /varset BurnSpell ${Burn[${i}].Arg[1,|]}
            /varset BurnTarget ${Burn[${i}].Arg[2,|]}
            /varset BurnArg3 ${Burn[${i}].Arg[3,|]}
            /varset AbortFlag 0
            /if (${ConOn} && ${Burn[${i}].Find[|cond]}) {
                /varset CondNo ${Burn[${i}].Mid[${Math.Calc[${Burn[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            /if (${BurnSpell.Equal[null]} || ${Me.Hovering}) /continue
            /if (${BurnTarget.Equal[Mob]}) {
                /varset BurnTargetID ${MyTargetID}
            } else /if (${BurnTarget.Equal[Me]}) {
                /varset BurnTargetID ${Me.ID}
            } else /if (${BurnTarget.Equal[MA]}) {
                /varset BurnTargetID ${Spawn[=${MainAssist}].ID}
            } else /if (${BurnTarget.Equal[Pet]}) {
                /varset BurnTargetID ${Me.Pet.ID}
            } else /if (${BurnTarget.Equal[abort]}) {
                /varset BurnTargetID ${MyTargetID}
                /varset BurnArg3 abort
            } else /if (${MyTargetID}) {
                /varset BurnTargetID ${MyTargetID}
            }
            /if (${BurnArg3.Equal[abort]}) {
                /varset AbortFlag 1
            }
            /call CastWhat "${BurnSpell}" ${BurnTargetID} Burn ${CondNo} ${AbortFlag}
            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /echo Casting >> BURN${i}:${BurnSpell}
                /while (${Me.Casting.ID} && ${Window[CastingWindow].Open} && !${IAmABard}) {
                    /delay 5
                }
            }
        /next i
        /varset BurnActive 1
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  Code from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Event_TooSteep
        /varset EventFlag 1
        /varset CampfireOn 0
        /echo Setting CampfireOn to 0. You are on a hill.
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire Section -  OriginalCode from toomanynames, wizbomb
| ----------------------------------------------------------------------------
    Sub Bind_Campfire
        /declare UseThisCampfire int local ${CampfireOn}
        /if (${Select[${Zone.ID},33506]}) /return
        /if (${ReturnToCamp}) /call DoWeMove 1 Bind_CampFire
        /if (${UseThisCampfire}>1) {
            /if (${FindItemCount[Fellowship Campfire Materials]}<1) {
                /varset UseThisCampfire 1
                /echo Fellowship Campfire Materials Not Found. Setting to Regular Fellowship.
            }
        }
        /windowstate FellowshipWnd open
        /delay 10
        /nomodkey /notify FellowshipWnd FP_Subwindows tabselect 2
        /if (${Me.Fellowship.Campfire}) {
            /if (!${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]}) {
                /nomodkey /notify FellowshipWnd FP_DestroyCampsite leftmouseup
                /delay 5s ${Window[ConfirmationDialogBox].Open}
                /if (${Window[ConfirmationDialogBox].Open}) {
                    /nomodkey /notify ConfirmationDialogBox Yes_Button leftmouseup
                }
                /delay 5s !${Me.Fellowship.Campfire}
            }
        }
        /nomodkey /notify FellowshipWnd FP_RefreshList leftmouseup
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_CampsiteKitList listselect ${UseThisCampfire}
        /delay 1s
        /nomodkey /notify FellowshipWnd FP_CreateCampsite leftmouseup
        /delay 5s ${Me.Fellowship.Campfire}
        /windowstate FellowshipWnd close
        /if (${Me.Fellowship.Campfire}) /echo Campfire Dropped
    /return
| ----------------------------------------------------------------------------
| SUB: Sort Array
| ----------------------------------------------------------------------------
    Sub SortArray(ArrayName, HiLo, SortHow)
        DEBUGN SortArray Enter ${ArrayName} ${HiLo} ${SortHow}
        /declare i                  int     local
        /declare j                  int     local
        /declare k                  int     local
        /declare l                  int     local
        /declare m                  int     local
        /declare TempSortedName     string  local ${HiLo}
        /declare TempPos            int     local 0
        /declare NewArrayPos        int     local 0
        /declare NewArraySize       int     local 0
        /declare TempArray[${${ArrayName}.Size}] string     local 0
        /declare TArray2[${${ArrayName}.Size}]   string     local 0
        /declare CArray[${${ArrayName}.Size}]    string     local TRUE
        /declare MArrayCount int    local 1
        /declare WArrayCount int    local 1
        /declare BArrayCount int    local 1
        /declare TempSwapHold       string  local
        /declare Swapped            int     local 1
        | Assign Array to temp array
        /for i 1 to ${${ArrayName}.Size}
            DEBUGN ${i} ${${ArrayName}[${i}]}
            /varset TempArray[${i}] ${${ArrayName}[${i}]}
        /next i
        /if (${ArrayName.Equal[dps]}) {
            /for i 1 to ${TempArray.Size}
                /if (${TempArray[${i}].Find[|weave]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset WeaveArray[${WArrayCount}] ${TempArray[${i}].Replace[|weave,]}
                    DEBUGN ${WeaveArray[${WArrayCount}]}
                    /if (${WArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc WArrayCount ${WArrayCount}+1
                } else /if (${TempArray[${i}].Find[|mash]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset MashArray[${MArrayCount}] ${TempArray[${i}].Replace[|mash,]}
                    DEBUGN ${MashArray[${MArrayCount}]}
                    /if (${MArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc MArrayCount ${MArrayCount}+1
                } else /if (${TempArray[${i}].Find[|ambush]} && ${TempArray[${i}].Arg[2,|].NotEqual[0]}) {
                    /varset BeforeArray[${BArrayCount}] ${TempArray[${i}].Replace[|ambush,]}
                    DEBUGN ${BeforeArray[${BArrayCount}]}
                    /if (${BArrayCount}>1) /varset TempArray[${i}] NULL
                    /varcalc BArrayCount ${BArrayCount}+1
                }
            /next i
        }
        | Move Array to Temp Array leaving out useless entries.
        /for m 1 to ${${ArrayName}.Size}
            /if (${TempArray[${m}].Length} && !${TempArray[${m}].Find[|0]} && ${TempArray[${m}].NotEqual[null]}) {
                /if (!${Select[${ArrayName},Buffs,Burn]} && ${Int[${TempArray[${m}].Arg[2,|]}]}==0) {
                    /echo Invalid Format for: ${ArrayName}${m}=${TempArray[${m}]} Second Tag: ${TempArray[${m}].Arg[2,|]} Should be a Numeric Value.
                    /echo Skipping Entry. ${ArrayName}${m}. Please correct and restart macro.
                    /continue
                }
                /varcalc NewArrayPos ${NewArrayPos}+1
                /varset TArray2[${NewArrayPos}] ${TempArray[${m}]}
                /varcalc NewArraySize ${NewArraySize}+1
            }
        /next m
        |Sort the Array if needed
        /if (!${Select[${ArrayName},Buffs,Burn]} && ${NewArraySize}>1) {
            /varset m ${NewArraySize}
            /while (${Swapped} && ${m}>1) {
                /varset Swapped 0
                /for k 2 to ${m}
                    /varcalc j ${k}-1
                    /if (${TArray2[${j}].Arg[2,|]} ${SortHow} ${TArray2[${k}].Arg[2,|]}) {
                        /varset TempSwapHold ${TArray2[${j}]}
                        /varset TArray2[${j}] ${TArray2[${k}]}
                        /varset TArray2[${k}] ${TempSwapHold}
                        /varset Swapped 1
                    }
                /next k
                /varcalc m ${m}-1
            }
        }
        | Bail if array is empty and turn off switch
        /if (!${NewArraySize}) {
            /if (${Defined[${ArrayName}On]}) {
                /if (${${ArrayName}On}) {
                    /varset ${ArrayName}On 0
                    /echo ${ArrayName}
                    /if (${ArrayName.NotEqual[heals]} && ${ArrayName.NotEqual[burn]}) {
                        /echo ERROR1: ${ArrayName}On=1 but section is empty. Turning ${ArrayName} off. Please check your ini file.
                        /beep
                        /delay 10
                    } else /if (${ArrayName.Equal[heals]} && !${AutoRezOn}) {
                        /echo ERROR: ${ArrayName}On=1 but section is empty. Turning ${ArrayName} off. Please check your ini file.
                        /beep
                        /delay 10
                    }
                }
            }
            /return
        }
        /deletevar ${ArrayName}
        /declare ${ArrayName}[${NewArraySize}] string outer
        /for l 1 to ${NewArraySize}
            /varset ${ArrayName}[${l}] ${TArray2[${l}]}
            DEBUGN  ${${ArrayName}[${l}]}
        /next l
        /if (${ArrayName.Equal[buffs]}) /call CreateTimersBuffs
        /if (${ArrayName.Equal[dps]}) /call CreateTimersDPS
        DEBUGN ${${ArrayName}.Size}
        DEBUGN SortArray Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers DPS
| ----------------------------------------------------------------------------
    Sub CreateTimersDPS
        | Declare timers for DPS duration spells and Attack buffs
        /declare i int local
        /varset DebuffCount 0
        /for i 1 to ${DPS.Size}
            /if (${Int[${DPS[${i}].Arg[2,|]}]}<101) {
                /if (!${Defined[DPSTimer${i}]}) {
                    /declare DPSTimer${i}       timer         outer 5
                    /declare ABTimer${i}        timer         outer 0
                    /declare FDTimer${i}        timer         outer 0
                } else {
                    /varset DPSTimer${i} 0
                    /varset ABTimer${i} 0
                    /varset FDTimer${i} 0
                }
            } else {
                /if (!${Defined[DBOTimer${i}]}) {
                    /declare DBOTimer${i}       timer         outer 0
                    /declare DBOList${i}        string        outer
                    /varcalc DebuffCount ${DebuffCount}+1
                } else {
                    /varset DBOTimer${i} 0
                    /varset DBOList${i}
                }
            }
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: Assign single heals - seperate single heals from group heals
| ---------------------------------------------------------------------------
    Sub FindSingleHeals
        DEBUGN Enter FindSingleHeals
        /declare i int local
        /declare j int local
        /declare SHCount int 0
        /declare HealHighPoint int  local 0
        /declare HealHighestPoint int  local 0
        /declare HealHighestPointMA int  local 0
        /declare HealPointTag string  local 0
        /declare HealSpell string  local
        /declare HealSpellRange int local 0
        /for i 1 to ${Heals.Size}
            /varset HealSpell ${Heals[${i}].Arg[1,|]}
            /varset HealPointTag ${Heals[${i}].Arg[3,|]}
            /if (${HealPointTag.Equal[MA]}) {
                /varset HealHighestPointMA ${Heals[${i}].Arg[2,|]}
            } else {
                /varset HealHighPoint ${Heals[${i}].Arg[2,|]}
            }
            /varset HealSpellRange ${Int[${Spell[${HealSpell}].Range}]}
            DEBUGN ${i} ${HealSpell} ${Spell[${HealSpell}].TargetType} ${Select[${Spell[${HealSpell}].TargetType},Single,Self]}
            /if (${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]} || ${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            } else /if (${Select[${Me.Class.Name},Druid,Shaman]} && (${HealSpell.Find[Intervention]} || ${HealSpell.Find[Survival]})) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            } else /if (${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[single]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${Heals[${i}].Arg[3,|].Find[tap]} || ${Heals[${i}].Arg[3,|].Find[pet]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && ${Select[${Heals[${i}].Arg[3,|]},MA,ME,pet]}) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            } else /if (${Spell[${HealSpell}].TargetType.Equal[Free Target]}) {
                /varcalc SHCount ${SHCount}+1
                /varset SingleHeal[${SHCount}] ${Heals[${i}]}
            }
            /if (${HealPointTag.NotEqual[MA]} && ${HealHighPoint}>${SingleHealPoint}) /varset SingleHealPoint ${HealHighPoint}
            /if (${HealPointTag.Equal[MA]} && ${HealHighestPointMA}>${SingleHealPointMA}) /varset SingleHealPointMA ${HealHighestPointMA}
            /if (${HealSpellRange}>${SingleHealPointRange}) /varset SingleHealPointRange ${HealSpellRange}
            DEBUGN ${SingleHealPoint} ${SingleHealPointRange}
        /next i
        /if (${SHCount}) /call SortArray SingleHeal 100|100 >
        /if (!${SingleHealPoint}) /varset SingleHealPoint 99
        /if (!${SingleHealPointMA}) /varset SingleHealPointMA ${SingleHealPoint}
        /if (!${SingleHealPointRange}) /varset SingleHealPointRange 200
        /if (${Debug}) {
        /for j 1 to ${SingleHeal.Size}
            DEBUGN ${j} ${SingleHeal[${j}]} ${Spell[${SingleHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${SingleHeal[${j}].Arg[1,|]}].Duration}
        /next j
        }
        DEBUGN Leave FindSingleHeals
    /return
| ----------------------------------------------------------------------------
| SUB: Assign Group heals
| ---------------------------------------------------------------------------
    Sub FindGroupHeals
        /if (!${Select[${Me.Class.ShortName},BST,CLR,SHM,DRU,PAL]}) /return
        DEBUGN Enter FindGroupHeals
        /declare i int local
        /declare j int local
        /declare GHCount int 0
        /declare HealSpell string  local
        /for i 1 to ${Heals.Size}
            /varset HealSpell ${Heals[${i}].Arg[1,|]}
            DEBUGN ${HealSpell}
            /if (!${HealSpell.Length} || ${HealSpell.Equal[null]} || ${Select[${Spell[${HealSpell}].TargetType},Single,Self]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[self]} || ${HealSpell.Find[Aegis of Superior Divinity]} || ${HealSpell.Find[Harmony of the Soul]}) /continue
            /if (${HealSpell.Find[Burst of Life]} || ${HealSpell.Find[Focused Celestial Regeneration]}) /continue
            /if (${Me.Class.Name.Equal[Shaman]} && ${Spell[${HealSpell}].Name.Find[Intervention]} || ${Me.Class.Name.Equal[Druid]} && ${Spell[${HealSpell}].Name.Find[Survival]}) /continue
            /if (${Spell[${HealSpell}].TargetType.Find[group v]} || ${Spell[${FindItem[=${HealSpell}].Spell}].TargetType.Find[group v]} || ${Spell[${HealSpell}].TargetType.Find[Targeted AE]} && !${Select[${Heals[${i}].Arg[3,|]},MA,ME]}) {
                /varcalc GHCount ${GHCount}+1
                /varset GroupHeal[${GHCount}] ${Heals[${i}]}
            }
        /next i
        DEBUGN ${GHCount}
        /if (${GHCount}) {
            /call SortArray GroupHeal 100|100 >
            /for j 1 to ${GroupHeal.Size}
                DEBUGN ${j} ${GroupHeal[${j}]} ${Spell[${GroupHeal[${j}].Arg[1,|]}].CastTime.Float} ${Spell[${GroupHeal[${j}].Arg[1,|]}].Duration}
            /next j
        }
        DEBUGN Leave FindGroupHeals
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Heals
| ----------------------------------------------------------------------------
    Sub CreateTimersHeals
        | Declare timers for Heal duration spells
        /declare j int local
        /declare k int local
        /declare q int local
        /for j 1 to ${GroupHeal.Size}
            | Group Heal duration timers
            /if (!${Defined[SpellGH${j}]}) {
                /declare SpellGH${j}    timer   outer   0
            } else {
                /varset SpellGH${j} 0
            }
        /next j
        /for j 1 to ${SingleHeal.Size}
            /for k 0 to 13
                | Self and MA duration heal timers for  out of group including Pets.
                /if (!${Defined[Spell${j}GM${k}]}) {
                    /declare Spell${j}GM${k}     timer   outer   0
                } else {
                    /varset Spell${j}GM${k} 0
                }
                DEBUGN Group heal Timers Spell${j}GM${k} ${Spell${j}GM${k}}
            /next k
        /next j
       | Declare timers for Pet heals
        /for q 1 to ${SingleHeal.Size}
            /if (!${Defined[PetHealTimer${q}]}) {
                /declare PetHealTimer${q} timer outer 0
            } else {
                /varset PetHealTimer${q} 0
            }
        /next q
        /for j 1 to ${SingleHeal.Size}
            /for k 0 to ${XSlotTotal}
                | XTarget Timers.
                /if (!${Defined[Spell${j}XT${k}]}) {
                    /declare Spell${j}XT${k}     timer   outer   0
                } else {
                    /varset Spell${j}XT${k} 0
                }
                DEBUGN XTarget heal Timers Spell${j}XT${k} ${Spell${j}XT${k}}
            /next k
        /next j

    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Rez
| ----------------------------------------------------------------------------
    Sub CreateTimersRez
        | Declare timers for Rez duration spells
        /declare m int local
        /for m 1 to 5
            /if (!${Defined[BattleRezTimer${m}]}) {
            /declare BattleRezTimer${m} timer outer 0
        } else {
            /varset BattleRezTimer${m} 0
        }
        /next m
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers Mez
| ----------------------------------------------------------------------------
    Sub CreateTimersMez
        | Declare timers for mezzing
        /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
            /declare l int local
            /for l 1 to 30
                /if (!${Defined[MezTimer${l}]}) {
                    /declare MezTimer${l} timer outer 0
                    /declare MMTimer${l} timer outer 0
                } else {
                    /varset MezTimer${l} 0
                    /varset MMTimer${l} 0
                }
            /next l
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Creat Timers Buffs
| ----------------------------------------------------------------------------
    Sub CreateTimersBuffs
        | Declare timers for Buff duration spells
        /declare o int local
        /declare p int local
        | Create buff timer for all buff in array
        /for o 1 to ${Buffs.Size}
           | Create timers for everyone in group plus 2 extra for MA buffs
            /for p 0 to 7
                /if (!${Defined[Buff${o}GM${p}]}) {
                    /declare Buff${o}GM${p}     timer   outer   0
                } else {
                    /varset Buff${o}GM${p} 0
                }
                /if (${Buffs[${o}].Find[|begfor]}) {
                    /varset Buff${o}GM${p} 600
                }
                /if (${Debug}) {
                    /echo \atDEBUG Buff Timers:Buff${o}GM${p} ${Buff${o}GM${p}}
                    |/delay 1
                }
            /next p
        /next o
    /return
| ----------------------------------------------------------------------------
| SUB: Create Timers GoM
| ----------------------------------------------------------------------------
    Sub CreateTimersGoM
        | Declare timers for Rez duration spells
        /declare i int local
        /for i 1 to ${GoMSpell.Size}
            /if (!${Defined[GoMSpellTimer${i}]}) {
                /declare GoMSpellTimer${i} timer outer 0
            } else {
                /varset GoMSpellTimer${i} 0
            }
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: ZCheck /call ZAxisCheck current ,Z to check, difference
| ----------------------------------------------------------------------------
    Sub ZAxisCheck(float Zcur, float Zdiff)
        | Move down if Z distance more than Zcheck due to levitation
        DEBUGN ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} Enter. - ${Me.FeetWet}
        /if (!${Me.FeetWet}) {
            /if (${Zcur}>=${Zdiff}) {
                /keypress CMD_MOVE_DOWN hold
                /delay 10 ${Math.Distance[${CampZLoc}:${Me.Z}]}<=${Zdiff}
                /keypress CMD_MOVE_DOWN
            }
        }
        DEBUGN ZCheck ZCur: ${Zcur} ZDiff: ${Zdiff} leave.
    /return
| ----------------------------------------------------------------------------
| SUB: Event_WornOff - secondary check to rebuff
| ----------------------------------------------------------------------------
    Sub Event_WornOff(string Line, string wospell, string wotarget)
        /varset EventFlag 1
        /if (!${RebuffOn}) /return
        /if (${wotarget.Equal[${Me}]}) /return
        /if (${AggroTargetID}) /return
        /if (${Me.Class.Name.Find[bard]}) /return
        /if (${wospell.Find[promised]}) /return
        DEBUGBUFF Event_WornOff Enter ${wospell} ${wotarget}
        /declare i int local
        /declare j int local
        /declare WOSpellTT string local 0
        /declare WOTries int local 0
        /declare WOMessage int local 0
        /if (${Me.Book[${wospell}]}) {
            /varset WOSpellTT ${Spell[${Me.Book[${Me.Book[${wospell}]}].ID}].TargetType}
        } else {
            /varset WOSpellTT ${Spell[${wospell}].TargetType}
        }
        /if (${WOSpellTT.Left[5].Equal[group]}) /varset WOSpellTT group
        DEBUGBUFF Event_WornOff ${WOSpellTT}
        /if (${Group.Member[${wotarget}].Index}) {
            /varset j ${Group.Member[${wotarget}].Index}
            /for i 1 to ${Buffs.Size}
                /if (${Buffs[${i}].Find[${wospell}]}) {
                    /varset Buff${i}GM${j} 0
                    /if (${wotarget.Equal[${MainAssist}]}) /varset Buff${i}GM7 0
                    /if (!${WOMessage}) {
                        /echo ${wotarget} needs ${wospell} because it wore off.
                        /varset WOMessage 1
                    }
                    /if (${Select[${WOSpellTT},single,group]} && ${Me.Buff[${wospell}].ID}) {
                        /if (${Select[${EverQuest.Server},fippy,vulak,ragefire,lockjaw]}==0) {
                            /while (${WOTries}<6) {
                                /removebuff "${wospell}"
                                /delay 5
                                /varcalc WOTries ${WOTries}+1
                                /if (${Me.Buff[${wospell}].ID}) {
                                    DEBUGBUFF Spell: ${WOSpellTT} Slot: ${Me.Buff[${wospell}].ID} Buff: ${i} GM: ${j}
                                } else {
                                    /break
                                }
                            }
                        }
                    }
                    | reset spell timer on caster
                    /varset Buff${i}GM0 0
                    /if (${ReadBuffsTimer}) /varset ReadBuffsTimer 0
                }
            /next i
        } else {
            /for i 1 to ${Buffs.Size}
                /if (${Buffs[${i}].Find[${wospell}]}) {
                    /if (${wotarget.Equal[${MainAssist}]}) /varset Buff${i}GM7 0
                    /if (!${WOMessage}) {
                        /echo ${wotarget} needs ${wospell} because it wore off.
                        /varset WOMessage 1
                    }
                    /if (${ReadBuffsTimer}) /varset ReadBuffsTimer 0
                }
            /next i
            /if (${IniNextTimer}) /varset IniNextTimer 0
        }
        DEBUGBUFF Event_WornOff Leave
    /return
|-----------------------------------------------------------------------------
| SUB: Capture Tells
| ----------------------------------------------------------------------------
    Sub Event_YouGotTell(Message, Fwho, Swhat)
        /varset EventFlag 1
        |/if (${GMailEvents.Find[tells]}) {
            | The Fwho.Equal[${Me.CleanName}'s pet] does NOT work, so I split it to 2 Finds and this works.
            /if ((${Me.Pet.ID} && ${Spawn[${Fwho}].ID}==${Me.Pet.ID}) || (${Fwho.Find[${Me.CleanName}]} && ${Fwho.Find[s pet]})) /return
            /if (!${Me.Pet.ID} && ${Swhat.Find[, master.]} && ${Swhat.Find[I am unable to wake an]}) /return
            /if (${Select[${Spawn[${Fwho}].Type},NPC,PET]}) /return
            /echo ====> ${Fwho} Sent you a Tell: ${Swhat} <====
        |/call GmailSend "You Got Tell From ${Fwho}, ${Swhat}"
        |} else {
        |    /doevents flush YouGotTell
        |}
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Merc state 4 = no gold membership
| ----------------------------------------------------------------------------
    Sub WriteBuffsMerc
        /if (${Mercenary.State.NotEqual[Active]} || ${EverQuest.GameState.NotEqual[INGAME]}) /return
        /if (${WriteBuffsMercTimer}) /return
        /if (!${Redguides}) /return
        /if (${AggroTargetID}) /return
        /if (${DanNetOn}) /return
        DEBUGBUFF WriteBuffsmerc Enter
        /declare i int local 0
        /declare k int local 0
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Mercenary.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Mercenary.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Mercenary.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Mercenary.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        | Need to check if you have to target your merc to get the buffs anymore.
        /target id ${Mercenary.ID}
        /delay 20 ${Target.BuffsPopulated}
        /for i 1 to 15
            DEBUGBUFF WriteBuffsMerc ${i} ${Mercenary.Buff[${i}]}
            /if (${Mercenary.Buff[${i}].Name.Length}) {
                /varset BuffList ${Mercenary.Buff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                DEBUGBUFF WriteBuffsMerc: ${i}-${BuffList}
                /varset Writebufflist ${Writebufflist}${BuffList}|
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Mercenary.ID}" Buffs "${Writebufflist}"
        |/delay 15
        /varset WriteBuffsMercTimer 30s
        DEBUGBUFF WriteBuffsMerc Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs Pet
| ----------------------------------------------------------------------------
    Sub WriteBuffsPet
        /if (!${Me.Pet.ID} || ${EverQuest.GameState.NotEqual[ingame]}) /return
        /if (${AggroTargetID}) /return
        |/if (!${Select[${Role},pettank,pullerpettank,hunterpettank]} && ${Spawn[${MainAssist} ${MainAssistType}].ID}!=${Me.Pet.ID}) /return
        /if (!${Select[${Role},pettank,pullerpettank,hunterpettank]}) /return
        /if (${WriteBuffsPetTimer}) /return
        /if (${DanNetOn}) /return
        /if (!${Redguides}) /return
        DEBUGBUFF WriteBuffPet Enter
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.Pet.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs
        | Write all current buffs to Kissassist_Buffs.ini file
        | Do I need to Target my pet here?
        /target id ${Me.Pet.ID}
        /delay 20 ${Target.BuffsPopulated}
        /for i 1 to 50
            DEBUGBUFF WriteBuffPet ${i} ${Target.Buff[${i}]}
            /if (${Me.PetBuff[${i}].Name.Length}) {
                /varset BuffList ${Me.PetBuff[${i}]}
            } else {
                /varset BuffList
            }
            /if (${BuffList.Length}) {
                DEBUGBUFF WriteBuffPet: ${i}-${BuffList}
                /varset Writebufflist ${Writebufflist}${BuffList}|
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Buffs "${Writebufflist}"
        /delay 15
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 0 to 39
            /varset Blockedbuff ${Me.BlockedPetBuff[${k}].Name}
            /if (${Blockedbuff.Length} && ${Blockedbuff.NotEqual[null]}) {
                /varset Blockedbufflist ${Blockedbufflist}${Blockedbuff}|
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.Pet.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedPetBuffWnd].Open}) /windowstate BlockedPetBuffWnd close
        /varset WriteBuffsPetTimer 30s
        DEBUGBUFF WriteBuffsPet Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Clean Buffs File
| ----------------------------------------------------------------------------
    Sub CleanBuffsFile
        /if (${CleanBuffsTimer}) /return
        /declare i int local
        /declare SectionList string local ${Ini["KissAssist_Buffs.ini"]}
        /declare SectionListCount int local ${SectionList.Count[|]}
        /if (${SectionListCount}==0) /return
        /varcalc SectionListCount ${SectionListCount}-1
        /declare SectionName string local
        /for i 1 to ${SectionListCount}
            /varset SectionName ${SectionList.Arg[${i},|]}
            DEBUGBUFF CleanBuffsFile ${i} ${SectionName} ${Math.Calc[${Ini["KissAssist_Buffs.ini",${SectionName},Day]}-${Time.Day}]} ${Math.Calc[${Time.Hour}-${Ini["KissAssist_Buffs.ini",${SectionName},Hour]}]} Day: ${Time.Day} Hour: ${Time.Hour}
            /if (${Ini["KissAssist_Buffs.ini",${SectionName},Day].NotEqual[${Time.Day}]}) {
                /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
                /continue
            }
            /if (${Math.Calc[${Time.Hour}-${Ini["KissAssist_Buffs.ini",${SectionName},Hour]}]}!=0) /ini "KissAssist_Buffs.ini" ${SectionName} NULL NULL
        /next i
        /varset CleanBuffsTimer 10m
    /return
| ----------------------------------------------------------------------------
| SUB: AE check - cast area effect spells depending on set number of mobs
| ----------------------------------------------------------------------------
    Sub AECheck(int prm_ListMobs)
        /if (!${AEOn}) /return
        /if (${Target.Type.Equal[corpse]}) /return
        /if (!${AggroTargetID}) /return
        DEBUGCOMBAT AECheck Enter
        /declare i int local
        /declare j int local
        /declare AESpell string local
        /declare AEMobCount int local
        /declare AETarget string local
        /declare AETargetID int local
        /declare AERange int local
        /declare MobCountTemp int local 0
        /declare int_SpawnCountXT int local 0
        /declare int_SpawnCountAE int local 0
        /declare s_WorkSpawn spawn local
        
        /call MobRadar los ${AERadius} AECheck
        | Adjust mobcount by subtracting mobs not on xtarget
        DEBUGCOMBAT AECheck Mobcount: ${MobCount} ${prm_ListMobs}
        /if (!${MobCount}) /return
        /varset MobCountTemp ${SpawnCount[npc xtarhater targetable los radius ${AERadius} zradius 50 noalert 3]}
        /if (${MobCountTemp}<=0) /return
        /if (${IAmMA} && ${TargetSwitchingOn} && ${Target.ID} && ${Target.ID}!=${MyTargetID} && ${CombatStart}) /call CombatTargetCheck 1
        /for i 1 to ${AE.Size}
            /varset AESpell ${AE[${i}].Arg[1,|]}
            /if (${AESpell.Equal[null]}) /continue
            /varset AEMobCount ${AE[${i}].Arg[2,|]}
            /varset AETarget ${AE[${i}].Arg[3,|]}
            | Check if AEspell is ready to use if not skip it
            /if (${AESpell.NotEqual[burn]} && !${Me.SpellReady[${Spell[${AESpell}].RankName}]} && !${Me.AltAbilityReady[${AESpell}]} && !${Me.CombatAbilityReady[${Spell[${AESpell}].RankName}]} && !${Me.AbilityReady[${AESpell}]} && !${AESpell.Find[command:]}) /continue
            /if (${FindItem[=${AESpell}].ID} && !${Me.ItemReady[=${AESpell}]}) /continue
            /if (${AEMobCount}<=${MobCountTemp}) {
                /if (${AETarget.Equal[null]} || ${AETarget.Equal[Mob]} || ${AETarget.Equal[Single]}) {
                    /varset AETargetID ${MyTargetID}
                } else /if (${AETarget.Equal[Me]}) {
                    /varset AETargetID ${Me.ID}
                } else /if (${AETarget.Equal[MA]}) {
                    /varset AETargetID ${Spawn[=${MainAssist}].ID}
                } else /if (${AETarget.Equal[Pet]}) {
                    /varset AETargetID ${Me.Pet.ID}
                } else /if (${AESpell.Equal[burn]} && !${BurnActive}) {
                    /echo AE-> ${MobCountTemp} Mobs: Activating BURN
                    /call Burn
                    /return
                }
                /varset AERange ${Spell[${AESpell}].AERange}
                /if (!${AERange}) {
                    /varset AERange ${AERadius}
                }
                /if (${Spawn[id ${AETargetID}].ID}) {
                    /vardata s_WorkSpawn Spawn[id ${AETargetID}].ID
                    /varset int_SpawnCountXT ${SpawnCount[npc xtarhater loc ${s_WorkSpawn.X} ${s_WorkSpawn.Y} radius ${AERange}]}
                    /varset int_SpawnCountAE ${SpawnCount[npc loc ${s_WorkSpawn.X} ${s_WorkSpawn.Y} radius ${AERange}]}
                    /if (${Me.XTarget[${XTSlot}].ID} && ${Me.XTarget[${XTSlot}].TargetType.NotEqual[Auto Hater]}) /varcalc int_SpawnCountXT ${int_SpawnCountXT}+1
                    DEBUGCOMBAT AECheck SpawnCountXT: ${int_SpawnCountXT} SpawnCountAE: ${int_SpawnCountAE} AERange: ${AERange}
                    /if (${AETarget.NotEqual[Single]}) {
                        /if (${s_WorkSpawn.ID} && ${int_SpawnCountXT} < ${int_SpawnCountAE}) {
                            /if (!${SpamTimer2}) {
                                /echo AE-> Casting ${AESpell} now would aggro more mobs(${int_SpawnCountAE}) than we have on xtarget(${int_SpawnCountXT})
                                /varset SpamTimer2 20
                            }
                            /if (${prm_ListMobs}) {
                                /for j 1 to ${int_SpawnCountAE}
                                    /vardata WorkSpawn NearestSpawn[${j},npc loc ${s_WorkSpawn.X} ${s_WorkSpawn.Y} radius ${AERange}].ID
                                    /echo Spawn Info: ${j} - ${WorkSpawn.Name} - Direction from you: ${WorkSpawn.HeadingTo} Mob X,Y: ${WorkSpawn.X},${WorkSpawn.Y} 
                                /next j
                                /vardata WorkSpawn ClearSpawnValue
                            }
                            /continue
                        }
                    }
                    /if (!${ConOn} || !${AE[${i}].Find[|cond]} || ${If[${Cond[${AE[${i}].Mid[${Math.Calc[${AE[${i}].Find[|cond]}+5]},3]}]},1,0]}) {
                        /if (${AETarget.Equal[Single]}) {
                            /call CastWhat "${AESpell}" ${AETargetID} AoE 0 0
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /echo AE-> ${AESpell} on Single target  >> ${Spawn[${AETargetID}].CleanName} <<
                            }
                            /continue
                        } else {
                            /call CastWhat "${AESpell}" ${AETargetID} AoE 0 0
                            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                                /echo AE-> ${MobCountTemp} Mobs: Casting AE ${AESpell}
                            }
                        }
                    }
                } else {
                    /break
                }
            }
        /next i
        DEBUGCOMBAT AECheck Leave
    /return
| ----------------------------------------------------------------------------
| SUB: WriteDebuffs
| ----------------------------------------------------------------------------
    Sub WriteDebuffs
        /if (${EverQuest.GameState.NotEqual[ingame]}) /return
        /if (${DanNetOn}) /return
        DEBUGHEALS WriteDebuffs Enter - ${NeedCuring}
        /declare DebuffList string local
        /declare IAmDeBuffed int local ${Math.Calc[${Int[${Me.Poisoned.ID}]}+${Int[${Me.Diseased.ID}]}+${Int[${Me.Cursed.ID}]}+${Int[${Me.Corrupted.ID}]}+${Int[${Me.Mezzed.ID}]}+${Int[${Me.Song[Restless Curse].ID}]}]}

        /if (${IAmDeBuffed}) {
            /if (!${NeedCuring}) {
                /varset NeedCuring 1
                /varset DebuffList ${IAmDeBuffed}|${Int[${Me.Poisoned.ID}]}|${Int[${Me.Diseased.ID}]}|${Math.Calc[${Int[${Me.Cursed.ID}]}+${Int[${Me.Song[Restless Curse].ID}]}]}|${Int[${Me.Corrupted.ID}]}|${Int[${Me.Mezzed.ID}]}
                /ini "KissAssist_Buffs.ini" "${Me.ID}" Debuffs "${DebuffList}"
                DEBUGHEALS WriteDebuffs Writing debuffs to ini file
            }
        } else {
            /if (${NeedCuring}) {
                /varset NeedCuring 0
                /varset DebuffList
                /ini "KissAssist_Buffs.ini" "${Me.ID}" Debuffs "${DebuffList}"
                DEBUGHEALS WriteDebuffs Clearing debuffs from ini file
            }
        }
        DEBUGHEALS WriteDebuffs Leave - ${NeedCuring}
    /return
| ----------------------------------------------------------------------------
| SUB: CheckCures - Check Character first then cure list.
| ----------------------------------------------------------------------------
    Sub CheckCures(string sentFrom)
        /if (!${CuresOn}) /return
        /if (${Me.Invis} && !${AggroTargetID}) /return
        /if (${Medding} && ${MedCombat}) /return
        DEBUGHEALS CheckCures Enter ${sentFrom}
        /declare i int local
        /declare j int local
        /declare IniIDList string local
        /declare IniIDCount int local 0
        /declare IniDebuffCount string local 0
        /declare IniDebuffList string local
        /declare CuretoCast string local
        /declare CTID int local
        /declare CTName string
        /declare CondNo int local 0
        /declare C1stPart string
        /declare C2ndPart string
        /declare C3rdPart string
        /declare CureCast int local 0
        /if (${HealsOn}) {
            /if (!${LastHealCheck} || ${AggroTargetID}) {
                /call CheckHealth CheckCures
                /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
            }
        }
        |CuresOn 0=Off, 1=Everyone in zone, 2=Self Only, 3=Group Only. 
        /if (${IAmMA} && ${TargetSwitchingOn} && ${Target.ID} && ${Target.ID}!=${MyTargetID} && ${CombatStart}) /call CombatTargetCheck 1
        | Check Buffs from ini
        /if (${CuresOn}==2) {
            /varset IniIDList ${Me.ID}
            /varset IniIDCount 1
        } else {
            /if (!${DanNetOn}) {
                /varset IniIDList ${Ini["KissAssist_Buffs.ini"]}
                /varcalc IniIDCount ${IniIDList.Count[|]}
            } else {
                /if (${Zone.ShortName.Find[_]}) {
                    /varset IniIDList ${DanNet.Peers[zone_${Zone.ShortName}]}
                } else {
                    /varset IniIDList ${DanNet.Peers[zone_${EverQuest.Server.Lower}_${Zone.ShortName}]}
                }
                /varset IniIDCount ${IniIDList.Count[|]}
            }
        }
        /if (!${IniIDCount}) /return
        /declare pIDList[${IniIDCount}] string local 
        /for i 1 to ${IniIDCount}
            /varset pIDList[${i}] ${IniIDList.Arg[${i},|]}
        /next i

        | For each Character
        /for j 1 to ${IniIDCount}
            /if (!${DanNetOn} || ${CuresOn}==2) {
                /varset CTID ${Spawn[${pIDList[${j}]}].ID}
            } else {
                /varset CTID ${Int[${Spawn[=${pIDList[${j}]}].ID}]}
            }
            /if (!${CTID}) /continue
            /if (${Spawn[${CTID}].Type.Equal[Corpse]}) /continue
            /if (${Spawn[${CTID}].Distance}>100) /continue
            /varset CTName ${Spawn[id ${CTID}].CleanName}
            /if (${CuresOn}==3) {
                /if (${Group} && !${Group.Member[${CTName}].Index}) /continue
            }

            /varset CureCast 0
            | For each cure.
            /for i 1 to ${Cures.Size}
                /if (!${Cures[${i}].Length} || ${Cures[${i}].Equal[null]}) /continue
                /varset C1stPart ${Cures[${i}].Arg[1,|]}
                /if (${Cures[${i}].Arg[2,|].Length}==0 || ${Cures[${i}].Arg[2,|].Find[cond]}) {
                    /varset C2ndPart
                    /varset C3rdPart everyone
                } else /if (${Cures[${i}].Arg[2,|].Equal[me]}) {
                    /varset C2ndPart
                    /varset C3rdPart me
                } else {
                    /varset C2ndPart ${Cures[${i}].Arg[2,|]}
                    /if (${Cures[${i}].Arg[3,|].Length}==0 || ${Cures[${i}].Arg[3,|].Find[cond]}) {
                        /varset C3rdPart everyone
                    } else /if (${Cures[${i}].Arg[3,|].Equal[me]}) {
                        /varset C3rdPart me
                    } else {
                        /varset C3rdPart everyone
                    }
                }
                /if (${ConOn} && ${Cures[${i}].Find[|cond]}) {
                    /varset CondNo ${Cures[${i}].Mid[${Math.Calc[${Cures[${i}].Find[|cond]}+5]},3]}
                } else {
                    /varset CondNo 0
                }
            
                |CuresOn 1=Everyone, 3=Group Only
                /if (${C3rdPart.Equal[me]}) {
                    /if (${CTID}!=${Me.ID}) /continue
                } else /if (${C3rdPart.NotEqual[everyone]}) {
                    /continue
                }
                | If spell NOT ready then skip it.
                /if (!${Select[TRUE,${Me.SpellReady[${Spell[${C1stPart}].RankName}]},${Me.AltAbilityReady[${C1stPart}]},${Me.CombatAbilityReady[${Spell[${C1stPart}].RankName}]},${Me.ItemReady[${C1stPart}]}]}) {
                    /continue
                }
                /varset CuretoCast
                /varset IniDebuffCount 0
                /if (${CTID}!=${Me.ID}) {
                    /if (!${DanNetOn}) {
                        /varset IniDebuffCount ${Ini["KissAssist_Buffs.ini",${pIDList[${j}]},"Debuffs"]}
                        /if (!${Int[${IniDebuffCount.Arg[1,|]}]}) /break
                    } else {
                        /if (${MacroQuest.Parser}!=2) {
                            /squelch /engine parser 2 noauto
                            /while (${MacroQuest.Parser}!=2) {
                                /delay 5
                            }
                        }
                        /dquery ${pIDList[${j}]} -q ${Parse[0,"Math.Calc[${Int[${Me.Poisoned.ID}]}+${Int[${Me.Diseased.ID}]}+${Int[${Me.Cursed.ID}]}+${Int[${Me.Song[Restless Curse].ID}]}+${Int[${Me.Corrupted.ID}]}+${Int[${Me.Mezzed.ID}]}]"]} -o DNout -t ${DanNetDelay}
                        /if (${Int[${DNout}]}==0) {
                            /varset IniDebuffCount 0|0
                            /break
                        } else {
                            /varset IniDebuffCount ${Int[${DNout}]}
                            /dquery ${pIDList[${j}]} -q ${Parse[0,"Int[${Me.Poisoned.ID}]}|${Int[${Me.Diseased.ID}]}|${Math.Calc[${Int[${Me.Cursed.ID}]}+${Int[${Me.Song[Restless Curse].ID}]}].Int}|${Int[${Me.Corrupted.ID}]}|${Int[${Me.Mezzed.ID}]"]} -o DNout -t ${DanNetDelay}
                            /varset IniDebuffCount ${IniDebuffCount}|${DNout}
                        }
                    }
                } else {
                    /varset IniDebuffCount ${Math.Calc[${Int[${Me.Poisoned.ID}]}+${Int[${Me.Diseased.ID}]}+${Int[${Me.Cursed.ID}]}+${Int[${Me.Corrupted.ID}]}+${Int[${Me.Mezzed.ID}]}]}+${Int[${Me.Song[Restless Curse].ID}]}
                    /if (!${Int[${IniDebuffCount}]}) /break
                    /varset IniDebuffCount ${IniDebuffCount}|${Int[${Me.Poisoned.ID}]}|${Int[${Me.Diseased.ID}]}|${Math.Calc[${Int[${Me.Cursed.ID}]}+${Int[${Me.Song[Restless Curse].ID}]}]}|${Int[${Me.Corrupted.ID}]}|${Int[${Me.Mezzed.ID}]}
                }
                DEBUGHEALS CheckCures ${IniDebuffCount} ${C1stPart} ${C2ndPart} ${C3rdPart}
                /if (${C2ndPart.Length}>0) {
                    /if (${C2ndPart.Equal[poison]} && ${IniDebuffCount.Arg[2,|]}>0) {
                        /varset CuretoCast ${C1stPart}
                    } else /if (${C2ndPart.Equal[disease]} && ${IniDebuffCount.Arg[3,|]}>0) {
                        /varset CuretoCast ${C1stPart}
                    } else /if (${C2ndPart.Equal[curse]} && ${IniDebuffCount.Arg[4,|]}>0) {
                        /varset CuretoCast ${C1stPart}
                    } else /if (${C2ndPart.Equal[corruption]} && ${IniDebuffCount.Arg[5,|]}>0) {
                        /varset CuretoCast ${C1stPart}
                    } else /if (${C2ndPart.Equal[mezzed]} && ${IniDebuffCount.Arg[6,|]}>0) {
                        /varset CuretoCast ${C1stPart}
                    }
                    /if (!${CuretoCast.Length}) /continue
                } else {
                    /varset CuretoCast ${C1stPart}
                }
                | Check cures for group component since they don't seem to work on out of group toons
                /if (${Spell[${CuretoCast}].TargetType.Equal[group v1]} && !${Spawn[id ${CTID} group].ID}) {
                    /if (!${Defined[CureTimer${CTID}${i}]}) {
                        /declare CureTimer${CTID}${i} timer outer 30s
                        DEBUGHEALS CheckCures /echo declare CureTimer${CTID}${i}
                    } else /if (!${CureTimer${CTID}${i}}) {
                        /varset CureTimer${CTID}${i} 30s
                        DEBUGHEALS CheckCures /echo varset CureTimer${CTID}${i}
                    }
                    /if (${DebugHeals} && !${CureTimer${CTID}${i}}) /echo CURING: >> ${CTName} << is not in your group and >> ${CuretoCast} << is a group spell.
                    /continue
                }
                /call CastWhat "${CuretoCast}" ${CTID} Cure ${CondNo} 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                    /call BroadCast o "CURING: >> ${CTName} << with ${CuretoCast}"
                    /varset CureCast 1
                    /if (${HealsOn}) {
                        /call CheckHealth CheckCures
                        /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
                    }
                }
            | Bottom Each Cure
            /next i
            /if (${CTID}==${Me.ID} && ${CureCast}) {
                /if (!${DanNetOn}) {
                    /varset IniDebuffCount ${Math.Calc[${Int[${Me.Poisoned.ID}]}+${Int[${Me.Diseased.ID}]}+${Int[${Me.Cursed.ID}]}+${Int[${Me.Corrupted.ID}]}+${Int[${Me.Mezzed.ID}]}]}+${Int[${Me.Song[Restless Curse].ID}]}
                    /if (!${IniDebuffCount}) {
                        /varset NeedCuring 1
                        /call WriteDebuffs 
                    }
                }
            }
            /if (${HealsOn}) {
                /if (!${LastHealCheck} || ${AggroTargetID}) {
                    /call CheckHealth CheckCures
                    /if (${HealInterval}) /varcalc LastHealCheck ${HealInterval}*10
                }
            }
        | Bottom Each Character
        /next j
        /if (${MacroQuest.Parser}==2) /squelch /engine parser 1
        DEBUGHEALS CheckCures Leave ${sentFrom}
    /return
| ----------------------------------------------------------------------------
| SUB: WaitSubs - bunch of crap to call while medding standing around etc
| ----------------------------------------------------------------------------
    Sub WaitSubs
        DEBUGN WaitSubs Enter
        /if (${Me.Hovering}) /call PauseWhileHovering WaitSubs
        /call WriteDebuffs
        /if (${CuresOn}) {
            /call CheckCures WaitSubs
            /if (${HealsOn}) /call CheckHealth WaitSubs
        } else /if (${HealsOn}) {
            /call CheckHealth WaitSubs
        }
        /if (${MezOn}) {
            /call MezCheck WaitSubs
        }
        /call WriteBuffs
        /if (${AutoRezOn}) /call RezCheck all
        /call CanIDoStuff
        /call CastMana WaitSubs
        /if (${PetOn}) /call DoPetStuff
        /if (${BuffsOn}) {
            /call CheckBuffs ${ForceBuffs}
            /varset ForceBuffs 0
            /if (${KABegActive}) /call CheckBegforBuffs
        }
        /if (${MercOn}) /call MercsDoWhat
        DEBUGN WaitSubs Leave
    /return
| ----------------------------------------------------------------------------
| SUB: BroadCast - Handles echos and messages in mq2irc and mq2eqbc
| ----------------------------------------------------------------------------
    Sub BroadCast(msgcolor, message)
        /if (${msgcolor.Equal[null]}) /varset msgcolor w
        /if (${EQBCOn}) {
            /if (${Macro.IsTLO[EQBC]}) {
                /if (${EQBC.Connected}) {
                    /if (TRUE) /${BroadCastSay} [+${msgcolor}+] [${Time}] ${message} [+x+]
                } else {
                    /echo You are NOT connected to an EQBC Server. Please check your connection.
                    /echo ${message}
                }
            } else {
                /echo EQBC is Required, but the plugin is NOT Loaded.
                /echo ${message}
            }
        } else /if (${DanNetOn}) {
            /if (${Macro.IsTLO[DanNet]}) {
                /if (${DanNet.PeerCount}) {
                    /if (TRUE) /${BroadCastSay} \a${msgcolor} [${Time}] ${message} \aw
                } else {
                    /echo DanNet is Loaded but no Peers are connected.
                    /echo ${message}
                }
            } else {
                /echo DanNet is Required, but the plugin is NOT Loaded.
                /echo ${message}
            }
        } else {
            /echo ${message}
        }
        /if (${Bool[${Plugin[MQ2IRC]}]} && ${IRCOn}) /i say ${message}
    /return
| ----------------------------------------------------------------------------
| SUB: Campfire ${Window[FellowshipWnd].Child[FP_CampPage].Child[FP_CampsiteViewer].Text}
| ----------------------------------------------------------------------------
    Sub Campfire
        /if (!${CampfireOn}) /return
        /if (${CampfireTimer}) /return
        /if (${Me.Fellowship.CampfireZone.ID} && (${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]} || ${Me.Fellowship.CampfireZone.Name.Find[guild hall]})) /return
        /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>${CampRadius}) /return
        /if (${AggroTargetID}) /return
        /if (${CombatStart}) /return
        /if (${SpawnCount[pc radius 50 fellowship]}>=3) {
            /call Bind_Campfire
        } else {
            /echo Not enough fellowship members trying again in 5 minutes
            /varset CampfireTimer 5m
        }
        /doevents TooSteep
    /return
| ----------------------------------------------------------------------------
| SUB: NamedWatch
| ----------------------------------------------------------------------------
    Sub NamedWatch(int IgnoreTarget)
        /if (!${BurnAllNamed}) {
            | For GMail Notify Only
            |/if (${GMailEvents.Find[named]} && ${SpawnCount[xtarhater named radius ${MeleeDistance}]}) {
            |    /call GmailSend "${Spawn[xtarhater named radius ${MeleeDistance}].CleanName} is a NAMED and its in CAMP!"
            |    /varset NamedCheck 1
            |}
        } else {
            | BurnAllNameds is ON, So Do this.
            /if (!${IgnoreTarget}) {
                | Use Target and MyTargetID to ID the Named.
                /if (${BurnAllNamed}==1 && ${Spawn[${MyTargetID}].Named}) {
                    /popup *** Mob:(${Target.CleanName}) is a NAMED!
                    /echo *** Mob:(${Target.CleanName}) is a NAMED!
                    /if (${BurnAllNamed}) /call Burn
                    /varset NamedCheck 1
                    |/if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
                } else {
                    | Setting BurnAllNamed=2 will only burn mobs on the list.
                    /declare i int local
                    /varset MobsToBurn ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
                    /if (${MobsToBurn.Find[null]}) /return
                    /for i 1 to 25
                        /if (${MobsToBurn.Arg[${i},,].Length} && !${MobsToBurn.Find[null]} && ${Spawn[${MobsToBurn.Arg[${i},,]}].ID}==${MyTargetID} && ${Spawn[${MobsToBurn.Arg[${i},,]}].CleanName.Equal[${Target.CleanName}]}) {
                            /call Burn
                            /popup *** Mob:(${Target.CleanName}) is a NAMED!
                            /echo *** Mob:(${Target.CleanName}) is a NAMED!
                            |/if (${GMailEvents.Find[named]}) /call GmailSend "${Target.CleanName} is a NAMED and its in CAMP!"
                            /varset NamedCheck 1
                            /break
                        }
                    /next i
                }
            } else {
                | BurnAllNameds is ON, but I am NON-Melee, So Using SpawnCount and Spawn info to determine if Named.
                /if (${BurnAllNamed}==1 && ${SpawnCount[xtarhater named radius ${MeleeDistance}]}) {
                    /popup *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                    /echo *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                    /varset MyTargetID ${Spawn[xtarhater named radius ${MeleeDistance}].ID}
                    /varset MyTargetName ${Spawn[id ${MyTargetID}].CleanName}
                    /call Burn
                    /varset NamedCheck 1
                    /varset MyTargetID 0
                    |/if (${GMailEvents.Find[named]}) /call GmailSend "${Spawn[xtarhater named radius ${MeleeDistance}].CleanName} is a NAMED and its in CAMP!"
                } else {
                    | Setting BurnAllNamed=2 will only burn mobs on the list.
                    /declare i int local
                    /varset MobsToBurn ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
                    /if (${MobsToBurn.Find[null]}) /return
                    /for i 1 to 25
                        /if (${MobsToBurn.Arg[${i},,].Length} && ${Spawn[${MobsToBurn.Arg[${i},,]}].ID}==${Spawn[xtarhater named radius ${MeleeDistance}].ID} && ${Spawn[${MobsToBurn.Arg[${i},,]}].CleanName.Equal[${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}]}) {
                            /varset MyTargetID ${Spawn[xtarhater named radius ${MeleeDistance}].ID}
                            /varset MyTargetName ${Spawn[id ${MyTargetID}].CleanName}
                            /call Burn
                            /popup *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                            /echo *** Mob:(${Spawn[xtarhater named radius ${MeleeDistance}].CleanName}) is a NAMED!
                            |/if (${GMailEvents.Find[named]}) /call GmailSend "${Spawn[xtarhater named radius ${MeleeDistance}].CleanName} is a NAMED and its in CAMP!"
                            /varset NamedCheck 1
                            /varset MyTargetID 0
                            /break
                        } else /if (${MobsToBurn.Arg[${i},,].Length}==0 || ${MobsToBurn.Arg[${i},,].Equal[null]}) {
                            /break
                        }
                    /next i
                }
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Scan ini file for errors in spelling or missing items
| ----------------------------------------------------------------------------
    Sub ScanIni(string p_Sections)
        /declare int_i             int    local 1
        /declare int_j             int    local 1
        /declare int_Count         int    local 0 
        /declare int_CountEnrties  int    local 0
        /declare int_CountErrors   int    local 0
        /declare str_Sections      string local
        /declare str_Section       string local null
        /declare str_iniKey        string local
        /declare str_SummonedStuff string local null
        
        /if (!${p_Sections.Length} || ${p_Sections.Equal[null]} || ${p_Sections.Equal[all]}) {
            /varset str_Sections Buffs|DPS|Burn|Heals|AE|Cures|Pet|PetBuffs|GoM|Mez|Aggro|Pull
        } else {
            /varset str_Sections ${p_Sections}
        }
        
        /if (${str_Sections.Find[Buffs]}) {
            /for int_i 1 to ${BuffsSize}
                /varset str_iniKey ${Ini["${IniFileName}",Buffs,Buffs${int_i}]}
                /if (${str_iniKey.NotEqual[null]}) {
                    /if (${str_iniKey.Arg[2,|].Equal[summon]}) {
                        /if (${str_SummonedStuff.Equal[null]}) {
                            /varset str_SummonedStuff ${str_iniKey.Arg[3,|]}|
                        } else {
                            /varset str_SummonedStuff ${str_SummonedStuff}${str_iniKey.Arg[3,|]}|
                        }
                    }
                }
            /next int_i
        }

        /for int_j 1 to ${Math.Calc[${str_Sections.Count[|]}+1]}
            /varset str_Section ${str_Sections.Arg[${int_j},|]}
            /varset int_CountEnrties 0
            /varset int_CountErrors 0
            /varset int_Count 0
            /echo ---------------->> Scanning ${str_Section} <<----------------
            /if (${Select[${str_Section},Buffs,DPS,Burn,Heals,AE,Cures,PetBuffs,GoM,Aggro]}) {
                /if (${Defined[${str_Section}Size]}) {
                    /varset int_Count ${${str_Section}Size}
                }
            } else /if (${str_Section.Equal[Pet]}) {
                /varset int_Count 3
            } else /if (${str_Section.Equal[Mez]}) {
                /varset int_Count 2
            } else /if (${str_Section.Equal[Pull]}) {
                /varset int_Count 1
            }
            /if (${int_Count}) {
                /for int_i 1 to ${int_Count}
                    /if (${Select[${str_Section},DPS,Burn,Heals,AE,Cures,Aggro]}) {
                        /varset str_iniKey ${Ini["${IniFileName}",${str_Section},${str_Section}${int_i}]}
                    } else /if (${str_Section.Equal[Buffs]}) {
                        /if (${Select[${str_iniKey.Arg[2,|]},summon,remove,begfor]}) {
                            /varset str_iniKey null
                        } else /if (${str_SummonedStuff.NotEqual[null]} && ${str_SummonedStuff.Find[${str_iniKey.Arg[1,|]}|]}) {
                            /varset str_iniKey null
                        } else {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},${str_Section}${int_i}]}
                        }
                    } else /if (${str_Section.Equal[Pet]}) {
                        /if (${int_i}==1) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},PetSpell]}
                        } else /if (${int_i}==2) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},PetShrinkSpell]}
                        } else /if (${int_i}==3) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},PetBreakMezSpell]}
                        } else {
                            /break
                        }
                    } else /if (${str_Section.Equal[PetBuffs]}) {
                        /varset str_iniKey ${Ini["${IniFileName}",Pet,${str_Section}${int_i}]}
                    } else /if (${str_Section.Equal[GoM]}) {
                        /varset str_iniKey ${Ini["${IniFileName}",${str_Section},GomSpell${int_i}]}
                    } else /if (${str_Section.Equal[Mez]}) {
                        /if (${int_i}==1) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},MezSpell]}
                        } else /if (${int_i}==2) {
                            /varset str_iniKey ${Ini["${IniFileName}",${str_Section},MezAESpell]}
                        } else {
                            /break
                        }
                    } else /if (${str_Section.Equal[Pull]}) {
                        /varset str_iniKey ${Ini["${IniFileName}",${str_Section},PullWith]}
                    }
                    /if (${str_iniKey.Left[1].Equal[;]} || ${str_iniKey.Equal[null]}) /continue
                    /while (1) {
                        DEBUGN ScanIni: ${str_Section}${int_i}=${str_iniKey}
                        | find out if there is a Rank and fix spell name.
                        /call SpellRankCheck "${str_iniKey}"
                        /varset str_iniKey ${Macro.Return}
                        DEBUGN ScanIni: ${str_iniKey} after return
                        /if (${str_iniKey.Find[|]}) /varset str_iniKey ${str_iniKey.Arg[1,|]}
                        /if (${str_iniKey.Find[Command:]}) /break
                        /if (${str_Section.Equal[GoM]} && ${str_iniKey.Find[Gift Of Mana]}) /break
                        /if (${str_Section.Equal[AE]} && ${str_iniKey.Find[Burn]}) /break
                        /if (${str_Section.Equal[Pull]} && ${Select[${str_iniKey},melee,pet]}) {
                            /varcalc int_CountEnrties ${int_CountEnrties}+1
                            /break
                        }
                        /if (!${Me.Book[${str_iniKey}]} && !${Me.CombatAbility[${str_iniKey}]} && !${Me.AltAbility[${str_iniKey}]} && !${FindItem[=${str_iniKey}].ID} && ${str_iniKey.NotEqual[banestrike]} && !${Me.Skill[${str_iniKey}]}) {
                            /echo ...ERROR: ${str_Section}${int_i}=${str_iniKey} unable to find as a AA, Combat Ability, Item, Skill, or Spell
                            /varcalc int_CountErrors ${int_CountErrors}+1
                        }
                        /varcalc int_CountEnrties ${int_CountEnrties}+1
                        /break
                    }
                /next int_i
            }
            /if (!${int_CountEnrties}) {
                /echo -- Nothing defined in this section
            } else /if (!${int_CountErrors}) {
                /echo -- No Spelling Errors or Missing Items Detected
            }
        /next int_j
    /return
| ----------------------------------------------------------------------------
| SUB: IniWrite - quick ini entry for spells,  aas, discs, items
| ----------------------------------------------------------------------------
    Sub Bind_IniWrite(IWSection, IWE1, IWE2, IWE3, IWE4, IWE5, IWE6, IWE7, IWE8)
    DEBUGN Bind_IniWrite: Enter
    /declare keyNum int local 0
    /declare IWPercent int local 100
    /declare IWSlot int local 1
    /declare IWType string local ${IWE1}
    /declare IWTypeSingle string local
    /declare IWArray int local ${${IWSection}.Size}
    /declare IWEmptySlot string local 0
    /declare IWEntry string local
    /declare i int local
    /declare j int local
    /declare k int local
    | Determine if single type
    /if (${Select[${IWType},aa,disc,item,spell,clear]}) {
        | Set Item
        /if (${IWType.Equal[item]}) {
            /if (!${Cursor.ID}) {
                /echo ..SET${IWSection}: You need to put the item on your cursor.
                /return
            }
            /varset IWTypeSingle ${Cursor.Name}
            /echo ${IWTypeSingle}
        }
        | Set Spell
        /if (${IWType.Equal[spell]}) {
            /if (!${Me.Gem[${IWE2}].Name.Length}) {
                /echo ..SET${IWSection}: You need to mem a spell
                /return
            }
            /varset IWTypeSingle ${Me.Gem[${IWE2}].Name}
        }
        | Set AA
        /if (${IWType.Equal[aa]}) {
            /if (!${Me.AltAbility[${IWE2}]}) {
                /echo ..SET${IWSection}: You don't have that AA
                /return
            }
            /varset IWTypeSingle ${Me.AltAbility[${IWE2}].Name}
        }
        | Set Disc/Combat Ability
        /if (${IWType.Equal[disc]}) {
            /if (!${Select[${IWE2},1,2,3,4,5,6,7,8]}) {
                /echo ..SET${IWSection}: Disc # must be a Combat Abilty Button 1-8
                /return
            }
            /if (!${Me.CombatAbility[${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}]}) {
                /echo ..SET${IWSection}: You don't have that Disc or Combat Ability button ${IWE2} is empty.
                /return
            }
            /varset IWTypeSingle ${Window[CombatAbilityWnd].Child[CAW_Button${IWE2}].Text}
        }
        | Final Catchall for error control
        /if (!${IWTypeSingle.Length}) {
            /echo ..SET${IWSection}: ${IWType} parameter is blank. Please provide a ${IWType}
            /return
        }
        | Find empty slot & check if entry exists
        /echo ..SET${IWSection}: Looking of for spot to write ${IWTypeSingle}
        /for k 1 to ${IWArray}
            /varset IWEntry ${Ini[${IniFileName},${IWSection},${IWSection}${k}]}
            /if (${IWSection.Equal[DPS]}) /varset IWPercent 90
            /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
            DEBUGN ${${IWSection}[${k}].Length}
            /if (${IWEntry.Find[${IWTypeSingle}]}) {
                /echo ..SET${IWSection}: Duplicate entry ${IWSection}${k}=${IWTypeSingle} skipping.
                /return
            }
            /if (${IWEntry.Equal[null]} && ${IWEmptySlot}==0) {
                /varset IWEmptySlot ${k}
            }
            /if (${k}==${IWArray} && !${IWEmptySlot}) /varset IWEmptySlot ${k}
        /next k
        /if (${IWEmptySlot}==${IWArray}) {
            /echo ..SET${IWSection}: No empty slots in ${IWSection} to write
            /return
        }
        /if (${Select[${IWSection},DPS,Heals]}) {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}|${IWPercent}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}|${IWPercent}
        } else {
            /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWEmptySlot}" "${IWTypeSingle}"
            /echo  ..SET${IWSection}: ${IWSection}${IWEmptySlot} is empty writing ${IWTypeSingle}
        }
    } else {
        /echo ..SET${IWSection}: This command will write over current ${IWSection} settings
        /for i 1 to 8
            /varset keyNum ${i}
            /if (${Me.Gem[${IWE${i}}].Name.Length}) {
                /if (${IWSection.Equal[DPS]}) /varcalc IWPercent ${IWPercent}-5
                /if (${IWSection.Equal[Heals]}) /varset IWPercent 80
                /if (${Select[${IWSection},DPS,Heals]}) {
                    /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}|${IWPercent}"
                    /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}|${IWPercent}
                }
                /if (${Select[${IWSection},Buffs]}) {
                    /ini "${IniFileName}" "${IWSection}" "${IWSection}${IWSlot}" "${Me.Gem[${IWE${i}}].Name}"
                    /echo ..SET${IWSection}: Writing ${IWSection}${IWSlot}=${Me.Gem[${IWE${i}}].Name}
                }
                /varcalc IWSlot ${IWSlot}+1
                /delay 10
            }
        /next i
    }
    /return
|-----------------------------------------------------------------------------
| SUB: Check Begged for buffs
| ----------------------------------------------------------------------------
    Sub CheckBegforBuffs
        /declare WNWAll    string local
        /declare WNWPart1  string local
        /declare WNWPart2  string local
        /declare WNWPart3  string local
        /declare WNWx      int    local 1
        /declare WNWSpellType string local
        /declare BuffToCast   string local
        DEBUGBUFF CheckBegForBuffs: Enter
        /if (${Me.Invis}) /return
        /if (!${KABegForList.Length}) /return
        /while (1) {
            /varset WNWAll ${KABegForList.Arg[${WNWx},|]}
            /if (!${WNWAll.Length} || ${WNWAll.Equal[null]}) {
                /if (!${KABegForList.Length} || ${KABegForList.Equal[null]}) /varset KABegActive 0
                /break
            }
            /varset WNWPart1 ${WNWAll.Arg[1,:]}
            /varset WNWPart2 ${WNWAll.Arg[2,:]}
            /varset WNWPart3 ${WNWAll.Arg[3,:]}
            DEBUGBUFF CheckBegForBuffs: ${WNWAll} - ${Me.Invis}
            /if (${Me.Invis}) /break
            /varset BuffToCast ${Buffs[${WNWPart3}].Arg[1,|]}
            /if (${Me.Book[${BuffToCast}]}) {
                /varset WNWSpellType ${Spell[${BuffToCast}].TargetType}
            } else /if (${Me.AltAbility[${BuffToCast}]}) {
                /varset WNWSpellType ${Me.AltAbility[${BuffToCast}].Spell.TargetType}
            } else {
                /varset WNWSpellType self
            }
            DEBUGBUFF CheckBegForBuffs: ${BuffToCast} - ${WNWSpellType}
            /if (${WNWSpellType.NotEqual[self]}) {
                /call CastWhat "${BuffToCast}" ${Spawn[PC ${WNWPart2}].ID} Buffs 0 0
                /if (${Macro.Return.Equal[CAST_SUCCESS]} || ${Macro.Return.Equal[CAST_RECOVER]}) {
                    /call RemoveFromBegList "${WNWAll}" ${WNWx} "${WNWSpellType}"
                } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                    /break
                } else {
                    /varcalc WNWx ${WNWx}+1
                }
            } else {
                /call RemoveFromBegList "${WNWAll}" ${WNWx} "self"

            }
        }
        DEBUGBUFF CheckBegForBuffs: Leave 
    /return
|-----------------------------------------------------------------------------
| SUB: Remove From Beg List
| ----------------------------------------------------------------------------
    Sub RemoveFromBegList(string RBLAll, int RBLIdx, string RBLType)
        /declare RBLPart1  string Local
        /declare RBLPart2  string Local
        /declare RBLPart3  string Local
        /declare RBLPart1t string Local
        /declare RBLPart2t string Local
        /declare RBLPart3t string Local
        /declare RBLy      int    local 0
        /if (!${RBLAll.Length} || ${RBLAll.Equal[null]}) /return
        /varset RBLPart1 ${RBLAll.Arg[1,:]}
        /varset RBLPart2 ${RBLAll.Arg[2,:]}
        /varset RBLPart3 ${RBLAll.Arg[3,:]}
        DEBUGBUFF RemoveFromBegList: Enter - ${RBLAll} - ${RBLIdx} - ${RBLType}
        /if (!${RBLIdx}) /varset RBLIdx 1
        /if (${KABegForList.Find[${RBLAll}|]}) {
            /varset KABegForList ${KABegForList.Replace[${RBLAll}|,]}
            | Check for AE Items and remove any entries with same item tag and buff number entry
            /if ((${Select[${RBLPart1},BEGFORAEITEMS]} && ${KABegForList.Find[${RBLPart1}:]}) || ${RBLType.Equal[self]}) {
                /varset RBLy ${RBLIdx}
                /while (1) {
                    /varset RBLAll ${KABegForList.Arg[${RBLy},|]}
                    /if (!${RBLAll.Length} || ${RBLAll.Equal[null]}) {
                        /break
                    } else {
                        | Part1: Alias Name - Part2: Character Name - Part3: Buff entry index number
                        /varset RBLPart1t ${RBLAll.Arg[1,:]}
                        /varset RBLPart2t ${RBLAll.Arg[2,:]}
                        /varset RBLPart3t ${RBLAll.Arg[3,:]}
                        /if (${RBLPart1t.Equal[${RBLPart1}]} && ${RBLPart3t.Equal[${RBLPart3}]}) {
                            /if (${KABegForList.Find[${RBLAll}|]}) {
                                /varset KABegForList ${KABegForList.Replace[${RBLAll}|,]}
                            } else /if (${KABegForList.Find[${RBLAll}]}) {
                                /varset KABegForList ${KABegForList.Replace[${RBLAll},]}
                            } else {
                                /varcalc RBLy ${RBLy}+1
                            }
                        } else {
                            /varcalc RBLy ${RBLy}+1
                        }
                    }
                }
            } else /if (${RBLType.Equal[single]}) {
                | Check for single targeted items and remove any duplicates from list. Only need to cast once.
                /if (${KABegForList.Find[${RBLAll}]}) {
                    /while (${KABegForList.Find[${RBLAll}|]}) {
                        /varset KABegForList ${KABegForList.Replace[${RBLAll}|,]}
                    }
                    /if (${KABegForList.Find[${RBLAll}]}) /varset KABegForList ${KABegForList.Replace[${RBLAll},]}
                }
            }
        } else /if (${KABegForList.Find[${RBLAll}]}) {
            /varset KABegForList ${KABegForList.Replace[${RBLAll},]}
        }
        DEBUGBUFF RemoveFromBegList: Leave
    /return
|-----------------------------------------------------------------------------
| SUB: Check Begged for Pet buffs
| ----------------------------------------------------------------------------
    Sub CheckBegforPetBuffs
        /declare WNWAll    string local
        /declare WNWPart1  string local
        /declare WNWPart1t string local
        /declare WNWx      int    local 1
        /declare WNWy      int    local
        /declare WhatBeenCast string local

        /declare PTPPetID int local
        /declare GMemID int local
        /declare GMemShortName string local
        /declare GMemPetName string local
        /declare i int local 0
        /if (!${PetToysOn}) /return
        /if (${Me.Invis}) /return
        DEBUGPET PetToysPlease: Enter GiveToys
        | If group command give all pets in group toys
        /echo CheckBegforPetBuffs: ${KABegForPetList} ${WNWx}
        /if (!${KABegForPetList.Length}) /return
        /while (1) {
            /varset WNWAll ${KABegForPetList.Arg[${WNWx},|]}
            /if (!${WNWAll.Length} || ${WNWAll.Equal[null]}) {
                /if (!${KABegForPetList.Length} || ${KABegForPetList.Equal[null]}) /varset KAPetBegActive 0
                /break
            }
            /varset WNWPart1 ${WNWAll}
            /if (${WNWPart1.Equal[group]}) {
                /echo I am giving pet toys to every Pet in Group except mine.
                | Start at 1 my pet doesn't need toys
                /for i 1 to 5
                    /varset GMemID ${Group.Member[${i}].ID}
                    /varset PTPPetID ${Group.Member[${i}].Pet.ID}
                    /varset GMemShortName ${Group.Member[${i}].Class.ShortName}
                    /varset GMemPetName ${Group.Member[${i}].Pet.Name}
                    DEBUGPET PetToysPlease: ${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}
                    /if (${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}) {
                        /if (${Me.Invis}) /break
                        /call pettoys ${GMemPetName}
                    }
                /next i
            } else {
                | Individual Pet.
                /if (${Me.Invis}) /break
                /echo Giving pet toys to (${WNWPart1}).
                /call pettoys ${WNWPart1}
            }

            /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                /if (${KABegForPetList.Find[${WNWAll}|]}) {
                    /varset KABegForPetList ${KABegForPetList.Replace[${WNWAll}|,]}
                    /if (${KABegForPetList.Find[${WNWPart1}]}) {
                        /varset WNWy ${WNWx}
                        /while (1) {
                            /varset WNWAll ${KABegForPetList.Arg[${WNWy},|]}
                            /if (!${WNWAll.Length} || ${WNWAll.Equal[null]}) {
                                /break
                            } else {
                                /varset WNWPart1t ${WNWAll}
                                /if (${WNWPart1t.Equal[${WNWPart1}]}) {
                                    /if (${KABegForPetList.Find[${WNWAll}|]}) {
                                        /varset KABegForPetList ${KABegForPetList.Replace[${WNWAll}|,]}
                                    } else /if (${KABegForPetList.Find[${WNWAll}]}) {
                                        /varset KABegForPetList ${KABegForPetList.Replace[${WNWAll},]}
                                    } else {
                                        /varcalc WNWy ${WNWy}+1
                                    }
                                } else {
                                    /varcalc WNWy ${WNWy}+1
                                }
                            }
                        }
                    }
                } else /if (${KABegForPetList.Find[${WNWAll}]}) {
                    /varset KABegForPetList ${KABegForPetList.Replace[${WNWAll},]}
                }
            } else /if (${Macro.Return.Equal[CAST_CANCELLED]}) {
                /break
            } else {
                /varcalc WNWx ${WNWx}+1
            }
        }
    /return
|-----------------------------------------------------------------------------
| SUB: Campfire back to camp
| ----------------------------------------------------------------------------
    Sub CampfireBack
        DEBUGN CampFireBack Enter ${CampZone} ${Zone.ID} ${IAmDead} ${CampfireClickTimer}
        /if (${Me.Hovering}) /call PauseWhileHovering CampFireBack
        /if (!${Me.ID} || !${Zone.ID}) /call PauseWhileZoning CampFireBack
        /if (${CampfireClickTimer}) /return
        /if (${CampZone}==${Zone.ID}) /return
        /declare SpamTimerCFB timer local 0
        /declare t_Wait timer local 100
        /while (${t_Wait}) {
            /delay 5
            /if (${Me.Fellowship.Campfire} && ${ClickBacktoCamp}==1) /break
        }
        | Am I Dead?
        /if (${Me.Buff[Revival Sickness].ID}) {
            | Does Campfire Exist?
            /if (!${Me.Fellowship.Campfire}) {
                /echo There is no campfire up.
            | Am I & the campfire in the same zone?
            } else /if (${Select[${Me.Fellowship.CampfireZone.ID},${Zone.ID}]}) {
                /echo I'm back in the same zone as my campfire.
                /varset IAmDead 0
            } else /if (${FindItemCount[Fellowship Registration Insignia]}) {
                /while (1) {
                    /if (${FindItem[Fellowship Registration Insignia].TimerReady} == 0) {
                        /echo Time to get back to work. Clicking Fellowship Insignia in 30 seconds.
                        | Delay for rest state to kick in
                        /while (${Select[${Me.CombatState},active,resting]}==0) {
                            /delay 5
                        }
                        /doevents
                        /squelch /nomodkey /itemnotify "Fellowship Registration Insignia" rightmouseup
                        /delay 50 !${Zone.ID}
                        /if (!${Zone.ID}) /call PauseWhileZoning CampFireBack
                        /break
                    } else {
                        /if (!${SpamTimerCFB}) /echo Waiting for Fellowship Registration Insignia to refresh.
                        /varset SpamTimerCFB 100
                    }
                    /delay 10
                    /if (!${Me.Fellowship.Campfire}) {
                        /echo There is no campfire up.
                        /break
                    }
                }
                /while (1) {
                    /varset EventFlag 0
                    /doevents
                    /if (!${EventFlag}) /break
                }
            } else {
                /echo You Don't have a Fellowship Registration Insignia. You may want to go get one.
            }
        }
        /varset CampfireClickTimer 1m
        DEBUGN CanpFireBack Leave
    /return
|-----------------------------------------------------------------------------
| SUB: Debug 
| ----------------------------------------------------------------------------
    Sub Bind_Debug(string p_cmd1, string p_cmd2, string p_cmd3)
        /declare str_onoff string local
        /declare str_command string local
        /declare str_uselog string local
        /if (${EverQuest.CurrentUI.NotEqual[Default]}) {
            /echo You are using a Custom UI. Please switch to Default UI before Posting.
        }
        | Check param 3
        /if (${Select[${p_cmd3},log,logc]}) {
            /varset str_uselog ${Select[${p_cmd3},log,logc]}
        } else {
            /varset str_uselog 0
        }
        | Check Param 2
        /if (${Select[${p_cmd2},0,1,on,off]}) {
            /varset str_command ${p_cmd1}
            /varset str_onoff ${p_cmd2}
            /if (${p_cmd2.Equal[on]}) {
                /varset str_onoff 1
            } else {
                /varset str_onoff 0
            }
        } else /if (${Select[${p_cmd2},log,logc]}) {
            /varset str_uselog ${Select[${p_cmd2},log,logc]}
            /varset str_onoff
        } else {
            /varset str_onoff
        }
        | Check Param 1
        /if (${Select[${p_cmd1},0,1,on,off]}) {
            /varset str_command Debug
            /varset str_onoff ${p_cmd1}
            /if (${p_cmd1.Equal[on]}) {
                /varset str_onoff 1
            } else {
                /varset str_onoff 0
            }
            /if (!${str_onoff} && ${DebugAllOn}) /varset str_command all
        } else /if (${p_cmd1.Equal[all]}) {
            /varset str_command ${p_cmd1}
        } else /if (${Select[${p_cmd1},Buffs,Combat,Cast,ChainP,Heals,Mez,Move,Pull,RK]}) {
            /varset p_cmd1 ${p_cmd1.Left[1].Upper}${p_cmd1.Right[-1].Lower}
            /if (${Select[${p_cmd1.Right[1]},p,k]}) /varset p_cmd1 ${p_cmd1.Left[-1]}${p_cmd1.Right[1].Upper}
            /varset str_command Debug${p_cmd1}
        } else /if (!${p_cmd1.Length}) {
            /if (${DebugAllOn}) {
                /varset str_command all
            } else {
                /varset str_command Debug
            }
        } else {
            /varset str_command Help
            /varset str_onoff
        }
        
        /if (${str_command.Equal[help]}) {
            /echo --------------------------------------------------------------------------------------------
            /echo \ayDebug help: 
            /echo \ay    /debug command action1 action2
            /echo \ay        command: \aohelp/all/Buffs/Combat/Cast/ChainP/Heals/Mez/Move/Pull/RK/on/off/0/1
            /echo \ay        action1: \aoon/off/0/1 or blank 
            /echo \ay        action2: \aolog or blank
            /echo \ag    Examples:
            /echo \at        /debug all on -----> Turns on debug all.
            /echo \at        /debug all off ----> Turns off debug all. 
            /echo \at        /debug all --------> Taggles on/off debug all.
            /echo \at        /debug all log ----> Toggles on/off debug all and starts/stops logging.
            /echo \at        /debug on ---------> Turns on debug only.
            /echo \at        /debug off --------> Turns off debug only.
            /echo \at        /debug ------------> Toggles on/off debug only.
            /echo \at        /debug combat on --> Turns on combat debug only.
            /echo \at        /debug combat off -> Turns off combat debug only.
            /echo \at        /debug combat -----> Taggles on/off combat debug only
            /echo \at        
            /echo \at        /debug log - Is an invalid format and shouldn't be used. 
            /echo 
            /echo \ay        log - can be used as either action1 or action2, but never as command.
            /echo \ay              you do NOT have to sepcify the log action to turn logging off.
            /echo \ay              any action that turns off any debug command will stop logging.
            /echo
            /echo \ay    Note: MQ2Log plugin will be loaded using the noauto option if the plugin is not loaded. 
            /echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            /return
        } else /if (${str_command.Equal[debug]}) {
            /if (!${str_onoff.Length}) {
                /if (${Debug}) {
                    /varset str_onoff 0
                } else {
                    /varset str_onoff 1
                }
            }
            /varset Debug ${str_onoff}
            /if (${Debug}) {
                /echo \atDEBUG On
            } else {
                /echo \atDEBUG Off
            }
        } else /if (${str_command.Equal[all]}) {
            /if (!${str_onoff.Length}) {
                /if (${DebugAllOn}) {
                    /varset str_onoff 0
                } else {
                    /varset str_onoff 1
                }
            }
            /varset DebugAllOn ${str_onoff}
            /if (${DebugAllOn}) {
                /echo \atDebugAll On
            } else {
                /echo \atDebugAll Off
            }
            /varset Debug ${DebugAllOn}
            /varset DebugBuffs ${DebugAllOn}
            /varset DebugCast ${DebugAllOn}
            /varset DebugCombat ${DebugAllOn}
            /varset DebugHeals ${DebugAllOn}
            /varset DebugMez ${DebugAllOn}
            /varset DebugMove ${DebugAllOn}
            /varset DebugPet  ${DebugAllOn}
            /varset DebugPull ${DebugAllOn}
        } else /if (${Defined[${str_command}]}) {
            /if (!${str_onoff.Length}) {
                | Double brackets it is on purpose.
                /if (${${str_command}}) {
                    /varset str_onoff 0
                } else {
                    /varset str_onoff 1
                }
            }
            /varset ${str_command} ${str_onoff}
            /if (${${str_command}}) {
                /echo \at${str_command} On
            } else {
                /echo \at${str_command} Off
            }
        } else {
            /echo Invalid Command. Try /debug help.
            /return
        }
        /if (${str_uselog}) {
            /if (!${Bool[${Plugin[mq2log]}]}) {
                /plugin MQ2Log noauto 
                /delay 20 ${Bool[${Plugin[mq2log]}]}==True
            }
            /if (!${DebugLogging}) {
                /if (${str_onoff.Equal[1]}) {
                    /if (${str_uselog.Equal[2]}) /mqlogcustom ${EverQuest.Server}_${Me.CleanName} clear
                    /mlog on
                    /varset DebugLogging 1
                    /echo Using UI: ${EverQuest.CurrentUI}
                    /echo KissAssist Info: ${MacroName} ${MacroVer}-${KissRevision}
                    /echo MQ Build: ${MacroQuest.InternalName} - ${MacroQuest.Build} - ${MacroQuest.BuildDate}
                    /plugin list
                    /call DebugInfo
                }
            } else {
                /if (${str_onoff.Equal[0]}) {
                    /echo KissAssist Debug Off Marker!
                }
            }
        } else {
            /if (${DebugLogging}) {
                /if (${str_onoff.Equal[0]}) {
                    /echo KissAssist Debug Off Marker!
                }
            }
        }
    /return
|-----------------------------------------------------------------------------
| SUB: DebugInfo Used to dump Macro Variables in debug log.
| ----------------------------------------------------------------------------
    Sub DebugInfo
        /declare di_x int local 0
        /declare di_y int local 0
        /if (${UseMQ2Melee} && ${Bool[${Plugin[mq2melee]}]}) {
            /melee
            /echo Melee stickcmd: ${Ini[${EverQuest.Server}_${Me.CleanName}.ini,mq2melee,stickcmd]}
        }
        /echo ============================================================
        /echo 1 - ${Role} ${ReturnToCamp} ${ChaseAssist} ${CampRadius} ${MeleeDistance} ${CampZone} ${Zone.ID}
        /echo 2 - ${Math.Distance[${CampYLoc},${CampXLoc}]} ${Spawn[=${MainAssist}].Distance3D}
        /echo 3 - ${MeleeOn} ${DPSOn} ${UseMQ2Melee} "${StickHow}" ${XTSlot}
        /echo 4 - ${IAmMA} ${Spawn[=${MainAssist}].ID} ${Group} ${Group.MainAssist.ID}
        /echo 5 - ${BuffsOn} ${AEOn} ${AggroOn} ${HealsOn} ${CuresOn} ${AFKToolsOn} ${ConOn} ${PullLocsOn} ${TwistOn}
        /echo 6 - ${MiscGem} ${MiscGemLW} ${MiscGemRemem}
        /echo 7 - ${Me.Class} ${Me.Level} ${PullMoveUse} ${If[${PullMoveUse.Equal[nav]},${Navigation.MeshLoaded},0]}
        /if (${Role.Find[Puller]} || ${Role.Find[Hunter]}) {
            /echo 8 - ${PullWith} ${MaxRadius} ${MaxZRange} ${PullRadiusToUse} ${ChainPull} ${ChainPullHP} ${PullPause} ${PullLevel} ${PullArcWidth} ${PullOnReturn}
        }
        /if (${HealsOn} && ${XTarHeal}) {
            /echo 9 - ${XTarHealList} ${XTSlot} ${XTSlot2}
            /for di_x 1 to ${XSlotTotal}
                /if (${XTarHealList.Arg[${di_x},|].Length}) {
                    /varset di_y ${XTarHealList.Arg[${di_x},|]}
                    /echo --> ${di_x} - ${di_y} - ${Me.XTarget[${di_y}].TargetType}
                }
            /next di_x
        }
        /echo ============================================================
        | Put in the Type/TLO Checks you want below here. 
        /if (${IAmABard}) {
            /if (${TwistOn}) {
                /call DebugDumpTLO twist
            } else {
                /echo I am a Bard, but I am not using twist.
            }
        }
    /return
|-----------------------------------------------------------------------------
| SUB: DebugDumpTLO Pass the type name. Used to dump TLO/Type Members Data.
| ----------------------------------------------------------------------------
    Sub DebugDumpTLO(typeName)
        /declare dt_i int local 1
        /declare dt_TLOName string local 
        /if (!${typeName.Length} || !${Type[${typeName}].Name.Length}) {
            /echo Type - ${typeName} Not Available.
            /return
        }
        /varset dt_TLOName ${typeName.Left[1].Upper}${typeName.Right[-1]}
        /echo Listing for Type: ${typeName} - TLO: ${dt_TLOName}
        /echo =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- 
        /while (1) {
            /if (!${Type[${typeName}].Member[${dt_i}].Length}) /break
			/echo ${Type[${typeName}].Member[${dt_i}]} - ${${dt_TLOName}.${Type[${typeName}].Member[${dt_i}]}}
            /varcalc dt_i ${dt_i}+1
        }
        /echo =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd1
| ----------------------------------------------------------------------------
    Sub Event_PetSusStateAdd1
        /varset EventFlag 1
        /varset PetActiveState  0
        /varset PetSuspendState 1
        /varset PetTotCount     1
        DEBUGPET PetSusStateAdd1 triggered.
        DEBUGPET PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState})
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateAdd2
| ----------------------------------------------------------------------------
    Sub Event_PetSusStateAdd2
        /varset EventFlag 1
        /varset PetActiveState  1
        /varset PetSuspendState 1
        /varset PetTotCount     2
        DEBUGPET PetSusStateAdd2 triggered.
        DEBUGPET PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState})
    /return
|-----------------------------------------------------------------------------
| SUB: PetSusStateSub
| ----------------------------------------------------------------------------
    Sub Event_PetSusStateSub
        /varset EventFlag 1
        /varset PetActiveState  1
        /varset PetSuspendState 0
        /varset PetTotCount     1
        DEBUGPET PetSusStateSub triggered.
        DEBUGPET PetTotCount(${PetTotCount}) PetActiveState(${PetActiveState}) PetSuspendState(${PetSuspendState})
    /return
|-----------------------------------------------------------------------------
| SUB: Back Off and stop melee
| ----------------------------------------------------------------------------
    Sub Bind_BackOff(string OnOffFlag, int waitFlag)
        /declare t_Wait      timer local 0
        /declare i_Target    int   local ${Int[${Target.ID}]}
        /declare i_Flag1     int   local 0
        /if (${Select[${OnOffFlag},on,off,1,0]}>0) {
            /if (${Select[${OnOffFlag},on,1]}>0) {
                /varset DPSPaused 0
            } else {
                /varset DPSPaused 2
            }
        }
        /if (${DPSPaused}) {
            /echo Resetting. No Longer Backing off. ${waitFlag} ${IAmMA}
            /if (${waitFlag} && ${IAmMA}) {
                /if (${Me.Casting.ID}) {
                    /stopcast
                    /varset CastResult CAST_CANCELLED
                }
                /echo Pausing for new target. Switch to new target now.
                /varset t_Wait 30
                /beep
                /while (${t_Wait} && !${i_Flag1}) {
                    /if (${Target.ID} && ${Target.ID}!=${i_Target}) /varset i_Flag1 1
                    /delay 5
                }
                /if (${i_Flag1}) {
                    /varset i_Flag1 ${TargetSwitchingOn}
                    /varset TargetSwitchingOn 1
                    /call CombatTargetCheck 2
                    /varset TargetSwitchingOn ${i_Flag1}
                    /echo Target Switched from Backoff command.
                } else {
                    /echo Target NOT Switched. You can always try again.
                }
            }
            /if (${DPSPaused}==2 && ${UseMQ2Melee}) /squelch /melee on
            /varset DPSPaused 0
        } else {
            /varset DPSPaused 1
            /varset CombatStart 0
            /if (${UseMQ2Melee}) /squelch /melee off
            /squelch /attack off
            /if (${Stick.Active}) /stick off
            /call CombatReset 0 backoff
            /varset DPSPaused 2
            /echo Backing off - All Combat has been reset.
        }
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]} > 15 && !${waitFlag}) {
            /call DoWeMove 0 bind_backoff
        }
    /return
| -------------------------------------------------------------------------------------
| SUB: Event PetToysPlease
| -------------------------------------------------------------------------------------
    Sub Event_PetToysPlease(Message,string MTPet)
        /varset EventFlag 1
        /if (!${MTPet.Length}) /return
        /if (${MTPet.Find[null]}) /return
        /if (!${Spawn[pet ${MTPet}].ID} && ${MTPet.NotEqual[group]}) /return
        /declare PTPPetID int local
        /declare GMemID int local
        /declare GMemShortName string local
        /declare GMemPetName string local
        /declare i int local 0
        DEBUGPET PetToysPlease: Enter
        | If group command give all pets in group toys
        /if (${MTPet.Find[GROUP]}) {
            /echo I am giving pet toys to every Pet in Group except mine.
            | Start at 1 my pet doesn't need toys
            /for i 1 to 5
            /varset GMemID ${Group.Member[${i}].ID};
            /varset PTPPetID ${Group.Member[${i}].Pet.ID}
            /varset GMemShortName ${Group.Member[${i}].Class.ShortName}
            /varset GMemPetName ${Group.Member[${i}].Pet.Name}
            DEBUGPET PetToysPlease: ${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}
            /if (${GMemID} && ${PTPPetID} && ${Select[${GMemShortName},shm,nec,mag,bst,dru,enc,shd]} && ${Spawn[${GMemPetName}].Type.Equal[Pet]}) {
                /if (${PetToysOn}) /call pettoys ${GMemPetName}
            }
            /next i
        } else {
            | Individual Pet.
            /if (${PetToysOn}) {
                /echo Giving pet toys to (${MTPet}).
                /call pettoys ${MTPet}
            }
        }
        DEBUGPET PetToysPlease: Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Event PetToysPlease New
| -------------------------------------------------------------------------------------
    Sub Event_PetToysPlease_1(Message,string MTPet)
        /varset EventFlag 1
        | this version will create a list of pets to give toys too.
        | the routine to give items to pets will be called from the main loop.
        |
        /if (!${MTPet.Length}) /return
        /if (${MTPet.Find[null]}) /return
        /if (!${Spawn[pet ${MTPet}].ID} && ${MTPet.NotEqual[group]}) /return
        /if (!${PetToysOn}) /return
        DEBUGPET PetToysPlease: Enter AddToList
        | If group command give all pets in group toys
        /if (${MTPet.Find[GROUP]}) {
            /echo Adding Group entry to pet toys list.
            | Start at 1 my pet doesn't need toys
            /if (!${KABegForPetList.Length} || ${KABegForPetList.Equal[null]}) {
                /varset KABegForPetList group
            } else {
                /varset KABegForPetList ${KABegForPetList}|group
            }
            /varset KAPetBegActive 1
        } else {
            | Individual Pet.
            /if (!${KABegForPetList.Length} || ${KABegForPetList.Equal[null]}) {
                /varset KABegForPetList ${MTPet}
            } else {
                /varset KABegForPetList ${KABegForPetList}|${MTPet}
            }
            /varset KAPetBegActive 1
        }
        DEBUGPET PetToysPlease: Leave AddToList
    /return
| -------------------------------------------------------------------------------------
| SUB: Add stuff to alert list
| -------------------------------------------------------------------------------------
    Sub AlertAddToList(int whatlist, MvarList, IDvarList)
        DEBUGN AlertAddToList List:${whatlist} Mlist: ${MvarList}
        /declare k int local
        | Clear ignore mobs alert from list before assigning from ini list
        /squelch /alert clear ${whatlist}
        /if (${MvarList.Length} && !${MvarList.Find[null]}) {
            /for k 1 to 25
                /if (${MvarList.Arg[${k},,].Length} && !${MvarList.Find[null]} && ${Debug}) /echo \atDEBUG ADD ${MvarList.Arg[${k},,]} to ${MvarList}
                /if (${MvarList.Arg[${k},,].Length}) {
                    /if (${MvarList.Arg[${k},,].Find[*]}) {
                        /squelch /alert add ${whatlist} "${MvarList.Arg[${k},,].Replace[*,]}"
                    } else {
                        /squelch /alert add ${whatlist} "=${MvarList.Arg[${k},,]}"
                    }
                    DEBUGN AlertAddToList Add ${MvarList.Arg[${k},,]} to Alert List ${whatlist}
                }
            /next k
        }
        | Add by mob ID for mobs that get invalidated when pulling.
        /if (${IDvarList.Length} && ${IDvarList.NotEqual[null]}) {
            /varset k 1
            /while (${IDvarList.Arg[${k},|].Length} && ${IDvarList.Arg[${k},|].NotEqual[null]} && ${Int[${IDvarList.Arg[${k},|]}]}>0) {
                DEBUGN ADD ${IDvarList.Arg[${k},|]} to ${MvarList}
                /if (${Int[${IDvarList.Arg[${k},|]}]}>0) /squelch /alert add ${whatlist} id ${IDvarList.Arg[${k},|]}
                DEBUGN AlertAddToList Add ${IDvarList.Arg[${k},|]} to Alert List ${whatlist}
                /varcalc k ${k}+1
            }
        }
        DEBUGN AlertAddToList Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Cast Mount
| -------------------------------------------------------------------------------------
    Sub CastMount
        /if (${Me.Mount.ID} || !${MountOn} || (${HealsOn} && ${AggroTargetID})) /return
        /declare i int local
        /for i 1 to ${Buffs.Size}
        | Cast mount
        /if (${Buffs[${i}].Arg[2,|].Equal[Mount]} && !${Buffs[${i}].Find[0]} && !${Me.Mount.ID} && !${Attacking} && ${MountOn} && !${Me.FeetWet}) {
            DEBUGBUFF CheckBuffs Mount
                /if (${ConOn} && ${Buffs[${i}].Find[|cond]} && ${If[${Cond[${Buffs[${i}].Mid[${Math.Calc[${Buffs[${i}].Find[|cond]}+5]},3]}]},0,1]}) /continue
                /call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} CastMount 0 0
            /delay 1s
            /if (${Macro.Return.Equal[CAST_NOMOUNT]}) /varset MountOn 0
        }
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Cast Mana
| -------------------------------------------------------------------------------------
    Sub CastMana(string SentFrom)
        /if (${Me.Invis}) /return
        DEBUGBUFF CastMana Enter ${SentFrom}
        /declare i int local
        /declare CondNo int local 0
        /if (${MezOn}) {
            /varset MezBroke 0
            /doevents MezBroke
            /if (!${MezBroke}) {
                /varset GoMByPass 1
                /call DoMezStuff CastMana
                /varset GoMByPass 0
            }
        }
        /for i 1 to ${Buffs.Size}
            /if (${Buffs[${i}].Find[|0]} || ${Buffs[${i}].Equal[null]}) /continue
            /if (${Select[${Buffs[${i}].Arg[2,|]},mana,managroup]}==0) /continue
            /if (${ConOn} && ${Buffs[${i}].Find[|cond]}) {
                /varset CondNo ${Buffs[${i}].Mid[${Math.Calc[${Buffs[${i}].Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            | Check and Cast mana type spells/aas/items - Canni/Paragon/Harvest - prevent toon from using before rez after zoning for 2 min
            /if (${Buffs[${i}].Arg[2,|].Equal[Mana]} && !${Me.Buff[Revival Sickness].ID} && !${JustZoned}) {
                /if (${Buffs[${i}].Arg[1,|].Equal[Dichotomic Psalm]} && (${IAmABard} || ${Me.CurrentEndurance}<6600)) /continue
                /if (${Me.PctMana}<=${Buffs[${i}].Arg[3,|]} && ${Me.PctHPs}>${Int[${Buffs[${i}].Arg[4,|]}]}) {
                    /if (${Cursor.ID}) /call CheckCursor CastMana 0
                    DEBUGBUFF Canni/Paragon/Harvest
                    /call CastWhat "${Buffs[${i}].Arg[1,|]}" ${Me.ID} CastMana ${CondNo} 0
                    /if (${Macro.Return.Equal[CAST_SUCCESS]}) {
                        /echo Casting >> ${Buffs[${i}].Arg[1,|]} << for mana
                        /if (${AggroTargetID}) /break
                    }
                }
            } else /if (${Buffs[${i}].Arg[2,|].Equal[Managroup]} && (!${Medding} || (!${MedCombat} && ${Medding}))) {
                /call RegenOther "${Buffs[${i}].Arg[1,|]}" Mana ${Buffs[${i}].Arg[3,|]} 0 ${CondNo}
            }
        /next i
        DEBUGBUFF CastMana Leave ${SentFrom}
    /return
| -------------------------------------------------------------------------------------
| SUB: Event_Timer
| ------------------------------------ -------------------------------------------------
    Sub Event_Timer(Timer, OriginalValue)
        /varset EventFlag 1
        /if (${Select[${Timer},TributeTimer,AggroOffTimer,TellTimer,SitToMedTimer,CursorIDTimer]}==0) /return
        DEBUGN Event_Timer Enter ${Timer}
        /if (${Timer.Equal[TributeTimer]}) {
            /if (${UseTribute} && ${Me.TributeActive}) {
                /if (!${AggroTargetID} || (${Target.ID} && !${Target.Named})) {
                    /squelch /tribute personal off
                    /squelch /trophy personal off
                } else {
                    /if (${Target.ID} && ${Target.Named}) /varset ${Timer} 580s
                }
            }
        } else /if (${Timer.Equal[AggroOffTimer]}) {
            /if (${Me.Feigning}) /stand
            /if (${Me.Invis}) /makemevisible
        } else /if (${Timer.Equal[CursorIDTimer]}) {
            /if (${Cursor.ID}) /call CheckCursor Event_Timer 1
            /varset CursorID 0
        } else /if (${Timer.Equal[SitToMedTimer]} && !${Me.Moving}) {
            /if (!${MeleeOn} && ${Me.Standing} && ${MedCombat}==2 && !${Me.Mount.ID} && !${Me.Casting.ID} && (${Me.TargetOfTarget.ID}!=${Me.ID} || ${Target.ID}==${Me.ID})) /sit
        }
        DEBUGN Event_Timer leave
    /return
| -------------------------------------------------------------------------------------
| SUB: SpellRankCheck
| ------------------------------------ -------------------------------------------------
    Sub SpellRankCheck(Rk_Check_What)
        /declare rkCheck                string      local null
        /declare rkCheck1               string      local
        /declare rkdCheck               string      local
        /declare rkTemp                 string      ${Rk_Check_What.Arg[1,|]}
        /declare rkdTemp                string      ${Rk_Check_What.Arg[3,|]}
        /declare rkd_i                  int         local 0
        DEBUGN SpellRankChecks: Enter - ${rkTemp} - ${rkdTemp}
        /if (${Rk_Check_What.Left[1].Equal[0]} || ${Int[${Rk_Check_What.Left[1]}]}>0) /return ${Rk_Check_What}
        | Check for Rk. in spell name and Remove it.
        /if (${rkTemp.Find[ Rk.]}) {
            /varset rkTemp ${rkTemp.Left[${Math.Calc[${rkTemp.Find[ Rk.]}-1]}]}
        }
        /if (${Int[${Me.Book[${rkTemp}]}]}==0 && ${Int[${Me.Book[${Spell[${rkTemp}].RankName}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}]}]}==0 && ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}==0 && ${Int[${Me.CombatAbility[${Spell[${rkTemp}].RankName}]}]}==0) {
            /return ${Rk_Check_What}
        }
        DEBUGN SpellRankChecks: 1 rkCheck: "${rkCheck}" rkTemp: "${rkTemp}" rkdCheck: "${rkdCheck}" rkdTemp: "${rkdTemp}"
        | If this is NOT an Alt Ability then it must be a spell.
        /if (${Int[${Me.AltAbility[${rkTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
           /if (${DebugRK}) /echo 1a. well we think ${rkTemp} is an AA
           /varset rkCheck ${rkTemp}
        } else {
           /if (${DebugRK}) /echo 1c. well ${rkTemp} is not an AA or CombatAbility
           /varset rkCheck ${Spell[${rkTemp}].RankName}
        }
        | check for null
        DEBUGN SpellRankChecks: 2 rkCheck: ${rkCheck} rkTemp: ${rkTemp} Rk_Check_What: ${Rk_Check_What}
        | must NOT be null so lets fix Rk_Check_What.
        /if (${rkCheck.NotEqual[${rkTemp}]}) {
            /if (${Rk_Check_What.Find[|]}>0) {
                /varset rkCheck1 ${rkCheck}${Rk_Check_What.Right[-${Math.Calc[${Rk_Check_What.Find[|]}-1]}]}
                /varset rkCheck ${rkCheck1}
            }
        } else {
            /varset rkCheck ${Rk_Check_What}
        }
        /if (${Rk_Check_What.Arg[2,|].Equal[dual]}) {
            /if (${rkdTemp.Find[ Rk.]}) {
                /varset rkdTemp ${rkdTemp.Left[${Math.Calc[${rkdTemp.Find[ Rk.]}-1]}]}
            }
            /if (${Int[${Me.AltAbility[${rkdTemp}].ID}]}!=0 || ${Int[${Me.AltAbility[${rkTemp}].Spell.ID}]}!=0) {
                /varset rkdCheck ${Spell[${rkdTemp}].RankName}
            } else {
                /if (${Me.Subscription.NotEqual[gold]}) {
                    /varset rkdCheck ${rkdTemp}
                } else {
                    /varset rkdCheck ${Spell[${rkdTemp}].RankName}
                }
            }
            DEBUGN SpellRankChecks: 3 rkdCheck: ${rkdCheck} rkdTemp: ${rkdTemp} Rk_Check_What: ${Rk_Check_What}
            /varset rkCheck ${rkCheck.Arg[1,|]}|dual|${rkdCheck}
            /for rkd_i 4 to 10
                /if (!${Bool[${Rk_Check_What.Arg[${rkd_i},|]}]}) /break
                /varset rkCheck ${rkCheck}|${Rk_Check_What.Arg[${rkd_i},|]}
            /next rkd_i
        }
        DEBUGN SpellRankChecks: 4 Rk_Check_What: ${Rk_Check_What} rkCheck: ${rkCheck} rkTemp: ${rkTemp}
        DEBUGN SpellRankChecks: leave
    /return ${rkCheck}
| -------------------------------------------------------------------------------------
| SUB: Check cursor
| -------------------------------------------------------------------------------------
    Sub CheckCursor(string SentFrom, int ForceDrop)
        DEBUGN CheckCursor: enter ${SentFrom} ${ForceDrop}
        /if (${ForceDrop}) {
            /while (${Cursor.ID}) {
                /if (${Debug} && ${Cursor.ID}) /echo Dropping ${Cursor} ${SentFrom}
                /if (!${Me.FreeInventory}) {
                    /echo HEY YOUR INVENTORY IS FULL!
                    /break
                }
                /autoinventory
                /delay 10
            }
            /varset CursorID 0
        } else {
            /if ((!${CursorIDTimer} && !${CursorID}) || (${CursorID} && ${Cursor.ID}!=${CursorID})) {
                /varset CursorIDTimer 20s
                /varset CursorID ${Cursor.ID}
                /if (${Me.FreeInventory}) {
                    /echo ${Cursor.Name} is stuck on my cursor. Dropping it into inventory in 15s.
                } else {
                    /echo HEY YOUR INVENTORY IS FULL!
                }
            } else /if (!${CursorIDTimer}) {
                /while (${Cursor.ID}) {
                    /if (${Debug} && ${Cursor.ID}) /echo Dropping ${Cursor} ${SentFrom}
                    /autoinventory
                    /delay 10
                }
                /varset CursorID 0
            }
        }
        DEBUGN CheckCursor: leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Event LeftGroup
| -------------------------------------------------------------------------------------
    Sub Event_LeftGroup(Line,LGName)
        /varset EventFlag 1
        |/if (${GMailEvents.Find[leftgroup]}) /call GmailSend "${LGName} has left the group."
        /doevents flush LeftGroup
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind ZoneInfo
| -------------------------------------------------------------------------------------
    Sub Bind_ZoneInfo
        /declare LineInfo string local
        /declare zi_x int local
        /echo -------------------------------------------------------------------------
        /echo  ${ZoneName} - (${Zone.ShortName})
        /echo -------------------------------------------------------------------------
        /echo MezImmune: ${Ini[${InfoFileName},${ZoneName},MezImmune]}
        /echo MobsToPull: ${Ini[${InfoFileName},${ZoneName},MobsTopull]}
        /echo MobsToIgnore: ${Ini[${InfoFileName},${ZoneName},MobsToIgnore]}
        /echo MobsToBurn: ${Ini[${InfoFileName},${ZoneName},MobsToBurn]}
        /if (${PullLocsOn}) {
            /for zi_x 1 to ${PullLocs.Size}
                /if (${PullLocs[${zi_x}].Length} && ${PullLocs[${zi_x}].NotEqual[null]}) /echo PullLocs${zi_x}: ${PullLocs[${zi_x}]}
            /next zi_x
        }
        /echo -------------------------------------------------------------------------
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind WriteMySpell
| -------------------------------------------------------------------------------------
    Sub Bind_WriteMySpells(int Quite)
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /return
        /varcalc GemSlots ${Int[${Me.AltAbility[Mnemonic Retention].Rank}]}+8
        /declare i int local
        /for i 1 to ${GemSlots}
            /if (!${Quite}) /echo Gem ${i}: ${Me.Gem[${i}].Name}
            /ini "${IniFileName}" "Spells" "Gem${i}" "${Me.Gem[${i}].Name}"
        /next i
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind MemMySpells
| -------------------------------------------------------------------------------------
    Sub Bind_MemMySpells(Message, p_SpellSet)
        /declare temppCharName          string      local
        /declare pCharName              string      local ${Message}
        /declare tempIniFileName        string      local
        /declare pKV                    string      local
        /declare i                      int         local
        /declare ii                     int         local
        /declare SpellToMem             string      local
        /declare tempSpellName          string      local
        /declare tempSpellSection       string      local
        /declare int_WasIStanding       bool        local ${Me.Standing}
        
        DEBUGN MemMySpells: Enter
        /varcalc GemSlots ${Int[${Me.AltAbility[Mnemonic Retention].Rank}]}+8
        /if (!${pCharName.Length} || ${pCharName.Equal[null]}) {
           /varset temppCharName ${Me.CleanName}
        } else {
           /varset temppCharName ${pCharName}
        }
        /if (!${PIniSet}) {
            /if (${Ini[${MacroName}_${EverQuest.Server}_${temppCharName}.ini,General,KissAssistVer].Length}) {
                /varset tempIniFileName ${MacroName}_${EverQuest.Server}_${temppCharName}.ini
                /echo Server Name ini file detected using ${tempIniFileName}
            } else {
                /varset tempIniFileName ${MacroName}_${temppCharName}.ini
            }
        } else {
            /varset tempIniFileName ${IniFileName}
        }
        /varset pKV ${Ini[${tempIniFileName},General,KissAssistVer]}
        /if (${Int[${pKV}]}==0) {
           /echo Invalid INI file: ${tempIniFileName} for memorizing spells. Returning.
           /return
        }
        /if (${Bool[${p_SpellSet}]}) {
            /varset tempSpellSection Spells${p_SpellSet}
            /varset pKV ${Ini[${tempIniFileName},"${tempSpellSection}",Gem1]}
            /if (${Int[${pKV.Length}]}==0) {
               /echo No Spells Section found for: ${tempSpellSection}. Defaulting to Spells Section.
               /varset tempSpellSection Spells
               |/return
            }
        } else {
            /varset tempSpellSection Spells
        }
        /varset pKV ${Ini[${tempIniFileName},"${tempSpellSection}",Gem1]}
        /if (${Int[${pKV.Length}]}==0) {
           /echo No Spells found in INI file: ${tempIniFileName}. Use /writespells and try again. Returning.
           /return
        }
        /if (${IAmABard}) {
            /call CastBardCheck 0
        }
        /for i 1 to ${GemSlots}
            /varset SpellToMem ${Ini[${tempIniFileName},"${tempSpellSection}",Gem${i}]}
            /if (${SpellToMem.Length} && ${SpellToMem.NotEqual[null]}) {
                /if (${SpellToMem.Find[ Rk.]}) {
                   /varset tempSpellName ${SpellToMem.Left[${Math.Calc[${SpellToMem.Find[ Rk.]}-1]}]}
                } else {
                   /varset tempSpellName ${SpellToMem}
                }
                /varset SpellToMem ${Spell[${tempSpellName}].RankName}
                /if (${Me.Book[${SpellToMem}]}) {
                    /if (${Int[${Me.Gem[${SpellToMem}]}]}>0 && ${Int[${Me.Gem[${SpellToMem}]}]}!=${i}) {
                        /varcalc ii ${Int[${Me.Gem[${SpellToMem}]}]}-1
                        /notify CastSpellWnd CSPW_Spell${ii} rightmouseup
                        /delay 20 ${Int[${Me.Gem[${SpellToMem}]}]}==0
                    }
                    /if (!${Int[${Me.Gem[${i}].Name.Length}]} || ${Me.Gem[${i}].Name.NotEqual[${SpellToMem}]}) {
                        /varset DontMoveMe 1
                        /while (${Me.Moving}) {
                            /delay 5
                        }
                        /if (!${Me.Mount.ID} && ${Me.Standing}) /sit
                        /echo Meming ${SpellToMem} in slot ${i}
                        /if (${Stick.Active}) {
                            /stick pause
                            /MemSpell ${i} "${SpellToMem}"
                            /delay 150 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]}
                            /stick unpause
                        } else {
                            /MemSpell ${i} "${SpellToMem}"
                            /delay 150 ${Me.Gem[${i}].Name.Equal[${SpellToMem}]}
                        }
                        /varset DontMoveMe 0
                    }
                } else {
                    /echo Could Not find the spell ${tempSpellName} in your spell book.
                }
            }
        /next i
        /varset ReMemMiscSpell ${Me.Gem[${MiscGem}].Name}
        /varset ReMemMiscSpellLW ${Me.Gem[${MiscGemLW}].Name}
        /if (${IAmABard} && ${WasTwisting}) {
            /if (${Me.Sitting}) /stand
            /delay 5
            /squelch /twist
        } else /if (${int_WasIStanding} && ${Me.Sitting} && !${Me.Mount.ID}) {
            /stand
        }
    DEBUGN MemMySpells: leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind Parse
| -------------------------------------------------------------------------------------
    Sub Bind_Parse(TimeToParse)
        DEBUGN Bind_Parse Enter
        /if (!${Defined[ParseDPS]}) /declare ParseDPS     timer       outer       0
        /echo Parsing combat for ${TimeToParse} second
        /varset BurnAllNamed 0
        /tar npc dummy
        /delay 10 ${Target.ID}
        /varset MyTargetID ${Target.ID}
        /varset MyTargetName ${Target.CleanName}
        /varset ParseDPS ${TimeToParse}s
        /call Combat
        /call CombatReset 0 parse
        /target clear
        /attack off
        /stick off
        DEBUGN Bind_Parse Leave
    /return
| -------------------------------------------------------------------------------------
| SUB: Bind_TrackMeDown
| -------------------------------------------------------------------------------------
    Sub Bind_TrackMeDown(int StickOff, int UseNavOnly, int IgnoreDistance)
        /if (${DontMoveMe}) {
            /echo WAIT UP! I was told not to move. Leaving TrackMeDown.
            /return
        }
        DEBUGN Bind_TrackMeDown Enter
        /declare tmdChaseAssist int local ${ChaseAssist}
        /declare tmdReturnToCamp int local ${ReturnToCamp}
        /declare tmdChaseDistance int local ${ChaseDistance}
        /declare tmdCampRadiusExceed int local ${CampRadiusExceed}
        | Check if I am Dead.
        /if (${Me.Hovering} || ${IAmDead}) /return
        | Check if Who to chase character is in the zone.
        /if (${Spawn[pc ${WhoToChase}].ID}==0) /return
        /varset BindActive 1
        | Check if we are to use Navigation and it is loaded with a valid Mesh and Path.
        /if (${UseNavOnly} ) {
            /if (${PullMoveUse.NotEqual[nav]} || !${Navigation.MeshLoaded}) {
                /echo I can't Track Down ${WhoToChase}. Navigation not loaded or bad Mesh.
                /return
            } else {
                /if (${Navigation.PathExists[id ${Spawn[pc ${WhoToChase}].ID}]}==FALSE) {
                    /echo I can't Track Down ${WhoToChase}. No Valid Path too destination.
                    /return
                }
            }
        }
        /varset ChaseAssist 2
        /varset ReturnToCamp 0
        /varset ChaseDistance 20
        /if (${IgnoreDistance}) /varset CampRadiusExceed 100000
        /if (${Me.Casting.ID}) /stopcast
        | Go chase them down.
        /call DoWeChase TrackMeDown
        | Set things back
        /if (${tmdReturnToCamp}) {
            /varset CampXLoc ${Me.X}
            /varset CampYLoc ${Me.Y}
            /varset CampZLoc ${Me.FloorZ}
            /varset LookForward ${Me.Heading.DegreesCCW}
            /echo >> New camp set ${Me.Y}, ${Me.X}
        }
        /if (${StickOff}) {
            /if (${Stick.Active}) /squelch /stick off
        }
        /varset ChaseAssist ${tmdChaseAssist}
        /varset ReturnToCamp ${tmdReturnToCamp}
        /varset ChaseDistance ${tmdChaseDistance}
        /varset CampRadiusExceed ${tmdCampRadiusExceed}
        /varset BindActive 0
        DEBUGN Bind_TrackMeDown Leave
    /return
| -------------------------------------------------------------------------------------
| Task Code
| -------------------------------------------------------------------------------------
| SUB: Unmount
| -------------------------------------------------------------------------------------
    Sub Event_KTDismount
        /varset EventFlag 1
        |/declare factor1 int local 10
        /if (${MountOn}) /varset MountOn 0
        /if (${Me.Mount.ID}) {
            |/if (${Group}) {
            |    /varcalc factor1 
            |}
            /dismount
        }
    /return
|-----------------------------------------------------------------------------
| SUB: Target NPC
| ----------------------------------------------------------------------------
    Sub Event_KTTarget(Line, NPCName)
        /varset EventFlag 1
        /echo Targeting ${NPCName}
        /if (${NPCName.Equal[null]}) {
            /echo NPC Name is Null. Check your variables.
            /return FALSE
        }
        /if (!${Spawn[npc ${NPCName}].ID}) {
            /echo ${NPCName}? You must be in the wrong palce, no one here by that name
            /return FALSE
        }
        /target id ${Spawn[${NPCName}].ID}
        /delay 3s ${Target.ID}==${Spawn[${NPCName}].ID}
        /if (${Target.Distance}>15 && ${Target.Distance}<50) {
            /moveto id  ${Spawn[${NPCName}].ID}
            /delay 250 ${MoveTo.Stopped}
        }
        /varcalc ZDist ${Math.Distance[${Target.Z}:${Me.Z}]}-(${Target.Height}-${Me.Height})
        /call ZAxisCheck ${ZDist} 4.1
        /face ${If[${FaceMobOn}==2,nolook,fast nolook]}
        /delay 10
        /return TRUE
|-----------------------------------------------------------------------------
| SUB: KTHail
| ----------------------------------------------------------------------------
    Sub Event_KTHail(Line, KTMobID)
        |/varset EventFlag 1
        /tar id ${Spawn[npc ${KTMobID}].ID}
        /delay ${Math.Rand[30]}
        /keypress h
        /doevents flush KTaskSay
    /return
|-----------------------------------------------------------------------------
| SUB: KTSay
| ----------------------------------------------------------------------------
    Sub Event_KTSay(Line, KTSayWhat, KTMobID)
        |/varset EventFlag 1
        /tar id ${KTMobID}
        /delay ${Math.Rand[20]}
        /say ${KTSayWhat}
        /delay 10
        /doevents flush KTaskSay
    /return
|-----------------------------------------------------------------------------
| SUB: TaskDoorTarget
| ----------------------------------------------------------------------------
    Sub Event_KTDoorClick(Line, int KTDoorID)
        |/varset EventFlag 1
        /declare KTCDTimer timer local 10s
        /if (!${Defined[KTDoorID]}) {
            /doortarget
            /delay 3
            /declare KTDoorID ${DoorTarget.ID}
        }
        /echo DoorID: ${KTDoorID}
        /delay 10
        /keypress FIRST_PERSON_CAMERA hold
        /delay 2
        /keypress FIRST_PERSON_CAMERA
        /delay 10
        /if (${Target.ID}) /squelch /tar clear
        /delay 3
        /while (${KTCDTimer}) {
            /echo target door id ${KTDoorID}
            /if (${KTDoorID}) {
                /doortarget id ${KTDoorID}
            } else {
                /doortarget
            }
            /delay 3
            /echo ${DoorTarget.Name}
            /if (${Switch.ID}) /break
        }
        /face door
        /delay 3
        /if (!${KTCDTimer}) /varset KTCDTimer 50
        /while (${KTCDTimer} && ${DoorTarget.ID}) {
            /if (${DoorTarget.Distance}<=70)  {
                /echo Moving to Door
                /if (${DoorTarget.Distance}>15) {
                    /keypress forward hold
                    /delay 3
                    /keypress forward
                } else /if (${DoorTarget.Distance}<10) {
                    /keypress back hold
                    /delay 1
                    /keypress back
                }
            } else {
               /echo ${DoorTarget.Name} is too far away(${DoorTarget.Distance}). Get closer.
               /break
            }
            /if (!${Switch.Open}) {
                /face door
                /delay 3
                /echo clicking door
                /click left door
                /delay 1s
            } else {
                /break
            }
        }
        /if (${Window[largedialogwindow].Open}) {
            /notify largedialogwindow LDW_YesButton leftmouseup
        }
        /doevents flush KTDoorClick
    /return
|-----------------------------------------------------------------------------
| SUB: KTInvite
| ----------------------------------------------------------------------------
    Sub Event_KTInvite
        /varset EventFlag 1
        /declare i int
        /declare WhoToInvite ${SpawnCount[pc radius 75 guild]}
        /alert clear 6
        /squelch /alert add 6 ${Me}
        /for i 1 to ${WhoToInvite}
            /target id ${NearestSpawn[radius 75 pc guild noalert 6].ID}
            /delay 10
            /invite
            /delay 20
            /if (${EQBCOn} && ${Macro.IsTLO[EQBC]}) {
            /bct ${Target.CleanName} //invite
            } else /if (${DanNetOn} && ${Macro.IsTLO[DanNet]}) {
                /dex ${Target.CleanName} /invite
            }
            /delay 10
            /squelch /alert add 6 id ${Target.ID}
        /next i
    /return
|-----------------------------------------------------------------------------
| SUB: SetPullAngle
| ----------------------------------------------------------------------------
    Sub Bind_SetPullArc(float AWidth, string FDir)
        /declare DirDegree string local 0,45,90,135,180,225,270,315
        /declare FDirTemp  string local ${FDir}
        /if (!${AWidth}) {
            /if (${PullArcWidth}) {
                /echo Turning off Directional Pulling.
                /varset PullArcWidth 0
            }
            /return
        } else {
            /varset PullArcWidth ${AWidth}
        }
        /if (!${Bool[${FDir}]}) {
            /varset FDirTemp ${Me.Heading.Degrees}
        } else /if (${Float[${FDir}]}>0) {
            /varset FDirTemp ${FDir}
        } else {
            /varset FDirTemp ${DirDegree.Arg[${Select[${FDir},n,ne,e,se,s,sw,w,nw]},,]}.00
            /if (!${FDirTemp} && ${FDir.NotEqual[n]}) {
                /echo Invalid Direction. Turning off Directional Pulling.
                /varset PullArcWidth 0
                /return
            }
        }
        /call SetPullAngles ${Float[${FDirTemp}]} ${AWidth} 0
    /return
|-----------------------------------------------------------------------------
| SUB: SetPullAngles
| ----------------------------------------------------------------------------
    Sub SetPullAngles(float FDir, float AWidth, int IgnoreMessage)
        /if (!${AWidth}) /return
        /if (!${FDir}) /varset FDir 0.00
        | Figure the Degrees for the left side
        /if (${Math.Calc[${FDir}-(${AWidth}*.5)]}<0) {
            /varcalc PullLSide 360-((${AWidth}*.5)-${FDir})
        } else {
            /varcalc PullLSide ${FDir}-(${AWidth}*.5)
        }
        |Figure the Degrees for the right side
        /if (${Math.Calc[${FDir}+(${AWidth}*.5)]}>360) {
            /varcalc PullRSide ((${AWidth}*.5)+${FDir}-360)
        } else {
            /varcalc PullRSide ${FDir}+(${AWidth}*.5)
        }
        |Store your current heading
        /varset PullHeading ${FDir}
        /if (!${IgnoreMessage}) /echo Setting Pull Angles. Facing: ${FDir} Left Side: ${PullLSide} Right Side: ${PullRSide} Width: ${AWidth}
    /return
|-----------------------------------------------------------------------------
| SUB: FigureAngles
| ----------------------------------------------------------------------------
    Sub FigureMobAngle(int aMobID)
        /if (!${aMobID}) /return 0
        /declare DirectionToMob float local 0
        /varset DirectionToMob ${Spawn[${aMobID}].HeadingTo[${CampYLoc},${CampXLoc}].Degrees}
        /if (${PullLSide}>=${PullRSide}) {
            /if (${DirectionToMob}<${PullLSide} && ${DirectionToMob}>${PullRSide}) /return 0
        } else {
            /if (${DirectionToMob}<${PullLSide} || ${DirectionToMob}>${PullRSide}) /return 0
        }
    /return 1
|-----------------------------------------------------------------------------
| SUB: FeignAggroCheck
| ----------------------------------------------------------------------------
    Sub FeignAggroCheck
        /if (${AggroOffTimer}) {
            /while (${Me.Feigning} || ${Me.Invis}) {
                /doevents Timer
                /delay 5
            }
        } else {
            /doevents Timer
        }
    /return
|-----------------------------------------------------------------------------
| SUB: Reload INI Settings
| ----------------------------------------------------------------------------
    Sub Bind_Settings(string command1, string command2, int skipIniCheck)
        /declare CondNo     int     local     0
        /if (!${Select[${command1},load,list,help]}) {
            /echo Invalid Settings command.. Please use load, list, or help.
            /return
        }
        /if (${command1.Equal[load]}) {
            /if (!${command2.Length} || ${command2.Equal[null]}) /varset command2 all
            /if (!${Select[${command2},all,general,spells,buffs,melee,gom,gmail,ae,dps,aggro,heals,cures,pet,merc,mez,burn,pull,pulladvanced,afktools,conditions]}) {
                /echo Invalid reload option. Valid options are: general, spells, buffs, melee, gom, gmail, ae, dps, aggro, heals, cures, pet, merc, mez, burn, pull, pulladvanced, afktools, conditions, or all.
                /return
            }
            /echo Loading INI Info from ${command2} Section(s).
            | ************************* General **************************************|
            /if (${Select[${command2},all,general]}) {
                | Edit settings in your KissAssist_ToonName.ini file
                | Only call role from ini if not defined in command line from hot key
                /call LoadIni General Role                  string      Assist
                /if (${p_Role.NotEqual[null]}) /varset Role ${p_Role}
                /call LoadIni General CampRadius            int         30
                /call LoadIni General CampRadiusExceed      int         400
                /call LoadIni General ReturnToCamp          int         0
                /call LoadIni General ChaseAssist           int         0
                /call LoadIni General ChaseDistance         int         25
                /call LoadIni General MedOn                 int         1
                /call LoadIni General MedStart              int         20
                /call LoadIni General MedStop               int         100
                /call LoadIni General MedCombat             int         0
                /call LoadIni General LootOn                int         0
                /call LoadIni General RezAcceptOn           string      1|90
                /call LoadIni General AcceptInvitesOn       int         1
                /call LoadIni General GroupWatchOn          string      0
                /call LoadIni General GroupWatchCheck       string      FALSE
                /call LoadIni General CorpseRecoveryOn      int         0
                /if (${CorpseRecoveryOn}) {
                    /if (${Select[${Me.Class.ShortName},NEC,SHD]}) {
                        /if (${FindItemCount[Tiny Jade Inlaid Coffin]}<2 || ${Me.Level}<70) {
                            /varset CorpseRecoveryOn 2
                        }
                    } else /if (${Me.Class.ShortName.Equal[ROG]}) {
                        /if (!${Me.AltAbility[Shroud of Stealth]}) {
                            /varset CorpseRecoveryOn 2
                        }
                    } else {
                        /varset CorpseRecoveryOn 2
                    }
                }
                /if (${GroupWatchOn.Find[|]}) {
                    /varset GroupWatchPct ${GroupWatchOn.Arg[2,|]}
                    /varset GroupWatchOn ${GroupWatchOn.Arg[1,|]}
                }
                /call LoadIni General EQBCOn                string      0
                /call LoadIni General DanNetOn              string      0
                /call LoadIni General DanNetDelay           int         20
                /if (${EQBCOn}) {
                    /varset BroadCastSay bc
                    /if (${EQBCOn.Arg[2,|].Length} && ${EQBCOn.Arg[1,|].Equal[2]}) {
                        DEBUGN ${EQBCOn} ${EQBCOn.Arg[1,|]} ${EQBCOn.Arg[2,|]}
                        /varset BroadCastSay bct ${EQBCOn.Arg[2,|]}
                        /varset EQBCOn 2
                    }
                } else /if (${DanNetOn}) {
                    /varset BroadCastSay dgtell all
                    /if (${DanNetOn.Arg[2,|].Length} && ${DanNetOn.Arg[1,|].Equal[2]}) {
                        DEBUGN ${DanNetOn} ${DanNetOn.Arg[1,|]} ${DanNetOn.Arg[2,|]}
                        /varset BroadCastSay dgtell ${DanNetOn.Arg[2,|]}
                        /varset DanNetOn 2
                    }
                }
                /call LoadIni General IRCOn                 int         0
                /call LoadIni General CampfireOn            int         0
                /if (${Int[${Ini[${IniFileName},General,CharInfo].Arg[2,|]}]}!=${Me.Level}) /ini "${IniFileName}" "General" "CharInfo" "${Me.Class}|${Me.Level}|${Me.Subscription}"
                /if (${Int[${Ini[${IniFileName},General,DefaultUI].Arg[1,|]}]}!=${EverQuest.CurrentUI.Equal[Default]}) /ini "${IniFileName}" "General" "DefaultUI" "${If[${EverQuest.CurrentUI.Equal[Default]},TRUE,FALSE|Custom UIs are not supported. Please switch to Default UI before posting bugs.]}"
                /if (${Select[${Me.Class.ShortName},WIZ,DRU]}) {
                    /call LoadIni General GroupEscapeOn     int         0
                } else {
                    /if (!${Defined[GroupEscapeOn]}) {
                        /declare GroupEscapeOn              int         outer    0
                    }
                }
                /call LoadIni General DPSMeter              int         0
                /call LoadIni General ScatterOn             int         0
                /call LoadIni General LOSBeforeCombat       int         0
                /if (${IAmABard}) {
                    /call LoadIni General TwistOn           int         0
                    /call LoadIni General TwistMed          string      "Mana song gem"
                    /call LoadIni General TwistWhat         string      "Twist order here"
                } else {
                    /if (!${Defined[TwistOn]}) {
                        /declare TwistOn                    int         outer       0
                        /declare TwistMed                   string      outer       0
                        /declare TwistWhat                  string      outer       0
                    }
                }
                /if (${Int[${TwistMed.Left[1]}]}==0) /varset TwistMed 0
            }
            | ************************* Spells *************************************|
            /if (${Select[${command2},all,spells]}) {
                /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}==0) {
                    /call LoadIni SpellS MiscGem            int         8
                    /call LoadIni SpellS MiscGemLW          int         0
                    /call LoadIni SpellS MiscGemRemem       int         1
                    /call LoadIni SpellS LoadSpellSet       int         0
                    /call LoadIni SpellS SpellSetName       string      "KissAssist"
                    /call LoadIni Spells CastingInterruptOn int         1
                    /call LoadIni Spells CheckStuckGem      int         1
                    /if (${CastingInterruptOn}==1) /varset CastingInterruptOn 30
                } else /if (!${Defined[MiscGem]} ) {
                    /declare MiscGem                        int         outer   0
                    /declare MiscGemLW                      int         outer   0
                    /declare MiscGemRemem                   int         outer   0
                    /declare LoadSpellSet                   int         outer   0
                    /declare SpellSetName                   string      outer   null
                    /declare CastingInterruptOn             int         outer   0
                    /declare CheckStuckGem                  int         outer   0
                }
            }
            | ************************* Buffs ****************************************|
            /if (${Select[${command2},all,buffs]}) {
                /if (${LoadFromINI}) /call AutoLoad "buffs"
                /if (${Defined[Buffs]}) /deletevar Buffs
                /call LoadIni Buffs BuffsOn                 int         0
                /call LoadIni Buffs BuffsSize               int         20
                /declare Buffs[${BuffsSize}]                string      outer
                /call LoadIni Buffs Buffs                   string      NULL       Buffs
                /call LoadIni Buffs RebuffOn                int         1
                /call LoadIni Buffs CheckBuffsTimer         int         10
                /call LoadIni Buffs PowerSource             string      NULL
                /if (${BuffsOn}) {
                    /call SortArray Buffs 100|100 >
                } else {
                    /call CreateTimersBuffs
                }
            }
            | ************************* Melee ****************************************|
            /if (${Select[${command2},all,melee]}) {
                /call LoadIni Melee AssistAt                int         95
                /if (${p_AssistAt}) /varset AssistAt ${p_AssistAt}
                /if (${Select[${Me.Class.ShortName},BST,BER,MNK,PAL,RNG,ROG,SHD,WAR]}) {
                    /call LoadIni Melee MeleeOn             int         1
                } else {
                    /call LoadIni Melee MeleeOn             int         0
                }
                /call LoadIni Melee FaceMobOn               int         1
                /call LoadIni Melee MeleeDistance           int         75
                /call LoadIni Melee StickHow                string      "snaproll"
                /call LoadIni Melee AutoFireOn              int         0
                /call LoadIni Melee UseMQ2Melee             int         1
                /call LoadIni Melee TargetSwitchingOn       int         0
                /if (${Select[${Me.Class.ShortName},ROG]}) {
                    /call LoadIni Melee AutoHide            int         1
                } else /if (!${Defined[AutoHide]}) {
                    /declare AutoHide                       int         outer 0
                }
                /if (${IAmABard}) {
                    /call LoadIni Melee MeleeTwistOn        int         0
                    /call LoadIni Melee MeleeTwistWhat      string      "DPS twist order here"
                } else /if (!${Defined[MeleeTwistOn]}) {
                   /declare MeleeTwistOn                    int         outer       0
                   /declare MeleeTwistWhat                  string      outer       0
                }
                /call LoadIni Melee PetTauntOverride        int         0
            }
            | ************************* GoM ****************************************|
            /if (${Select[${command2},all,gom]}) {
                /if (!${Select[${Me.Class.ShortName},BRD,BER,MNK,ROG,WAR]}) {
                    /if (${Defined[GoMSpell]}) /deletevar GoMSpell
                    /call LoadIni GoM GoMSHelp              string       "Format - Spell|Target, MA Me or Mob, i.e. Rampaging Servant Rk. II|Mob"
                    /call LoadIni GoM GoMSize               int         3
                    /declare GoMSpell[${GoMSize}]           string      outer
                    /call LoadIni GoM GoMSpell              string      NULL       GoMSpell
                    /call CreateTimersGoM
                } else /if (!${Defined[GoMSize]}) {
                    /declare GoMSize                        int         outer 1
                    /declare GoMSpell[${GoMSize}]           string      outer
                }
            }
            | ************************* Gmail ****************************************|
            /if (${Select[${command2},all,gmail]}) {
                /if (${Defined[GMail]}) /deletevar GMail
                /call LoadIni GMail GMailHelp               string      "Events currently support - Dead,Drag,GM,Level,Named,Leftgroup,Tells"
                /call LoadIni GMail GMailOn                 int         0
                /call LoadIni GMail GMailSize               int         5
                /declare GMail[${GMailSize}]                string      outer
                /call LoadIni GMail GMail                   string      NULL       GMail
                /if (${GMailOn}) /call GmailIniParse
            }
            | *************************  AE ******************************************|
            /if (${Select[${command2},all,ae]}) {
                /if (${Defined[AE]}) /deletevar AE
                /call LoadIni AE AEOn                       int         0
                /call LoadIni AE AESize                     int         10
                /call LoadIni AE AERadius                   int         50
                /declare AE[${AESize}]                      string      outer
                /call LoadIni AE AE                         string      NULL       AE
            }
            | ************************* DPS ******************************************|
            /if (${Select[${command2},all,dps]}) {
                /if (${LoadFromINI}) /call AutoLoad "dps"
                /if (${Defined[DPS]}) /deletevar DPS
                /call LoadIni DPS DPSOn                     int         0
                /call LoadIni DPS DPSSize                   int         20
                /call LoadIni DPS DPSSkip                   int         20
                /call LoadIni DPS DPSInterval               int         2
                /declare DPS[${DPSSize}]                    string      outer
                /call LoadIni DPS DPS                       string      NULL        DPS
                /call LoadIni DPS DebuffAllOn               int         0
                /if (${DPSOn}) /call SortArray DPS 1|1 <
            }
            | ************************* Aggro ******************************************|
            /if (${Select[${command2},all,aggro]}) {
                /if (${Defined[Aggro]}) /deletevar Aggro
                /call LoadIni Aggro AggroOn                 int         0
                /if (${Select[${Me.Class.ShortName},SHD,WAR,PAL]})  {
                    /call LoadIni Aggro AggroSize           int         10
                } else {
                    /call LoadIni Aggro AggroSize           int         5
                }
                /declare Aggro[${AggroSize}]                string      outer
                /call LoadIni Aggro Aggro                   string      NULL        Aggro
                /if (${AggroOn}) /call SortArray Aggro 1|1 <
            }
            | ************************* Heals ***************************************|
            /if (${Select[${command2},all,heals]}) {
                /if (${Defined[AutoRez]}) /deletevar AutoRez
                /if (${Defined[Heals]}) /deletevar Heals
                /if (${Defined[SingleHeal]}) /deletevar SingleHeal
                /if (${Defined[GroupHeal]}) /deletevar GroupHeal
                /call LoadIni Heals Help                    string      "Format Spell|% to heal at i.e. Devout Light Rk. II|50"
                /if (${LoadFromINI}) /call AutoLoad "heals"
                /call LoadIni Heals HealsOn                 int         0
                /call LoadIni Heals HealInterval            int         0
                /call LoadIni Heals AutoRezOn               int         0
                /declare AutoRez[3]                         string      outer
                /if (${Select[${Me.Class.ShortName},CLR,SHM,DRU,PAL]})  {
                    /call LoadIni Heals HealsSize           int         15
                } else {
                    /call LoadIni Heals HealsSize           int         5
                }
                /declare Heals[${HealsSize}]                string      outer
                /declare GroupHeal[10]                      string      outer
                /declare SingleHeal[50]                     string      outer
                /call LoadIni Heals Heals                   string      NULL        Heals
                /call LoadIni Heals XTarHeal                int         0
                /call LoadIni Heals XTarHealList            string      "Xtar slots here Example: 5|6|7"
                /call LoadIni Heals HealGroupPetsOn         int         0
                /call LoadIni Heals RezMeLast               int         0
                /if (${HealsOn}) {
                    /call SortArray Heals 100|100 >
                    /call FindSingleHeals
                    /call FindGroupHeals
                    /call CreateTimersHeals
                }
                /if (${AutoRezOn}) /call CreateTimersRez
                /if (${XTarHeal} && ${XTarHealList.NotEqual[null]}) /call SetXTargetHealList "${XTarHealList}"
            }
            | ************************* Cures ***************************************|
            /if (${Select[${command2},all,cures]}) {
                /if (${Defined[Cures]}) /deletevar Cures
                /call LoadIni Cures CuresOn                 int         0
                /call LoadIni Cures CuresSize               int         5
                /declare Cures[${CuresSize}]                string      outer
                /call LoadIni Cures Cures                   string      NULL        Cures
            }
            | ************************* Pet *****************************************|
            /if (${Select[${command2},all,pet]}) {
                /if (${Defined[PetBuffs]}) /deletevar PetBuffs
                /if (${Defined[PetToysDone]}) /deletevar PetToysDone
                /if (${Defined[PetToys]}) /deletevar PetToys
                /if (${Select[${Me.Class.ShortName},DRU,SHM,BST,ENC,MAG,NEC,SHD]}) {
                    /call LoadIni Pet PetOn                 int         0
                    /call LoadIni Pet PetSpell              string      "YourPetSpell"
                    /call LoadIni Pet PetFocus              string      "NULL"
                    /call LoadIni Pet PetShrinkOn           int         0
                    /call LoadIni Pet PetShrinkSpell        string      "Tiny Companion"
                    /call LoadIni Pet PetBuffsOn            int         0
                    /call LoadIni Pet PetBuffsSize          int         8
                    /declare PetBuffs[${PetBuffsSize}]      string      outer
                    /call LoadIni Pet PetBuffs              string      NULL    PetBuffs
                    /call LoadIni Pet PetCombatOn           int         1
                    /call LoadIni Pet PetAssistAt           int         95
                    /call LoadIni Pet PetAttackDistance     int         115
                    /declare PetToysDone                    int         outer   0
                    /call LoadIni Pet PetToysSize           int         6
                    /declare PetToys[${PetToysSize}]        string      outer
                    /if (${Select[${Me.Class.ShortName},MAG]}) {
                        /call LoadIni Pet PetToysOn         int         0
                        /call LoadIni Pet PetToys           string      NULL    PetToys
                        /call LoadIni Pet PetToysGave       string      NULL
                    } else /if (!${Defined[PetToysOn]}) {
                        /declare PetToysGave                string      outer   NULL
                        /declare PetToysOn                  int         outer   0
                    }
                    /call LoadIni Pet PetBreakMezSpell      string      NULL
                    /call LoadIni Pet PetRampPullWait       int         0
                    /call LoadIni Pet PetSuspend            int         0
                    /call LoadIni Pet MoveWhenHit           int         0
                    /call LoadIni Pet PetHoldOn             int         1
                    /if (!${Defined[PetHold]}) /declare PetHold                        string     outer
                    /if (${Int[${Me.AltAbility[Companion's Discipline]}]} > 0) {
                        /if (${Me.AltAbility[Companion's Discipline]}>1) {
                            /varset PetHold ghold
                        } else {
                            /varset PetHold hold
                        }
                    }
                    /call LoadIni Pet PetForceHealOnMed     int         0
                } else /if (!${Defined[PetOn]}) {
                    /declare PetForceHealOnMed              int         outer   0
                    /declare PetOn                          int         outer   0
                    /declare PetAssistAt                    int         outer   0
                    /declare PetCombatOn                    int         outer   0
                    /declare PetRampPullWait                int         outer   0
                    /declare PetHoldOn                      int         outer   0
                    /declare PetHold                        string      outer   0
                    /declare PetToysOn                      int         outer   0
                    /declare PetAttackDistance              int         outer   0
                }
            }
            | ************************* Merc ****************************************|
            /if (${Select[${command2},all,merc]}) {
                /call LoadIni Merc Help                     string      "To use: Turn off Auto Assist in Manage Mercenary Window"
                /call LoadIni Merc MercOn                   int         0
                /call LoadIni Merc MercAssistAt             int         92
            }
            | ************************* Mez *****************************************|
            /if (${Select[${command2},all,mez]}) {
                /if (${Defined[MezAECount]}) /deletevar MezAECount
                /if (${Defined[MezCount]}) /deletevar MezCount
                /if (${Defined[MezAEClosest]}) /deletevar MezAEClosest
                /if (${Select[${Me.Class.ShortName},BRD,ENC,NEC]}) {
                    /call LoadIni Mez MezOn                 int         0
                    /call LoadIni Mez MezRadius             int         50
                    /call LoadIni Mez MezMinLevel           int         "Min Mez Spell Level"
                    /call LoadIni Mez MezMaxLevel           int         "Max Mez Spell Level"
                    /call LoadIni Mez MezStopHPs            int         80
                    /call LoadIni Mez MezSpell              string      "Your Mez Spell"
                    /call LoadIni Mez MezDebuffOnResist     int         0
                    /call LoadIni Mez MezDebuffSpell        string      "Your Debuff Spell"
                    | necros can't AE mez
                    /if (${Select[${Me.Class.ShortName},BRD,ENC]}) {
                        /call LoadIni Mez MezAESpell        string      "Your AE Mez Spell|0"
                        /declare MezAECount                 int         outer   ${MezAESpell.Arg[2,|]}
                        /varset MezAESpell                  ${MezAESpell.Arg[1,|]}
                    }
                    /declare MezCount[13]                   int         outer 0
                    /declare MezAEClosest                   int         outer 0
                } else /if (!${Defined[MezOn]}) {
                    /declare MezOn                          int         outer 0
                }
                
                | This loads and declares the MezImmune var
                /call LoadIni "${ZoneName}" MezImmune   string      "List up to 10 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL ${InfoFileName}
                /call LoadIni "${ZoneName}" AAMezImmune int         0 0 ${InfoFileName}
                /if (${MezOn}) /call CreateTimersMez
                |KissAssist_Info variables
                /if (!${MezImmune.Find[null]} && ${MezImmune.Length}>0) {
                    /squelch /alert clear 4
                    /call AlertAddToList 4 "${MezImmune}"
                } else {
                    /varset MezImmune null
                }
            }
            | ************************* Burn ****************************************|
            /if (${Select[${command2},all,burn]}) {
                /if (${Defined[Burn]}) /deletevar Burn
                /call LoadIni Burn  BurnAllNamed            int         0
                /call LoadIni Burn  UseTribute              int         0
                /call LoadIni Burn  BurnSize                int         15
                /declare Burn[${BurnSize}]                  string      outer
                /call LoadIni Burn  Burn                    string      NULL        Burn
                /call SortArray Burn 1|1 >
                /call FixBurnSpells
            }
            | ************************* Pull ****************************************|
            /if (${Select[${command2},all,pull]}) {
                /call LoadIni Pull PullWith                 string      "Melee"
                /call LoadIni Pull PullMeleeStick           int         0
                /call LoadIni Pull MaxRadius                int         350
                /call LoadIni Pull MaxZRange                int         50
                /call LoadIni Pull UseWayPointZ             int         0
                /call LoadIni Pull PullWait                 int         5
                                                                        | Include the # symbol for mobs with names that start with # 
                /call LoadIni "${ZoneName}" MobsToPull      string      "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or ALL for all mobs" NULL  ${InfoFileName}
                /call LoadIni "${ZoneName}" MobsToIgnore    string      "List up to 25 mobs. Use full names i.e. a green snake,a blue tiger,a wide eye ooze or NULL" NULL ${InfoFileName}
                /call LoadIni "${ZoneName}" MobsToBurn      string      "List up to 10 mobs. Use full names i.e. Beget Cube,Helias,Raze or NULL" Null ${InfoFileName}
                /call LoadIni "${ZoneName}" PullPath        string      "Place holder for path file. Not yet impletmented." NULL ${InfoFileName}
                /if (${p_PullPath.NotEqual[null]}) /varset PullPath ${p_PullPath}
                /call LoadIni Pull PullRadiusToUse          int         90
                /call LoadIni Pull PullRoleToggle           int         0
                /call LoadIni Pull ChainPull                int         0
                /call LoadIni Pull ChainPullHP              int         90
                /call LoadIni Pull PullPause                string      30|2
                /call LoadIni Pull PullLevel                string      0|0
                /call LoadIni Pull PullArcWidth             string      0
                
                /if (${IAmABard}) {
                    /call LoadIni Pull PullTwistOn          int         0
                } else /if (!${Defined[PullTwistOn]}) {
                    /declare PullTwistOn                    int         outer       0
                }
                /call LoadIni Pull PullOnReturn             int         0
                /if ((${MobsToPull.Find[all for all]} || !${MobsToPull.Length} || ${MobsToPull.Equal[all]} || ${MobsToPull.Equal[null]}) && (${MobsToIgnore.Find[or null]} || !${MobsToIgnore.Length} || ${MobsToIgnore.Equal[null]})) {
                    /varset MobsToPull all
                    /varset MobsToIgnore null
                } else /if (${MobsToIgnore.Find[or null]} || !${MobsToIgnore.Length} || ${MobsToIgnore.Equal[null]}) {
                    /varset MobsToIgnore null
                } else /if (${MobsToPull.Find[all for all]} || !${MobsToPull.Length} || ${MobsToPull.Equal[all]} || ${MobsToPull.Equal[null]}) {
                    /varset MobsToPull all
                }
                /squelch /alert clear 2
                /if (${MobsToPull.Equal[all]}) {
                    /varset SearchType noalert 1
                } else {
                    /call AlertAddToList 2 "${MobsToPull}" "null"
                    /varset SearchType alert 2
                }
                /squelch /alert clear 3
                /if (${MobsToIgnore.NotEqual[null]}) {
                    /call AlertAddToList 3 "${MobsToIgnore}" "null"
                }
                /if (${Role.Find[Puller]} || ${Role.Find[hunter]}) {
                    /if (${Bool[${Plugin[MQ2Map]}]}) {
                        /squelch /mapfilter CastRadius color 25 225 25
                        /squelch /mapfilter SpellRadius color 25 25 225
                        /squelch /mapfilter PullRadius color 255 255 0
                        /squelch /mapfilter CampRadius color 255 25 25
                    }
                }
                /if (!${PullRadiusToUse} || ${PullRadiusToUse}>100) /varset PullRadiusToUse 100
            }
            | *********************** PullAdvanced ***********************************|
            /if (${Select[${command2},all,pullAdvanced]}) {
                /if (${Defined[PullLocs]}) /deletevar PullLocs
            |    /call LoadIni pullAdvanced CalmOn           int         0
            |    /call LoadIni pullAdvanced CalmWith         string      0
            |    /call LoadIni pullAdvanced CalmRadius       int         50
            |    /call LoadIni pullAdvanced PullAbortOn      int         0      
            |    /call LoadIni pullAdvanced PullAbortCMD     string      null

                /declare PullLocs[5]                        string      outer
                /call LoadIni PullAdvanced PullLocsOn       int         0
                /call LoadIni "${ZoneName}" PullLocsHelp    string      "Y,X|Range. Ignore mobs in this area" NULL ${InfoFileName}
                /call LoadIni "${ZoneName}" PullLocs        string      0        PullLocs ${InfoFileName}
            }
            | ************************* AFKTools ************************************|
            /if (${Select[${command2},all,afktools]}) {
                /call LoadIni AFKTools AFKHelp              string      "AFKGMAction=0 Off, 1 Pause Macro, 2 End Macro, 3 Unload MQ2, 4 Quit Game"
                /call LoadIni AFKTools AFKToolsOn           int         1
                /call LoadIni AFKTools AFKGMAction          int         1
                /call LoadIni AFKTools AFKPCRadius          int         500
                /call LoadIni AFKTools CampOnDeath          int         0
                /call LoadIni AFKTools ClickBacktoCamp      int         0
            }
            | ************************* Kcond ************************************|
            /if (${Select[${command2},all,conditions]}) {
                /if (${Defined[Cond]}) /deletevar Cond
                /call LoadIni KConditions ConOn             int         0
                /call LoadIni KConditions CondSize          int         5
                /declare Cond[${CondSize}]                  string      outer
                /call LoadIni KConditions Cond              string      TRUE      Cond
            }
            | Re-figure Declared variables if needed.
            /if (${Select[${command2},all,pull]}) {
                /if (${PullPause.Find[|cond]}) {
                    /squelch /engine parser 2
                    /varset CondNo ${PullPause.Mid[${Math.Calc[${PullPause.Find[|cond]}+5]},3]}
                    /varset PullHoldCond ${Parse[1,${Cond[${CondNo}]}]}
                    /squelch /engine parser 1
                } else {
                    /varset PullHoldCond FALSE
                }
            }
            /if (!${skipIniCheck}) {
                /echo Checking your ini file for errors.
                /call ScanIni ${command2}
            }
        }
        DEBUGN Settings: 1: ${command1} 2: ${command2} procesed
    /return
|-----------------------------------------------------------------------------
| SUB: AssignLooter
| ----------------------------------------------------------------------------
    Sub AssignLooter
        /if (${Select[${Me},${Group.Leader}]}==0) /return
        /if (${LooterAssigned}) /return
        /if (${Group}<=0 || ${Raid.Members}>0) /return
        /if (${Group.MasterLooter.ID}>=1) /return
        DEBUGN Sub AssignLooter Enter
        /declare k int local
        /declare IniIDList string local
        /declare IniIDCount int local
        /declare IniID int local
        /declare AmIML string local
        /if (!${DanNetOn}) {
            /varset IniIDList ${Ini["KissAssist_Buffs.ini"]}
            /varcalc IniIDCount ${IniIDList.Count[|]}
        } else {
            /varset IniIDList ${DanNet.Peers[all]}
            /varset IniIDCount ${IniIDList.Count[|]}
        }
        /if (!${IniIDCount}) /return
        /declare pIDList[${IniIDCount}] string local 
        /for k 1 to ${IniIDCount}
            /varset pIDList[${k}] ${IniIDList.Arg[${k},|]}
        /next k
        | If I am group leader set Main Looter Tag for Group
        /if (${Select[${Me},${Group.Leader}]}) {
            DEBUGN AssignLooter: /echo I am group Leader
            |Assign myself as MainLooter if LootOn=1
            /if (${LootOn}) {
                DEBUGN AssignLooter: /echo I am the looter
                /if (${Group.MasterLooter.Name.NotEqual[${Me}]} && ${Group.MasterLooter.Name.Length}) {
                    /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                    /delay 30 !${Group.MasterLooter.Name.Length}
                    /call AssignGroupRole set "${Group.MainAssist.Name}" 5
                    /call BroadCast r "Assigning ${Me} as Master Looter in Group Window"
                    /varset LooterAssigned 1
                    /return
                }
            } else {
                DEBUGN AssignLooter: Looking for looter
                /for k 1 to ${IniIDCount}
                    /if (!${DanNetOn}) {
                        /varset IniID ${pIDList[${k}]}
                        /varset AmIML ${Ini["KissAssist_Buffs.ini",${IniIDList.Arg[${k},|]},"AmILooting"]}
                    } else {
                        /varset IniID ${Int[${Spawn[=${pIDList[${k}]}].ID}]}
                        /if (!${IniID} || ${IniID}==${Me.ID} || !${Spawn[id ${IniID} pc group].ID}) /continue
                        /dquery ${pIDList[${k}]} -q "LootOn" -o DNout -t ${DanNetDelay}
                        /if (${Int[DNout]}==0) /continue
                        /varset AmIML ${DNout}
                    }
                    DEBUGN AssignLooter: ${Spawn[${IniIDList.Arg[${k},|]}].ID} ${IniID} ${AmIML} ${Spawn[${IniIDList.Arg[${k},|]}].Type.NotEqual[pc]} ${Spawn[id ${IniIDList.Arg[${k},|]} group].ID}
                    | If toon is not the zone or not a PC skip to next ID
                    /if (!${Spawn[id ${IniID}].ID} || ${Spawn[id ${IniID}].Type.NotEqual[pc]} || !${AmIML}) /continue
                    /if (${Spawn[id ${IniID} pc group].ID}) {
                        | If Looter is someone else than who its suppose to be unset Group tag
                        /if (${Group.MasterLooter.Name.Length} && ${Group.MasterLooter.Name.NotEqual[${Spawn[id ${IniID} group pc].CleanName}]}) /call AssignGroupRole unset "${Group.MasterLooter.Name}" 5
                        /delay 30 !${Group.MasterLooter.Name.Length}
                        /call AssignGroupRole set "${Spawn[id ${IniID} group pc].CleanName}" 5
                        /call BroadCast r "LOOT: Assigning ${Spawn[id ${IniID} group pc].CleanName} as Master Looter in Group Window"
                        /varset LooterAssigned 1
                        /return
                    }
                /next k
            }
        }
        DEBUGN Sub AssignLooter Leave
    /return
| ----------------------------------------------------------------------------
| SUB: GmailParse
| ----------------------------------------------------------------------------
    Sub GmailIniParse
        DEBUGN GmailIniParse Enter
        /declare i int local 0
        /declare GMailEventCheck string local
        /for i 1 to ${GMail.Size}
            /varset GMailEventCheck ${Ini[${IniFileName},Gmail,Gmail${i}]}
            /if (${GMailEventCheck.Length} && ${GMailEventCheck.NotEqual[null]}) {
                /if (${Select[${GMailEventCheck},Dead,Drag,GM,Level,Named,Leftgroup,Tells]}) {
                     DEBUGN /echo ${i}. ${GMailEventCheck}
                    /if (${GMailEvents.Length}) {
                        /varset GMailEvents ${GMailEvents},${GMailEventCheck}
                    } else {
                        /varset GMailEvents ${GMailEventCheck}
                    }
                }
            }
        /next i
        DEBUGN GmailIniParse Leave
    /return
| ----------------------------------------------------------------------------
| SUB: GmailSend
| ----------------------------------------------------------------------------
    Sub GmailSend(GMessage)
        | Not supported by MQNext. Current Date: 11/6/2021
    /return
| ----------------------------------------------------------------------------
| SUB: GmailSend1
| ----------------------------------------------------------------------------
    Sub GmailSend1(GMessage)
        /return
        DEBUGN GmailSend Enter
        |Goofy time shit because Gmail fails if any entry has a colon : in it.
        /declare GTime string local
        /declare GtimeHour string local ${Time.Hour}
        /declare AMPM string local am
        /if (${Time.Hour}>=13) {
            /varset GtimeHour ${Int[${Math.Calc[${Time.Hour}-12]}]}
            /varset AMPM pm
        }
        /varset GTime Date.${Time.Date} Time.${GtimeHour}.${Time.Minute} ${AMPM}
        | Ghetto fix for buffer overflow until MQ2GMail is fixed
        /if (${Bool[${Plugin[MQ2Gmail]}]}) /squelch /plugin MQ2Gmail unload noauto
        /squelch /plugin MQ2Gmail noauto
        /gmail "Kiss-${EverQuest.Server}-${Me}" "${GTime} - ${GMessage}"
        /echo GMAIL just sent "Kiss-${EverQuest.Server}-${Me}" "${GTime} - ${GMessage}"
        /varcalc GSent ${GSent}+1
        /if (${GSent}==5) {
            /varset GSent 0
        }
        /delay 10
        DEBUGN GmailSend Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Roguestuff
| ----------------------------------------------------------------------------
    Sub Roguestuff
        /if (${Me.Hovering}) /return
        DEBUGN Roguestuff Enter
        /if (${Me.Class.Name.Equal[Rogue]} && !${Me.Combat} && ${AutoHide}) {
            /if (${Me.AbilityReady[hide]} && ${Me.AbilityReady[sneak]}) {
                /doability hide
                /doability sneak
            }
        }
        DEBUGN Roguestuff Leave
    /return
| ----------------------------------------------------------------------------
| SUB: LoadSpellSet
| ----------------------------------------------------------------------------
    Sub LoadSpellSet
        DEBUGN LoadSpellSet Enter
        /declare GemNum      int local
        /declare ValidSpells int local 0

        DEBUGN Sub LoadSpellSet LoadSpellSet=(${LoadSpellSet})
        /varcalc GemSlots ${Int[${Me.AltAbility[Mnemonic Retention].Rank}]}+8
        /if (${LoadSpellSet}==1) {
            DEBUGN Sub LoadSpellSet SpellSetName=(${SpellSetName})
            /echo Memming spellset (${SpellSetName}).
            /memspellset ${SpellSetName}
            /delay ${Math.Calc[${GemSlots}*10]}
        } else {
            |---Test to see if we have MySpells section defined in INI or not.
            /for GemNum 1 to ${GemSlots}
                /call LoadIni Spells Gem${GemNum} string NULL
                /if (${Gem${GemNum}.Length} && ${Gem${GemNum}.NotEqual[NULL]}) {
                    |-- We have found a good spell defined, one good spell is all it takes to be a valid Spells config.
                    /varset ValidSpells 1
                    /break
                }
            /next GemNum
            /if (${LoadSpellSet}==2) {
                /if (!${ValidSpells}) {
                    /echo You have no valid spells defined in your ini file [Spells], load your spells now and do a /writespells command while in KissAsssist.
                } else {
                    /call Bind_MemMySpells ${Me.CleanName}
                }
            }
        }
        |-- If we called this routine, make sure we update values for ReMemMiscSpell and ReMemMiscSpellLW since they might have changed after spellset load.
        /varset ReMemMiscSpell ${Me.Gem[${MiscGem}].Name}
        /varset ReMemMiscSpellLW ${Me.Gem[${MiscGemLW}].Name}
        DEBUGN LoadSpellSet Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Set Window Title Buffs
| ----------------------------------------------------------------------------
    Sub WinTitle
        DEBUGN WinTitle Enter
        /SetWinTitle ${Me.Name} (Lvl:${Me.Level} ${Zone.ShortName})
        DEBUGN WinTitle Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Set Xtargets to Heal
| ----------------------------------------------------------------------------
    Sub SetXTargetHealList(string HealList)
        /if (!${XTarHeal} && ${HealList.Equal[null]}) /return
        /declare n int local 0
        /if (${HealList.Equal[all]}) {
            /for GlobalIndex 1 to ${XSlotTotal}
                /if (${Me.XTarget[${GlobalIndex}].TargetType.Equal[Auto Hater]}) {
                    /echo XTarget ${GlobalIndex} is assigned as Auto Hater. You may want to fix this when using the ALL tag.
                } else {
                    /varcalc n ${n}+1
                    /varset XTarToHeal[${n}] ${GlobalIndex}
                }
            /next GlobalIndex
            /if (${n} && ${n}<${XSlotTotal}) {
                /varcalc n ${n}+1
                /for GlobalIndex ${n} to ${XSlotTotal}
                    /varset XTarToHeal[${GlobalIndex}] 0
                /next GlobalIndex
            }
        } else /if (${HealList.Equal[auto]}) {
            /for GlobalIndex 1 to ${XSlotTotal}
                /if (${Me.XTarget[${GlobalIndex}].TargetType.Equal[Auto Hater]}) {
                    /continue
                } else {
                    /varcalc n ${n}+1
                    /varset XTarToHeal[${n}] ${GlobalIndex}
                }
            /next GlobalIndex
            /if (${n} && ${n}<${XSlotTotal}) {
                /varcalc n ${n}+1
                /for GlobalIndex ${n} to ${XSlotTotal}
                    /varset XTarToHeal[${GlobalIndex}] 0
                /next GlobalIndex
            }
        } else {
            /varset n 1
            /varset GlobalIndex 1
            /if (${HealList.Find[|]}) {
                /while (${GlobalIndex}<${XSlotTotal}) {
                    /if (${Int[${HealList.Arg[${GlobalIndex},|]}]}>0 && ${Int[${HealList.Arg[${GlobalIndex},|]}]}<=${XSlotTotal}) {
                        /varset XTarToHeal[${n}] ${Int[${HealList.Arg[${GlobalIndex},|]}]}
                        /if (${Me.XTarget[${XTarToHeal[${n}]}].TargetType.Equal[Auto Hater]}) /echo XTarget ${XTarToHeal[${n}]} is assigned as Auto Hater. You may want to fix this.
                        /varcalc n ${n}+1
                        /varcalc GlobalIndex ${GlobalIndex}+1
                    } else /if (${Int[${HealList.Arg[${GlobalIndex},|]}]}==0) {
                        /varset XTarToHeal[${n}] 0
                        /varcalc GlobalIndex ${XSlotTotal}+1
                    } else {
                        /varcalc GlobalIndex ${GlobalIndex}+1
                    }
                }
            } else {
                /varset XTarToHeal[1] ${Int[${HealList}]}
            }
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Grab Corpse
| ----------------------------------------------------------------------------
    Sub DoClassStuff
        | Reserved for now
    /return
| ----------------------------------------------------------------------------
| SUB: Summon Corpse
| ----------------------------------------------------------------------------
    Sub RecoverCorpses(string rc_Flag1,int rc_Distance)
        /declare int_summonID    int    local 0
        /declare int_summonLevel int    local 0
        /declare int_coffinCount int    local 0
        /declare int_corpseCount int    local 0
        /declare int_idx1        int    local 0
        /declare int_idx2        int    local 0
        /declare str_useWhat     string local
        /declare str_Status      string local false
        /declare tim_wait1       timer  local 0
        /if (${AggroTargetID} || ${Me.Invis}) /return false
        /if (!${Select[${Me.Class.ShortName},shd,nec,rog]}) /return false
        
        /if (!${rc_Distance}) /varset rc_Distance 150
        DEBUGN SummonCorpse Enter ${rc_Flag1} ${rc_Distance}
        /if (${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}]}>10) /call DoWeMove 1 summoncorpse
        /if (!${SpawnCount[pccorpse ${Me}]} && !${SpawnCount[pccorpse group]}) /return false
        /if (${Select[${Me.Class.ShortName},shd,nec]}) {
            /if (${FindItemCount[Tiny Jade Inlaid Coffin]}<2) {
                /varset CorpseRecoveryOn 2
                /return false
            }
            /while (1) {
                /varset int_coffinCount ${FindItemCount[Tiny Jade Inlaid Coffin]}
                /varset int_summonID 0
                /varset str_useWhat null
                /if (${SpawnCount[pccorpse ${Me}]}) {
                    /if (${NearestSpawn[1,${Me} pccorpse].Distance3D}>${rc_Distance}) {
                        /varset int_summonID ${Me.ID}
                        /varset int_summonLevel ${Me.Level}
                    }
                }
                /if (!${int_summonID}) {
                    /if (${rc_Flag1.Equal[me]}) /break
                    /for int_idx1 1 to 5
                        /if (${Group.Member[${int_idx1}].OtherZone} || ${Group.Member[${int_idx1}].Type.Equal[corpse]} || ${Group.Member[${int_idx1}].Distance3D}>100) /continue
                        /varset int_corpseCount ${SpawnCount[${Group.Member[${int_idx1}].CleanName} pccorpse]}
                        /if (${int_corpseCount}) {
                            /for int_idx2 1 to ${int_corpseCount}
                                /if (${NearestSpawn[${int_idx2},${Group.Member[${int_idx1}].CleanName} pccorpse].Distance3D}>${rc_Distance}) {
                                    /varset int_summonID ${Group.Member[${int_idx1}].ID}
                                    /varset int_summonLevel ${Group.Member[${int_idx1}].Level}
                                    /break
                                }
                            /next int_idx2
                        }
                        /if (${int_summonID}) /break
                    /next int_idx1
                }
                
                /if (!${int_summonID}) /break
 
                /if (${Me.AltAbilityReady[Summon Remains]} && ${int_coffinCount}>3) {
                    /varset str_useWhat Summon Remains
                } else /if (${int_coffinCount}>1) {
                    /if (${Me.Spell[Thanatos' Proclamation].ID}) {
                        | Up to level 120 TJIC x 2
                        /varset str_useWhat Thanatos' Proclamation
                    } else /if (${Me.Spell[Duskreaper's Proclamation].ID} && ${int_summonLevel}<116) {
                        | Up to level 115 TJIC x 2
                        /varset str_useWhat Duskreaper's Proclamation
                    } else /if (${Me.Spell[Shadereaper's Proclamation].ID} && ${int_summonLevel}<111) {
                        | Up to level 110 TJIC x 2
                        /varset str_useWhat Shadereaper's Proclamation
                    } else /if (${Me.Spell[Stormreaper's Proclamation].ID} && ${int_summonLevel}<106) {
                        | Up to level 105 TJIC x 2
                        /varset str_useWhat Stormreaper's Proclamation
                    } else /if (${Me.Spell[Reaper's Proclamation].ID} && ${int_summonLevel}<101) {
                        | Up to level 100 TJIC x 2
                        /varset str_useWhat Reaper's  Proclamation
                    } else /if (${Me.Spell[Reaper's Decree].ID} && ${int_summonLevel}<96) {
                        | Up to level 95 TJIC x 2
                        /varset str_useWhat Reaper's Decree
                    } else /if (${Me.Spell[Reaper's Beckon].ID} && ${int_summonLevel}<91) {
                        | Up to level 90 TJIC x 2
                        /varset str_useWhat Reaper's Beckon
                    } else /if (${Me.Spell[Reaper's Call].ID} && ${int_summonLevel}<86) {
                        | Up to level 85 TJIC x 2
                        /varset str_useWhat Reaper's Call
                    } else /if (${Me.Spell[Procure Corpse].ID} && ${int_summonLevel}<81) {
                        | Up to level 80 TJIC x 2
                        /varset str_useWhat Procure Corpse
                    } else /if (${Me.Spell[Exhumer's Corpse].ID} && ${int_summonLevel}<76) {
                        | Up to level 75 TJIC x 2
                        /varset str_useWhat Exhumer's Corpse
                    } else /if (${Me.Spell[Conjure Corpse].ID} && ${int_summonLevel}<71) {
                        | Up to level 70 TJIC x 2
                        /varset str_useWhat Conjure Corpse
                    }
                }
                /if (${str_useWhat.Equal[null]}) /break
                
                /while (${Me.SpellInCooldown}) {
                   /delay 5
                }
                
                /if (${Me.Gem[${str_useWhat}]}) {
                    /varset tim_wait1 350
                    /while (!${Me.SpellReady[${str_useWhat}]} && ${tim_wait1}) {
                        /if (${ChaseAssist}) {
                            /call DoWeChase 0 summoncorpse
                        } else {
                            DOPARSE
                            /delay 5
                        }
                    }
                    /if (!${Me.SpellReady[${str_useWhat}]}) /break
                }
                
                /if (${Me.Invis}) /break
                /if (!${Target.ID} || ${Target.ID}!=${int_summonID}) /squelch /target id ${int_summonID}
                /call CastWhat "${str_useWhat}" ${int_summonID} summoncorpse-nomem 0 0
                /if (${Macro.Return.Equal[cast_success]}) {
                    /call BroadCast r "Summoned Corpse for: ${Spawn[ID ${int_summonID}].CleanName} Using: ${str_useWhat}"
                    /varset str_Status true
                    /delay 20
                } else {
                    /break
                }
                /if (${rc_Flag1.Equal[me]}) /break 
            
            | End of While Loop.
            }
        } else /if (${Me.Class.ShortName.Equal[rog]}) {
            /echo Rogues are not Supported at this time. Thank you for shopping at RedGuides.
            /delay 50
            /varset CorpseRecoveryOn 2
        }
        DEBUGN SummonCorpse Leave ${int_summonID} ${int_coffinCount} ${str_useWhat} ${int_summonLevel}
    /return ${str_Status}
| ----------------------------------------------------------------------------
| SUB: Grab Corpse
| ----------------------------------------------------------------------------
    Sub GrabCorpse(int checkFlag)
        DEBUGN GrabCorpse Enter ${checkFlag}
        /if (!${checkFlag}) /varset checkFlag 1
        /if (${checkFlag}==1) {
            /if (${SpawnCount[pccorpse ${Me}]}) {
                /if (${CorpseRecoveryOn}==1) {
                    /if (${NearestSpawn[1,pccorpse ${Me}].Distance3D}>89) {
                        /call RecoverCorpses "me" 89
                        /delay 30
                    }
                }
                /if (${SpawnCount[pccorpse ${Me} radius 89]}) {
                    /corpsedrag
                    /varset DragCorpse 1
                }
            }
        } else /if (${checkFlag}==2) {
            /if (${Math.Distance[${CampYLoc},${CampXLoc}]}>=${CampRadius}) {
                /target ${Me}
                /delay 10
                /corpsedrag
                /varset DragCorpse 1
                /echo Hey I found my corpse. Running back to camp for a rez
                |/if (${GMailEvents.Find[drag]}) /call GmailSend "Hey I found my corpse. Running back to camp for a rez!"
            }
        }
        DEBUGN GrabCorpse Leave
    /return
| ----------------------------------------------------------------------------
| SUB: DoCastingEvents
| ----------------------------------------------------------------------------
    Sub DoCastingEvents(int CastTimer, int actionFlag)
        DEBUGCAST DoCastingEvents \awEnter
        /declare CastCalcTimer timer local 10
        /declare castHold string local ${castReturn}
        /if (${CastTimer}) /varset CastCalcTimer ${CastTimer}
        /while (${CastCalcTimer} && ${castHold.Equal[${castReturn}]}) {
            /doevents CAST_BEGIN
            /doevents CAST_CANNOTSEE
            /doevents CAST_COLLAPSE
            /doevents CAST_COMPONENTS
            /doevents CAST_DISTRACTED
            /doevents CAST_FDFAIL
            /doevents CAST_FIZZLE
            /doevents CAST_IMMUNE
            /doevents CAST_INTERRUPTED
            /doevents CAST_NOMOUNT
            /doevents CAST_NOTARGET
            /doevents CAST_NOTREADY
            /doevents CAST_OUTDOORS
            /doevents CAST_OUTOFMANA
            /doevents CAST_OUTOFRANGE
            /doevents CAST_RECOVER
            /varset CheckResisted 1
            /doevents CAST_RESISTED
            /varset CheckResisted 0
            /doevents CAST_RESISTEDYOU
            /doevents CAST_STANDING
            /doevents CAST_STUNNED
            /doevents CAST_TAKEHOLD
            /doevents CAST_FAILED
            /if (${actionFlag}) /break
        }
        DEBUGCAST DoCastingEvents \awLeave ${CastCalcTimer} ${castHold} ${castReturn} ${Me.Casting.ID} ${Window[CastingWindow].Open}
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_BEGIN
| ----------------------------------------------------------------------------
    Sub Event_CAST_BEGIN(line,CBItem)
        DEBUGCAST Event_CAST_BEGIN \awEnter ${line}
        /varset castReturn CAST_SUCCESS
        
        DEBUGCAST Event_CAST_BEGIN \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_CANNOTSEE
| ----------------------------------------------------------------------------
    Sub Event_CAST_CANNOTSEE
        DEBUGCAST Event_CAST_CANNOTSEE \awEnter
        /varset castReturn CAST_CANNOTSEE
        DEBUGCAST Event_CAST_CANNOTSEE \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_COLLAPSE
| ----------------------------------------------------------------------------
    Sub Event_CAST_COLLAPSE
        DEBUGCAST Event_CAST_COLLAPSE \awEnter
        /varset castReturn CAST_COLLAPSE
        DEBUGCAST Event_CAST_COLLAPSE \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_COMPONENTS
| ----------------------------------------------------------------------------
    Sub Event_CAST_COMPONENTS
        DEBUGCAST Event_CAST_COMPONENTS \awEnter
        /varset castReturn CAST_COMPONENTS
        /doevents flush CAST_COMPONENTS
        DEBUGCAST Event_CAST_COMPONENTS \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_DISTRACTED
| ----------------------------------------------------------------------------
    Sub Event_CAST_DISTRACTED
        DEBUGCAST Event_CAST_DISTRACTED \awEnter
        /varset castReturn CAST_DISTRACTED
        DEBUGCAST Event_CAST_DISTRACTED \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_FAILED
| ----------------------------------------------------------------------------
    Sub Event_CAST_FAILED(line,name)
        DEBUGCAST Event_CAST_FAILED \awEnter
        /varset castReturn CAST_FAILED
        DEBUGCAST Event_CAST_FAILED \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_FDFAIL
| ----------------------------------------------------------------------------
    Sub Event_CAST_FDFAIL(line,name)
        DEBUGCAST Event_CAST_FDFAIL \awEnter
        /if (${name.Equal[${Me.Name}]} && ${Defined[castReturn]}) {
            /if (${Me.Sitting}) /stand
            /varset castReturn CAST_RESTART
        }
        DEBUGCAST Event_CAST_FDFAIL \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_FIZZLE
| ----------------------------------------------------------------------------
    Sub Event_CAST_FIZZLE
        DEBUGCAST Event_CAST_FIZZLE \awEnter
        /varset castReturn CAST_FIZZLE
        DEBUGCAST Event_CAST_FIZZLE \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_IMMUNE
| ----------------------------------------------------------------------------
    Sub Event_CAST_IMMUNE(line,name)
        DEBUGCAST Event_CAST_IMMUNE \awEnter
        DEBUGCAST Event_CAST_IMMUNE \aw${line}
        /varset castReturn CAST_IMMUNE
        DEBUGCAST Event_CAST_IMMUNE \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_INTERRUPT
| ----------------------------------------------------------------------------
    Sub Event_CAST_INTERRUPTED
        DEBUGCAST Event_CAST_INTERRUPT \awEnter
        /varset castReturn CAST_INTERRUPTED
        DEBUGCAST Event_CAST_INTERRUPT \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_NOMOUNT
| ----------------------------------------------------------------------------
    Sub Event_CAST_NOMOUNT
        DEBUGCAST Event_CAST_NOMOUNT \awEnter
        /varset castReturn CAST_NOMOUNT
        DEBUGCAST Event_CAST_NOMOUNT \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_NOTARGET
| ----------------------------------------------------------------------------
    Sub Event_CAST_NOTARGET
        DEBUGCAST Event_CAST_NOTARGET \awEnter
        /varset castReturn CAST_NOTARGET
        DEBUGCAST Event_CAST_NOTARGET \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_NOTREADY
| ----------------------------------------------------------------------------
    Sub Event_CAST_NOTREADY
        DEBUGCAST Event_CAST_NOTREADY \awEnter
        /varset castReturn CAST_NOTREADY
        DEBUGCAST Event_CAST_NOTREADY \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_OUTDOORS
| ----------------------------------------------------------------------------
    Sub Event_CAST_OUTDOORS
        DEBUGCAST Event_CAST_OUTDOORS \awEnter
        /varset castReturn CAST_OUTOFMANA
        DEBUGCAST Event_CAST_OUTDOORS \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_OUTOFMANA
| ----------------------------------------------------------------------------
    Sub Event_CAST_OUTOFMANA
        DEBUGCAST Event_CAST_OUTOFMANA \awEnter
        /varset castReturn CAST_OUTOFMANA
        DEBUGCAST Event_CAST_OUTOFMANA \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_OUTOFRANGE
| ----------------------------------------------------------------------------
    Sub Event_CAST_OUTOFRANGE
        DEBUGCAST Event_CAST_OUTOFRANGE \awEnter
        /varset castReturn CAST_OUTOFRANGE
        DEBUGCAST Event_CAST_OUTOFRANGE \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_RECOVER
| ----------------------------------------------------------------------------
    Sub Event_CAST_RECOVER
        DEBUGCAST Event_CAST_RECOVER \awEnter
        /varset castReturn CAST_RECOVER
        DEBUGCAST Event_CAST_RECOVER \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_RESISTED
| ----------------------------------------------------------------------------
    Sub Event_CAST_RESISTED(line,name)
        DEBUGCAST Event_CAST_RESISTED \awEnter
        DEBUGCAST Event_CAST_RESISTED \aw${name.Length} ${CheckResisted}
        /if (!${CheckResisted}) /return
        /echo \aw${name} was Resisted \ag
        /if (${castReturn.NotEqual[CAST_IMMUNE]}) /varset castReturn CAST_RESISTED
        /varset LastResisted ${name}
        DEBUGCAST Event_CAST_RESISTED \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_RESISTEDYOU
| ----------------------------------------------------------------------------
    Sub Event_CAST_RESISTEDYOU(line,name)
        DEBUGCAST Event_CAST_RESISTEDYOU \awEnter
        DEBUGCAST Event_CAST_RESISTEDYOU \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_STANDING
| ----------------------------------------------------------------------------
    Sub Event_CAST_STANDING
        DEBUGCAST Event_CAST_STANDING \awEnter
        /stand
        /varset castReturn CAST_RESTART
        DEBUGCAST Event_CAST_STANDING \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_STUNNED
| ----------------------------------------------------------------------------
    Sub Event_CAST_STUNNED
        DEBUGCAST Event_CAST_STUNNED \awEnter
        /if (${Me.Stunned}) {
            /delay 3s !${Me.Stunned}
        } else {
            /delay 7
        }
        /varset castReturn CAST_STUNNED
        DEBUGCAST Event_CAST_STUNNED \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_Success1
| ----------------------------------------------------------------------------
    Sub Event_CAST_SUCCESS1(line)
        DEBUGCAST Event_CAST_SUCCESS1 \awEnter
        /varset castReturn CAST_SUCCESS
        DEBUGCAST Event_CAST_SUCCESS1 \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: Event_CAST_TAKEHOLD
| ----------------------------------------------------------------------------
    Sub Event_CAST_TAKEHOLD
        DEBUGCAST Event_CAST_TAKEHOLD \awEnter
        /varset castReturn CAST_TAKEHOLD
        DEBUGCAST Event_CAST_TAKEHOLD \awLeave
    /return
| ----------------------------------------------------------------------------
| SUB: ChainPullNextMob
| ----------------------------------------------------------------------------
    Sub ChainPullNextMob(int EchoWaitMessage)
        /if (${Math.Distance[${CampYLoc},${CampXLoc}:${Spawn[=${MainAssist}].Y},${Spawn[=${MainAssist}].X}]}<=75) {
            /if (!${PullHold} && ${MobCount}<2 && !${Me.XTarget[${XTSlot2}].ID} && ${If[${Target.Named},0,1]}==1) {
                /if (${Target.ID} && ${Target.PctHPs} < ${ChainPullHP}) {
                    /call FindMobToPull 0 1 0
                    /if (${Macro.Return}>0 && (!${PullXPCheck} || (${Spawn[${ChainPullTemp}].Distance}<${Math.Calc[${PullRange}+400]} && ${PullXPCheck})) && ${Me.TargetOfTarget.Name.NotEqual[${Me.CleanName}]} && ${Me.PctAggro}<50) {
                        /varset PullMob ${Macro.Return}
                        /if (${UseMQ2Melee}) /squelch /melee melee=0
                        /if (${Stick.Active}) /squelch /stick off
                        /squelch /attack off
                        /delay 10
                        /if (${UseMQ2Melee}) /squelch /melee melee=1
                        /varset ChainPull 2
                        /varset MyTargetID 0
                        /varset Attacking 0
                        /varset CombatStart 0
                        /return 1
                    } else {
                        DEBUGCHAINPULL Chain Pull Failed 3: ${Macro.Return} ${PullXPCheck} ${Spawn[${ChainPullTemp}].Distance}<${Math.Calc[${PullRange}+400]} ${Me.TargetOfTarget.Name} ${Me.PctAggro}
                    }
                } else {
                    DEBUGCHAINPULL Chain Pull Failed 2: ${Target.ID} ${Target.PctHPs}<${ChainPullHP}
                }
            } else {
                DEBUGCHAINPULL Chain Pull Failed 1: ${PullHold} ${MobCount}<2 ${Me.XTarget[${XTSlot2}].ID} ${Target.Named}
            }
        } else /if (${EchoWaitMessage}) {
            /call BroadCast r "Holding Pulls. Tank to far from camp."
            /return W
        }
    /return 0
| ----------------------------------------------------------------------------
| SUB: Auto Load INI Entries
| ----------------------------------------------------------------------------
    Sub AutoLoad(string SectionName)
        /if (${SectionName.Equal[null]} || !${SectionName.Length}) /return
        /if (${Select[${SectionName},buffs,heals,dps]}==0) /return
        /echo AutoLoad INI - ${SectionName}
        /declare ActionsTag     string     local
        /declare SpellLevel     int        local
        /declare SpellLevelChk  int        local
        /declare ka             int        local
        /declare kb             int        local
        /declare kc             int        local
        /declare kl             int        local
        /declare km             int        local
        /declare kx             int        local
        /declare AutoLoadFile   string     local     AUTO${Me.Class.ShortName}.ini
        /declare SpellList      string     local
        /declare SpellListL     string     local
        /declare SpellListT     string     local
        /declare SpellName      string     local
        /declare SpellNameChk   string     local
        /declare VarArray       string     local
        /declare SpellTag       string     local
        /declare SpellTagL      string     local     null
        /declare UseLowerLevel  int        local     0
        /declare MemTheSpell    int        Local     0
        /if (${SectionName.Equal[buffs]}) {
            /varset VarArray Buffs
        } else /if (${SectionName.Equal[heals]}) {
            /varset VarArray Heals
        } else /if (${SectionName.Equal[dps]}) {
            /varset VarArray DPS
        } else {
            /echo Invalid Auto Array (${SectionName}) to check.
            /return
        }
        /varset ka 1
        /varset kc 0
        | File Name Format: AUTO Class Short Name .ini Example: AUTOCLR.ini, AUTOSHM.ini, AUTOMAG.ini
        | tag: is used for what you want to tag on after the end of the spell name. 
        |      Use standard kiss syntax. 
        |      This should come before the Actions: tag
        |      Example: tag:90|MA.
        | Actions Tag Syntax:
        |      UL - Is used to designate the use of a lower level spell for the previous spell list. This allows for 2 remedy spells.
        |           The spell based on your current level and the one just below your current level.
        |      Mem|# - Mem the spell in Gem #. This has to be last entry on line.
        | 
        | Heals1=Ethereal Remedy,Supernal Remedy,Pious Remedy,Sacred Remedy,Solemn Remedy,Devout Remedy,Earnest Remedy,Faithful Remedy,Graceful Remedy,Spiritual Remedy,Merciful Remedy,tag:85|MA,Actions:Mem|1
        | Heals2=tag:90|MA,Actions:UL|Mem|2
        | Heals3=tag:75|!MA
        | Heals4=tag:80|!MA,Actions:UL
        | OR
        | Heals3=tag:75
        | Heals4=tag:80,Actions:UL
        |
        /varset SpellListL null
        /while (1) {
            /varset SpellList null
            /varset SpellListT null
            /varset SpellLevel 0
            /if (${Ini[${AutoLoadFile},${SectionName},${VarArray}${ka}].Length}) {
                /varset SpellListT ${Ini[${AutoLoadFile},${SectionName},${VarArray}${ka}]}
            }
            /if (${SpellListT.NotEqual[null]}) {
                /varset kb 1
                /varset SpellTag null
                /varset kx 1
                /varset ActionsTag null
                | lets parse the line for tags and spells.
                /while (1) {
                    /if (!${Bool[${SpellListT.Arg[${kx},,]}]}) /break
                    /varset SpellNameChk ${SpellListT.Arg[${kx},,]}
                    /if (${SpellNameChk.Left[4].Equal[tag:]}) {
                        /varset SpellTag ${SpellNameChk.Replace[tag:,]}
                    } else /if (${SpellNameChk.Left[8].Equal[actions:]}) {
                        /varset ActionsTag ${SpellNameChk.Replace[actions:,]}
                    } else {
                        /if (${SpellList.Equal[null]}) {
                            /varset SpellList ${SpellNameChk}
                        } else {
                            /varset SpellList ${SpellList},${SpellNameChk}
                        }
                    }
                    /varcalc kx ${kx}+1
                }
                /if (${ActionsTag.NotEqual[null]}) {
                    /if (${ActionsTag.Arg[1,|].Equal[ul]}) {
                        /varset UseLowerLevel 1
                        /if (${ActionsTag.Arg[2,|].Equal[mem]}) {
                            /varset MemTheSpell ${Int[${ActionsTag.Arg[3,|]}]}
                        } else {
                            /varset MemTheSpell 0
                        }
                    } else /if (${ActionsTag.Arg[1,|].Equal[mem]}) {
                        /varset UseLowerLevel 0
                        /varset MemTheSpell ${Int[${ActionsTag.Arg[2,|]}]}
                    }
                } else {
                    /varset MemTheSpell 0
                    /varset UseLowerLevel 0
                }
                | Set SpellList to previous list if no spells listed in the current entry.
                /if (${SpellList.Equal[null]}) {
                    /if (${SpellListL.Equal[null]}) /continue
                    /varset SpellList ${SpellListL}
                } else {
                    /varset SpellListL ${SpellList}
                }
                
                /varset SpellName null
                
                |/if (!${SpellListT.Find[,lowerlevel]}) {
                /if (!${UseLowerLevel}) {
                    /while (${Bool[${SpellList.Arg[${kb},,]}]}) {
                        /varset SpellNameChk ${SpellList.Arg[${kb},,].Lower}
                        |/if (${SpellNameChk.Left[4].NotEqual[tag:]}) {
                            /varset SpellLevelChk ${Int[${Spell[${SpellNameChk}].Level}]}
                            /if (${SpellLevelChk}<=${Me.Level} && ${SpellLevel}<${SpellLevelChk}) {
                                | No ${FindItem[=${SpellNameChk}].ID} yet, For like Mounts and stuff. Will have to figure out later.
                                /if (${Me.Book[${SpellNameChk}]} || ${Me.AltAbility[${SpellNameChk}]} || ${Me.CombatAbility[${SpellNameChk}]} || ${Me.Skill[${SpellNameChk}]}) {
                                    /varset SpellLevel ${SpellLevelChk}
                                    /varset SpellName ${SpellNameChk}
                                    /varset kl ${kb}
                                }
                            }
                        |} else {
                        |    /varset SpellTag ${SpellNameChk.Replace[tag:,]}
                        |    /varset SpellTagL null
                        |}
                        /varcalc kb ${kb}+1
                    }
                } else {
                    /if (${kl}>1) {
                        /varcalc km ${kl}-1
                        /varset SpellName ${SpellList.Arg[${km},,].Lower}
                        /varset SpellLevel ${Int[${Spell[${SpellName}].Level}]}
                        /if (${SpellTagL.NotEqual[null]} && ${SpellTag.Equal[null]}) /varset SpellTag ${SpellTagL}
                    }
                }
                /if (${SpellName.NotEqual[null]} && ${SpellLevel}>0) {
                    /varcalc kc ${kc}+1
                    /if (${SpellTag.NotEqual[null]}) {
                        /varset SpellTagL ${SpellTag}
                        /varset SpellName ${SpellName}|${SpellTag}
                    }
                    |} else {
                    |    /varset SpellTagL null
                    |}
                    /ini "${IniFileName}" "${SectionName}" "${VarArray}${kc}" "${SpellName}"
                }
            } else {
                /break
            }
            /varcalc ka ${ka}+1
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Startup commands
| ----------------------------------------------------------------------------
    Sub StartupCommands
        DEBUGN StartupCommands Enter
        /declare CommandText string   local null
        /declare i           int      local 0
        /declare StartCount  int      local 0
        /declare CondNo      int      local 0
        /if (!${Ini[${IniFileName},"StartupCommands","CommandSize"].Length}) /return
        /varset StartCount ${Ini[${IniFileName},"StartupCommands","CommandSize"]}
        /if (!${StartCount}) /return
        /for i 1 to ${StartCount}
            /varset CommandText ${Ini[${IniFileName},"StartupCommands","Command${i}"]}
            /if (${ConOn} && ${CommandText.Find[|cond]}) {
                /varset CondNo ${CommandText.Mid[${Math.Calc[${CommandText.Find[|cond]}+5]},3]}
            } else {
                /varset CondNo 0
            }
            /if (${CommandText.Length} && ${CommandText.NotEqual[null]}) {
                /if (${CondNo} && ${If[${Cond[${CondNo}]},0,1]}) /continue
                /docommand ${CommandText}
                DOPARSE
                /delay 5
            }
        /next i
        DEBUGN StartupCommands Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Pause While Hovering
| ----------------------------------------------------------------------------
    Sub PauseWhileHovering(string SentFrom)
        DEBUGN PauseWhileHovering SentFrom: ${SentFrom} Enter
        /declare idx int local 0
        /doevents flush
        /while (${Me.Hovering}) {
            /if (${Role.Find[Puller]} && ${ClickBacktoCamp} && ${ReturnToCamp} && ${Math.Distance[${CampYLoc},${CampXLoc}:${Me.Y},${Me.X}]}>150) {
                /if (${Me.ItemReady[=Fellowship Registration Insignia]}) {
                    /if (${Window[respawnWnd].Open}) {
                        /varset idx ${Window[respawnWnd].Child[RW_OptionsList].List[=Bind Location,2]}
                        /if (${idx}) {
                            /nomodkey /notify respawnWnd RW_OptionsList listselect ${idx}
                            /delay 10
                            /nomodkey /notify respawnwnd RW_SelectButton leftmouseup
                        }
                    }
                } else {
                    /delay 10
                }
            } else {
                /delay 10
            }
        }
        DEBUGN PauseWhileHovering Leave
    /return
| ----------------------------------------------------------------------------
| SUB: Pause While Hovering
| ----------------------------------------------------------------------------
    Sub PauseWhileZoning(string SentFrom)
        DEBUGN \atPauseWhileZoning SentFrom: ${SentFrom} \awEnter
        /while (!${Me.ID} || !${Zone.ID}) {
            /delay 10
        }
        DEBUGN \atPauseWhileZoning \awEnter
    /return
| ----------------------------------------------------------------------------
| SUB: Kiss Conditions
| ----------------------------------------------------------------------------
    Sub KissConditons
        /call LoadIni KConditions Cond              string      TRUE      Cond
    /return
| ----------------------------------------------------------------------------
| SUB: Check and Fix Stuck Gems
| ----------------------------------------------------------------------------
    Sub CheckStuckGems
        /if (${Window[CastingWindow].Open} || ${Me.Invis}) /return
        /if (${Me.AltAbilityReady[origin]}) {
            /echo ***** Stuck Gem Detected ***** ${Me.SpellInCooldown}
            /alt act ${Me.AltAbility[origin].ID}
            /delay 50 ${Window[CastingWindow].Open}
            /stopcast
            /delay 10
        } else {
            /echo Origin AA not ready.
            /delay 20
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Fix Burn Spells
| ----------------------------------------------------------------------------
    Sub FixBurnSpells
        /declare i        int    local 0
        /declare CondNo   int    local 0
        /declare BurnArg1 string local
        /declare BurnArg2 string local
        /declare BurnArg3 string local
        /for i 1 to ${Burn.Size}
            /if (${Burn[${i}].NotEqual[null]}) {
                /if (${Burn[${i}].Find[|cond]}) {
                    /varset CondNo ${Burn[${i}].Mid[${Math.Calc[${Burn[${i}].Find[|cond]}+5]},3]}
                } else {
                    /varset CondNo 0
                }
                /varset BurnArg1 ${Burn[${i}].Arg[1,|]}
                /if (${Select[${Burn[${i}].Arg[2,|]},mob,me,ma,pet]}) {
                    /varset BurnArg2 ${Burn[${i}].Arg[2,|]}
                } else {
                    /varset BurnArg2 mob
                }
                /if (${Select[${Burn[${i}].Arg[3,|]},1,2,3]}) {
                    /varset BurnArg3 ${Burn[${i}].Arg[3,|]}
                } else {
                    /varset BurnArg3 1
                }
                /if (${CondNo}) {
                    /varset Burn[${i}] ${BurnArg1}|${BurnArg2}|${BurnArg3}|cond${CondNo}
                } else {
                    /varset Burn[${i}] ${BurnArg1}|${BurnArg2}|${BurnArg3}
                }
            }
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: Clear Array
| ----------------------------------------------------------------------------
    Sub ClearArray(CArrayName, CArraySize, CArrayMemberSize)
        /if (!${Defined[CArraySize]}) /return
        /if (!${Defined[CArrayMemberSize]}) /declare CArrayMemberSize string local 0
        /declare i int local
        /declare j int local
        /for i 1 to ${CArraySize}
            /if (${CArrayMemberSize}>=1) {
                /for j 1 to ${CArrayMemberSize}
                    /varset ${CArrayName}[${i},${j}] 0
                /next j
            } else {
                /varset ${CArrayName}[${i}] 0
            }
        /next i
    /return
| ----------------------------------------------------------------------------
| SUB: Buff List
| ----------------------------------------------------------------------------
    Sub Bind_TooBuffList(string Action, int ActionID)
        DEBUGBUFF TooBuffList: Enter
        /declare WorkOnID int local ${Int[${ActionID}]}
        /declare WorkOnName string local
        /declare j1 int local 0
        /declare PeersZone string local
        /if (!${WorkOnID}) /varset WorkOnID ${Target.ID}
        DEBUGBUFF TooBuffList: Action: ${Action} ActionID: ${ActionID} WorkOnID: ${WorkOnID}
        /if (!${WorkOnID} && ${Select[${Action},add,remove]}>0) {
            /echo Invalid ID. Please target a Character or use a proper ID.
            /return
        }
        /varset WorkOnName ${Spawn[id ${WorkOnID}].CleanName}
        /if (!${Action.Length} || ${Action.Equal[null]} || ${Select[${Action},add,remove,reset,clear]}==0) {
            /echo Invalid Action for Too Buff List, please use add, remove, reset or clear.
            /return
        }
        /if (${Action.Equal[reset]}) {
            /if (${ExtendedBuffList.Count[|]}>0) {
                /varset j1 1
                /while (${ExtendedBuffList.Arg[${j1},|].Length} && ${ExtendedBuffList.Arg[${j1},|].NotEqual[null]}) {
                    /if (!${Spawn[=${ExtendedBuffList.Arg[${j1},|]}].ID}) {
                        /echo Removed ${ExtendedBuffList.Arg[${j1},|]} from the Too Buff List.
                        /varset ExtendedBuffList ${ExtendedBuffList.Replace[${ExtendedBuffList.Arg[${j1},|]}|,]}
                    } else {
                        /varcalc j1 ${j1}+1
                    }
                }
            }
        } else /if (${Action.Equal[remove]}) {
            /if (${ExtendedBuffList.Find[${WorkOnName}|]}) {
                /varset ExtendedBuffList ${ExtendedBuffList.Replace[${WorkOnName}|,]}
                /echo Removed ${WorkOnName} from Too Buff List.
            } else {
                /echo ${WorkOnName} Not Found on the Too Buff List.
            }
        } else /if (${Action.Equal[clear]}) {
            /echo Too Buff List Cleared.
            /varset ExtendedBuffList
        } else {
            /if (${ExtendedBuffList.Count[|]}>49) {
                /echo There is a limit of 50 ID's. Please remove some before trying to add more.
                /return
            }
            /if (${ExtendedBuffList.Find[${WorkOnName}|]}) {
                /echo ${WorkOnName} Found on Too Buff List. No Need to add again.
                /return
            }
            /if (${Macro.IsTLO[DanNet]} && ${DanNetOn}) {
                /if (${Zone.ShortName.Find[_]}) {
                    /varset PeersZone zone_${Zone.ShortName}
                } else {
                    /varset PeersZone zone_${EverQuest.Server.Lower}_${Zone.ShortName}
                }
                /if (${DanNet.Peers[${PeersZone}].Find[${WorkOnName}|]}) {
                    /echo ${WorkOnName} Found on DanNet Peers[${PeersZone}] List. No Need to add.
                    /return
                }
            }
            /varset ExtendedBuffList ${ExtendedBuffList}${WorkOnName}|
            /Echo Added ${WorkOnName} to the Too Buff List.
        }
        /varset g_ExtendedBuffList ${ExtendedBuffList}
        DEBUGBUFF TooBuffList: Exit
    /return
| ----------------------------------------------------------------------------
| SUB: Ini Cleanup
| ----------------------------------------------------------------------------
    Sub IniCleanup
        /declare ICidx int local 0
        /declare ICtemp string local null
        | General Section
        /ini "${IniFileName}" "General" "ConditionsOn" NULL
        /ini "${IniFileName}" "General" "MiscGem" NULL
        /ini "${IniFileName}" "General" "MiscGemLW" NULL
        /ini "${IniFileName}" "General" "MiscGemRemem" NULL
        /ini "${IniFileName}" "General" "CastingInterruptOn" NULL
        | Buffs Section
        | Melee Section
        /ini "${IniFileName}" "Melee" "BeforeCombat" NULL
        | AE Section
        /ini "${IniFileName}" "AE" "AECOn" NULL
        | DPS Section
        /ini "${IniFileName}" "DPS" "DPSCOn" NULL
        | Aggro Section
        /ini "${IniFileName}" "Aggro" "AggroCOn" NULL
        /ini "${IniFileName}" "Aggro" "Aggro2nd" NULL
        | Heals section
        /ini "${IniFileName}" "Heals" "HealsCOn" NULL
        /ini "${IniFileName}" "Heals" "XTarHeal2" NULL
        /ini "${IniFileName}" "Heals" "AutoRez" NULL
        /ini "${IniFileName}" "Heals" "AutoRez1" NULL
        /ini "${IniFileName}" "Heals" "AutoRez2" NULL
        /ini "${IniFileName}" "Heals" "AutoRez3" NULL
        | Burn Section
        /ini "${IniFileName}" "Burn" "BurnCOn" NULL
        | GOM Section
        /ini "${IniFileName}" "GOM" "GOMCOn" NULL
        | Pull Section
        /ini "${IniFileName}" "Pull" "ChainPullPause" NULL
        | Old SpellSet section. Was moved to Spells section.
        /ini "${IniFileName}" "SpellSet" NULL
        | My Spells Section
        /varset ICtemp ${Ini[${IniFileName},MySpells,Gem1,BLANK]}
        /if (${ICtemp.Length}>0 && ${Select[${ICtemp},blank,null]}==0) {
            /for ICidx 1 to 13
                /varset ICtemp ${Ini[${IniFileName},MySpells,Gem${ICidx},NULL]}
                /ini "${IniFileName}" "Spells" "Gem${ICidx}" "${ICtemp}"
            /next ICidx
            /ini "${IniFileName}" "MySpells" NULL
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Init Data
| ----------------------------------------------------------------------------
    Sub InitData
        /declare n              int       local
        /declare WorkString     string    local
        /declare CondNo         int       local
        
        /if (${Bool[${Me.AltAbility[Companion's Discipline].Rank}]}) {
            /if (${Me.AltAbility[Companion's Discipline]}>5) /varset PetFocusOn 1
        }
        | Compensate for Eyes Wide open AA and Extended Target Window
        /if (${Ini[${IniFileName},General,XTSlot].Length}) {
            /varset XTSlot ${Ini[${IniFileName},General,XTSlot]}
            /if (${XTSlot}) /xtarget set ${XTSlot} autohater
            /ini "${IniFileName}" "General" "XTSlot" "0"
            /while (${Me.XTarget[${XTSlot}].TargetType.NotEqual[Auto Hater]}) {
               /delay 5
            }
            /varset XTSlot 0
        }
        /for n 1 to ${XSlotTotal}
            /if (${Me.XTarget[${n}].TargetType.Equal[Auto Hater]}) {
                /if (${XTSlot} && !${XTSlot2}) /varset XTSlot2 ${n}
                /if (${XTSlot}==0) {
                    /varset XTSlot ${n}
                    /ini "${IniFileName}" "General" "XTSlot" "${XTSlot}"
                }
            }
        /next n
        |  Added extra slot check and Error Message
        /if (${XTSlot}==0 || ${ChainPull} && !${XTSlot2}) {
            /echo You need more slots in your Extended Target Window set to Auto.
            /if (${ChainPull}) {
                /echo Please set at least 2 slots to Auto for Chain Pulling and restart KissAssist.
            } else {
                /echo Please set at least 1 slot to Auto and restart KissAssist.
            }
            /endmacro
        }
        | Changed Logic for populating AggroTargetID. This change will include mobs in camp not on XTarget.
        /noparse /varset AggroTargetID ${If[${Me.XTarget[${XTSlot}].ID},${Me.XTarget[${XTSlot}].ID},${If[${AggroTargetID2},${AggroTargetID2},0]}]}
        | Look at removing the AggroTargetID2 code if the change below works.
        | It did NOT work. Will have to update the pull code NOT to use MyTargetID and start using PullMob.
        /noparse /varset PullAggroTargetID ${If[${ChainPull}==0,${Me.XTarget[${XTSlot}].ID},${If[${Me.XTarget[${XTSlot}].ID} && (${Me.XTarget[${XTSlot}].ID}==${MyTargetID} || ${Me.XTarget[${XTSlot}].ID}!=${BeginMobID} || ${Me.XTarget[${XTSlot2}].ID}),${MyTargetID},0]}]}

        /if (${Select[${Me.Class.ShortName},BST,BRD,CLR,DRU,ENC,MAG,NEC,PAL,RNG,SHM,SHD,WIZ]}) /varset MedStat Mana
        /if (${Select[${Me.Class.ShortName},BER,MNK,ROG,WAR]}) /varset MedStat Endurance
        
        /if (${PullLevel.Find[auto]}) {
           /varcalc PullMin ${Me.Level}-5
           /varcalc PullMax ${Me.Level}+2
           /varset PullLevel auto
        } else /if (${PullLevel.Equal[0|0]} || ${PullLevel.Equal[0]} || ${PullLevel.Equal[null]} || !${PullLevel.Find[|]}) {
           /varset PullMin 1
           /varset PullMax 200
           /varset PullLevel off
        } else /if (${PullLevel.Find[linked]}) {
           /varset PullMin ${Int[${PullLevel.Arg[1,|]}]}
           /varset PullMax ${Int[${PullLevel.Arg[2,|]}]}
           /varset PullLevel linked
        } else {
           /varset PullMin ${Int[${PullLevel.Arg[1,|]}]}
           /varset PullMax ${Int[${PullLevel.Arg[2,|]}]}
           /varset PullLevel fixed
        }
        /if (${PullMin}>${PullMax} || ${PullMin}==0 || ${PullMax}==0) {
           /echo Invalid Pull Level Settings resetting to default.
           /varset PullMin 1
           /varset PullMax 200
           /varset PullLevel off
        }
        /if (${PullArcWidth}>359) /varset PullArcWidth 0
        /if (${Select[${Role},puller,pullertank,pullerpettank,hunter,hunterpettank]}) {
            /if (${PullWith.Find[|]} && ${PullWith.Arg[2,|].Length}) {
                /if (!${FindItemCount[=${PullWith.Arg[2,|]}]}) {
                    /varset WorkString ${PullWith.Arg[2,|]}
                    /for n 1 to ${Buffs.Size}
                        /if (${Buffs[${n}].Arg[2,|].Equal[summon]} && ${Buffs[${n}].Arg[3,|].Equal[${WorkString}]}) {
                            /if (${ConOn} && ${Buffs[${n}].Find[|cond]}) {
                                /varset CondNo ${Buffs[${n}].Mid[${Math.Calc[${Buffs[${n}].Find[|cond]}+5]},3]}
                            } else {
                                /varset CondNo 0
                            }
                            /call SummonStuff "${Buffs[${n}].Arg[1,|]}" "${WorkString}" 1 ${CondNo}
                            /if (${FindItemCount[=${PullWith.Arg[2,|]}]}) /break
                        }
                    /next n
                    /if (!${FindItemCount[${PullWith.Arg[2,|]}]}) {
                        /echo You have NO Ammo to pull with and I wasn't able to summon any.
                    }
                }
            }
            /if (${PullWith.Length} && ${PullWith.NotEqual[null]}) /call PullRangeSet
        }
        /if (${g_ExtendedBuffList.Length} && ${g_ExtendedBuffList.NotEqual[null]}) {
            /echo Recovering Extended Buff List.
            /varset ExtendedBuffList ${g_ExtendedBuffList}
        }
        /moveto set alwaysUW off
        /if (${Me.Skill[swimming]}) {
            /if (${Me.Skill[swimming]}<200) {
                /varset LocDelayCheckUW 40
            } else {
                /varset LocDelayCheckUW 20
            }
        } else {
            /varset LocDelayCheckUW 40
        }
        /if (!${Me.HaveExpansion[seeds of destruction]}) /varset MercOn 0
    /return
| ----------------------------------------------------------------------------
| SUB: InitPlugins
| ----------------------------------------------------------------------------
    Sub InitPlugins
        /declare PeersZone string local
        /call CheckPlugin MQ2Exchange
        /call CheckPlugin MQ2Moveutils
        /call CheckPlugin MQ2Posse
        /call CheckPlugin MQ2Rez
        /if (${IAmABard}) /call CheckPlugin MQ2Twist 1
        /if (!${IAmABard} && !${Bool[${Plugin[mq2twist]}]}) /declare Twist int outer 0
        /if (${UseMQ2Melee}) {
            /call CheckPlugin MQ2Melee
            /if (${Bool[${Plugin[mq2melee]}]}) {
            |  Turn aggro mode off and turn on melee mode in MQ2Melee
                /squelch /melee aggro=0
                /squelch /melee melee=1
                /squelch /melee petassist=0
                /squelch /melee on
                |stickmode: 0=MQ2Melee Auto mode, 1=Use custom StickCmd from MQ2Melee ini settings,2=Turn stick off. No /Sticking.
                /if (${UseMQ2Melee}==1) {
                    /squelch /melee stickmode=0
                } else {
                    /squelch /melee stickmode=1
                }
                /varset StickHow 0
            } else {
                /echo MQ2Melee plugin did NOT load. Setting UseMQ2Melee off.
                /varset UseMQ2Melee 0
                /if (${StickHow.Equal[0]}) /varset StickHow auto
            }
        } else {
            /if (${Bool[${Plugin[mq2melee]}]}) {
                /plugin mq2melee unload noauto
                /varset MQ2MeleeReload 1
            }
            /if (${StickHow.Equal[0]}) /varset StickHow auto
        }
        /if (${Bool[${Plugin[mq2cast]}]} && !${UseMQ2Melee}) {
            /plugin mq2cast unload noauto
            /varset MQ2CastReload 1
        }
        /varset DStickHow ${StickHow}
        /if (${EQBCOn} && !${Macro.IsTLO[EQBC]}) /plugin mq2eqbc noauto
        /if (${DanNetOn}) {
            /if (!${Macro.IsTLO[DanNet]}) {
                /call CheckPlugin mq2dannet 1
            }
            /if (${Zone.ShortName.Find[_]}) {
                /varset PeersZone zone_${Zone.ShortName}
            } else {
                /varset PeersZone zone_${EverQuest.Server.Lower}_${Zone.ShortName}
            }
            /dnet fullnames off
            /echo I see ${DanNet.PeerCount} clients connected to DanNet and ${DanNet.PeerCount[${PeersZone}]} clients in same Zone.
        }
        | Set MQ2moveutils variables
        /stick set autosave off
        /stick set verbflags 0
        /stick set breakonkb on
        /stick set breakonmouse off
        /stick set breakdist ${CampRadiusExceed}
        /stick set breakonwarp on
        /stick set usefleeing on
        /stick set delaystrafe on
        /stick set feign on
        | Set up MQ2rez if RezAcceptOn=1
        | Use new Rez TLO to capture current settings and restore when exiting macro.
        /if (${RezAcceptOn.Arg[1,|].Equal[1]}) {
            /if (!${Bool[${Plugin[mq2rez]}]}) {
                /plugin mq2rez
                /delay 5
            }
            /squelch /rez accept on
            /squelch /rez loot off
            /if (${Int[${RezAcceptOn.Arg[2,|]}]}>0) /rez pct ${Int[${RezAcceptOn.Arg[2,|]}]}
        } else {
            /squelch /rez accept off
        }
        /if (${Macro.IsTLO[Posse]}) {
            /if (${Select[${AFKToolsOn},1,2]}) {
                /posse radius ${AFKPCRadius}
                /posse friendnotify off
                /posse strangernotify on
                /if (!${Posse.Status})  {
                    /posse on
                    /posse load
                }
            }
        } else {
            /varset AFKToolsOn 0
        }
        /if (${DPSMeter}) {
            /call CheckPlugin MQ2DPSAdv 1
            /if (!${Macro.IsTLO[DPSAdv]}) {
                /echo DPSAdv TLO not found. Turning off DPS meter. 
                /varset DPSMeter 0
            }
        }
        /if (${Bool[${Plugin[mq2log]}]}) {
            /varset DebugLogging ${Int[${Ini["..\${EverQuest.Server}_${Me.CleanName}.ini",MQ2Log,Enabled]}]}
        }
    /return
| ----------------------------------------------------------------------------
| SUB: StartupCredits
| ----------------------------------------------------------------------------
    Sub StartupCredits
        /echo ================================
        /echo Redguides presents
        /echo ${MacroName} Created by Maskoi
        /echo ${MacroName} v.${MacroVer}.${KissRevision}
        /echo Maintained for RedGuides by Ctaylor22
        /echo ================================
        /if (${EQBCOn} && ${DanNetOn}) {
            /echo Using EQBC for Messaging and DanNet for Everything Else.
        } else /if (${EQBCOn}) {
            /echo Using EQBC for Messaging.
        } else /if (${DanNetOn}) {
            /echo Using DanNet for Everything.
        } else {
            /echo NOT using EQBC or DanNet.
        }
        /echo ================================
        /if (${Select[${Role},tank]}) {
            /if (${IAmMA}) {
                /echo I am Tanking & Main Assist
            }
        } else /if (${Select[${Role},puller]}) {
            /echo I am Puller. KissAssisting >> ${MainAssist} << at ${AssistAt}%
            /if (${ChainPull}) /echo  What? I have to chain pull now.
        } else /if (${Select[${Role},pullertank]}) {
            /echo I am Puller & Tank.
        | PetTank set role
        } else /if (${Select[${Role},pettank]}) {
            /echo My Pet >> ${Me.Pet.CleanName} << is Tanking & KissAssisting >> ${MainAssist} <<
        | PullerPetTank set role
        } else /if (${Select[${Role},pullerpettank]}) {
            /echo I am Pulling & my Pet >> ${Me.Pet.CleanName} << is Tanking.
            /echo We are all doomed.
            /delay 10
            /echo DOOMED!
        | HunterPetTank set role
        } else /if (${Select[${Role},hunterpettank]}) {
            /echo I am Hunting & my Pet >> ${Me.Pet.CleanName} << is Tanking.
        } else /if (${Select[${Role},hunter]}) {
            /echo I am Hunting.
        } else /if (${Select[${Role},offtank]}) {
            /echo I am Off Tanking. KissAssisting >> ${MainAssist} << at ${AssistAt}%
        } else {
            /echo KissAssisting >> ${MainAssist} << at ${AssistAt}%
            /echo ${MainAssist} is a ${MainAssistType} ${Spawn[=${MainAssist}].Class}
        }
        /if (${Role.Find[Puller]} && ${Float[${PullArcWidth}]}>0) {
            /call SetPullAngles ${Me.Heading.Degrees} ${Float[${PullArcWidth}]} 1
            /echo Pulling an Area starting from the Left at ${PullLSide} degrees ending at ${PullRSide} degrees.
        }
        /squelch /target clear
        /squelch /assist off
        /if (${Role.Find[pull]} || ${Role.Find[hunt]}) {
            /if (${PullPathWpCount} && ${PullMoveUse.Equal[advpath]}) {
                /call BroadCast r "PULL: Path >> ${PullPath} <<  found with ${PullPathWpCount} waypoints."
                /call BroadCast r "PULL: Using MQ2AdvPath to Pull with."
            } else /if (${Bool[${Plugin[MQ2Nav]}]}) {
                /if (${Navigation.MeshLoaded}) {
                    | Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
                    /varset PullMoveUse nav
                    /call BroadCast r "PULL: The MQ2Nav mesh for ${Zone} is loaded"
                    /call BroadCast r "PULL: Using MQ2Nav to Pull with ${PullWith}"
                } else {
                    /varset PullMoveUse los
                    /call BroadCast r "PULL: Using Line of Sight to Pull with ${PullWith}"
                }
            } else {
                /varset PullMoveUse los
                /call BroadCast r "PULL: Using Line of Sight to Pull with ${PullWith}"
            }
        } else {
            /if (${Bool[${Plugin[MQ2Nav]}]}) {
                /if (${Navigation.MeshLoaded}) {
                    | Set pullmoveuse to nav if mq2nav is detected without a mq2advpath path
                    /varset PullMoveUse nav
                    /echo The MQ2Nav mesh for ${Zone} is loaded
                    /echo Using MQ2Nav to Move.
                } else {
                    /varset PullMoveUse los
                }
            } else {
                /varset PullMoveUse los
                /echo Using MoveUtil to move with.
            }
        }
        /if (${Select[${PullMoveUse},los,nav]}>=1) /varset UseWayPointZ 0
    /return
| ----------------------------------------------------------------------------
| SUB: Startup Miscelanious Stuff
| ----------------------------------------------------------------------------
    Sub StartupMisc
        /declare s_Temp1 string local ${Ini[${IniFileName},Spells,Gem1,BLANK]}
        /declare i_x int local 0
        | If I am group leader set Main Assist Tag for Group Check for pet and make master MainAssist
        /if (${Select[${Me},${Group.Leader}]}) {
            /if (${Spawn[group ${MainAssist}].ID} || (${Spawn[${MainAssist}].Type.Equal[pet]} && ${Spawn[group ${Spawn[${MainAssist}].Master.CleanName}].ID})) {
                | If Main Assist is someone else than who its suppose to be unset Group tag
                /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
                    /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
                }
                /if (!${Group.MainAssist.Name.Length}) {
                    /if (${Spawn[${MainAssist}].Type.Equal[pet]}) {
                        /call BroadCast r "Assigning ${Spawn[${MainAssist}].Master.CleanName} as Main Assist in Group Window"
                        /call AssignGroupRole set "${Spawn[${MainAssist}].Master.CleanName}" 2
                    } else {
                        /call BroadCast r "Assigning ${MainAssist} as Main Assist in Group Window"
                        /call AssignGroupRole set "${MainAssist}" 2
                    }
                }
            } else /if (${Group.MainAssist.Name.Length} && ${Group.MainAssist.Name.NotEqual[${MainAssist}]}) {
                /call AssignGroupRole unset "${Group.MainAssist.Name}" 2
            }
        }
        /if (${LoadSpellSet}) /call LoadSpellSet
        /if (${s_Temp1.Equal[blank]}) /call Bind_WriteMySpells 1
    /return
| ----------------------------------------------------------------------------
| SUB: LoadAliases
| ----------------------------------------------------------------------------
    Sub LoadAliases
    | ************************* Aliases **************************************|
        DEBUGN Ini/Alias info ${KissAssistVer.NotEqual[${MacroVer}]} "${KissAssistVer}" "${MacroVer}"
        /if (${KissAssistVer.NotEqual[${MacroVer}]} || ${ForceAlias}) {
            /if (${ForceAlias}) {
                /echo Resetting Aliases this can take up to 1 min
            } else {
                /echo Version Mismatch Detected, Resetting Aliases this can take up to 1 min
            }
            /squelch /alias /afktoolson     /changevarint AFKTools AFKToolsOn
            /squelch /alias /assistat       /changevarint Melee AssistAt
            /squelch /alias /autofireon     /togglevariable AutoFireOn
            /squelch /alias /autorezon      /togglevariable AutoRezOn
            /squelch /alias /buffson        /togglevariable BuffsOn
            /squelch /alias /camphere       /togglevariable ReturnToCamp
            /squelch /alias /campradius     /changevarint General CampRadius
            /squelch /alias /chase          /togglevariable ChaseAssist
            /squelch /alias /chasedistance  /changevarint General ChaseDistance
            /squelch /alias /chaseoff       /changevarint General ChaseAssist 0
            /squelch /alias /chaseon        /changevarint General ChaseAssist 1
            /squelch /alias /debugall       /debug all on log
            /squelch /alias /dpsinterval    /changevarint DPS DPSInterval
            /squelch /alias /dpsmeter       /togglevariable DPSMeter
            /squelch /alias /dpson          /changevarint DPS DPSOn
            /squelch /alias /dpsskip        /changevarint DPS DPSSkip
            /squelch /alias /dpsspam        /togglevariable DPSSpam
            /squelch /alias /dpswrite       /togglevariable DPSWriteOn
            /squelch /alias /healson        /changevarint Heals HealsOn
            /squelch /alias /interrupton    /togglevariable CastingInterruptOn
            /squelch /alias /ktdismount     /echo KTDismount
            /squelch /alias /ktdoor         /echo KTDoorClick
            /squelch /alias /kthail         /echo KTHail
            /squelch /alias /ktinvite       /echo KTInvite
            /squelch /alias /ktsay          /echo KTSay
            /squelch /alias /kttarget       /echo KTTarget
            /squelch /alias /looton         /changevarint General LootOn
            /squelch /alias /maxradius      /changevarint Pull MaxRadius
            /squelch /alias /maxzrange      /changevarint Pull MaxZRange
            /squelch /alias /medcombat      /togglevariable MedCombat
            /squelch /alias /medstart       /changevarint General MedStart
            /squelch /alias /meleedistance  /changevarint Melee MeleeDistance
            /squelch /alias /meleeon        /togglevariable MeleeOn
            /squelch /alias /mercassistat   /changevarint Merc MercAssistAt
            /squelch /alias /mezon          /changevarint Mez MezOn
            /squelch /alias /movewhenhit    /togglevariable MoveWhenHit
            /squelch /alias /pethold        /togglevariable PetHold
            /squelch /alias /peton          /togglevariable PetOn
            /squelch /alias /pettoyson      /togglevariable PetToysOn
            /squelch /alias /pettoysplz     /echo PetToysPlease
            /squelch /alias /rebuffon       /togglevariable RebuffOn
            /squelch /alias /returntocamp   /togglevariable ReturnToCamp
            /squelch /alias /rezallon       /togglevariable AutoRezAll 1
            /squelch /alias /rezalloff      /togglevariable AutoRezAll 0
            /squelch /alias /scatteron      /togglevariable ScatterOn
            /squelch /alias /setae          /iniwrite AE
            /squelch /alias /setaggro       /iniwrite Aggro
            /squelch /alias /setbackoff     /backoff
            /squelch /alias /setbuffs       /iniwrite Buffs
            /squelch /alias /setburn        /iniwrite Burn
            /squelch /alias /setcure        /iniwrite Cure
            /squelch /alias /setdps         /iniwrite DPS
            /squelch /alias /setheals       /iniwrite Heals
            /squelch /alias /katwistpause   /togglevariable TwistHold 1
            /squelch /alias /katwistresume  /togglevariable TwistHold 0
            /squelch /alias /switchma       /switchma
            /squelch /alias /waithere       /togglevariable waithere
            /squelch /alias /trackme        /trackmedown
            /squelch /alias /debug delete
            /squelch /alias /debugbuffs delete
            /squelch /alias /debugcombat delete
            /squelch /alias /debugcast delete
            /squelch /alias /debugchainpull delete
            /squelch /alias /debugheal delete
            /squelch /alias /debugmez delete
            /squelch /alias /debugmove delete 
            /squelch /alias /debugpull delete
            /squelch /alias /debugrk delete
            /squelch /alias /dpsspam delete
            /ini "${IniFileName}" "General" "KissAssistVer" "${MacroVer}"
        }
        DEBUGN Aliases processed
    /return
| ----------------------------------------------------------------------------
| SUB: DeclareOuters
| ----------------------------------------------------------------------------
    Sub DeclareOuters(string declareFlag)
        | Do Not Edit These *****************************************************|
        /if (${declareFlag.Equal[pre]}) {
            /declare BroadCastSay           string      outer       bc
            /declare CampXLoc               int         outer       ${Me.X}
            /declare CampYLoc               int         outer       ${Me.Y}
            /declare CampZLoc               int         outer       ${Me.Z}
            /declare CampZone               int         outer       ${Zone.ID}
            /declare Debug                  int         outer       0
            /declare DebugAllOn             int         outer       0
            /declare DebugBuffs             int         outer       0
            /declare DebugCast              int         outer       0
            /declare DebugChainP            int         outer       0
            /declare DebugCombat            int         outer       0
            /declare DebugHeals             int         outer       0
            /declare DebugMez               int         outer       0
            /declare DebugMove              int         outer       0
            /declare DebugPet               int         outer       0
            /declare DebugPull              int         outer       0
            /declare DebugRK                int         outer       0
            /declare DebugTime              int         outer       0
            /declare DebugLogging           int         outer       0
            /declare ForceAlias             int         outer       1
            /declare GoMTimer               timer       outer       0
            /declare GroupWatchPct          int         outer       20
            /declare IAmABard               bool        outer       ${Me.Class.Name.Equal[Bard]}
            /declare IniFileName            string      outer
            /declare KissAssistVer          string      outer
            /declare KissRevision           string      outer       024
            /declare LookForward            int         outer       ${Me.Heading.DegreesCCW}
            /declare LoadFromINI            int         outer       0
            /declare MacroName              string      outer       KissAssist
            /declare BuffFileName           string      outer       ${MacroName}_Buffs.ini
            /declare InfoFileName           string      outer       ${MacroName}_Info.ini
            /declare MacroVer               string      outer       12.002
            /declare Parse0                 bool        outer       TRUE
            /declare PIniSet                int         outer       0
            /declare ZoneName               string      outer       ${Zone}
        } else /if (${declareFlag.Equal[main]}) {
            /declare AddSpam                timer       outer       0
            |/declare AddsArray[50,3]        string      outer       NULL
            /declare AdvpathPointNum        int         outer       0
            /declare AdvpathPointX          float       outer       0
            /declare AdvpathPointY          float       outer       0
            /declare AdvpathPointZ          float       outer       0
            /declare AEDisplayMobInfo       int         outer       0
            /declare AggroOffTimer          timer       outer       0
            /declare AggroTargetID          string      outer
            /declare AggroTargetID2         string      outer       0
            /declare AmmoSwitch             int         outer       0
            /declare Attacking              int         outer       0
            /declare AutoRezAll             int         outer       0
            /declare BagNum                 int         outer       0
            /declare BagNumLast             int         outer       0
            /declare BeforeArray[5]         string      outer       null
            /declare BeginMobID             string      outer
            /declare Banestrike             string      outer
            /declare BardStartTwist         int         outer       0
            /declare BardWasTwisting        string      outer       null
            /declare BindActive             int         outer       0
            /declare BurnActive             int         outer       0
            /declare BurnCalled             int         outer       0
            /declare BurnOn                 int         outer       1
            /declare BurnID                 int         outer       0
            /declare BlockedBuffsCount      int         outer       0
            /declare CalledTargetID         int         outer       0
            |/declare CalmCount              int         outer       0 
            /declare CampOnDeathTimer       timer       outer       0
            /declare CampfireClickTimer     timer       outer       0
            /declare CampfireTimer          timer       outer       0
            /declare CantHit                int         outer       0
            /declare CantSee                int         outer       0
            /declare CastResult             string      outer
            /declare castReturn             string      outer       CAST_CANCELLED
            /declare CheckResisted          int         outer       0
            /declare ChainPullTemp          string      outer
            /declare CheckOnReturn          int         outer       0
            /declare CleanBuffsTimer        timer       outer       0
            /declare ClearSpawnValue        spawn       outer
            /declare ColorIdx               int         outer       0
            /declare ColorList              string      outer       tWgtuwyr
            /declare CombatStart            int         outer       0
            /declare ConColor               string      outer       t
            /declare CorpseRezCheck         string      outer       null
            /declare CursorID               int         outer       0
            /declare CursorIDCount          int         outer       0
            /declare CursorIDTimer          timer       outer       0
            /declare DebuffCount            int         outer       0
            /declare DebugTicker            timer       outer       0
            /declare DMZ                    int         outer       ${Select[${Zone.ID},345,344,202,203,279,151,33506]}
            /declare DNout                  string      outer       null
            /declare DontMoveMe             int         outer       0
            /declare DPSPaused              int         outer       0
            /declare DPSSpam                int         outer       0
            /declare DPSTarget              int         outer       0
            /declare DPSTwisting            int         outer       0
            /declare DPSWriteOn             int         outer       0
            /declare DragCorpse             int         outer       0
            /declare DStickHow              string      outer       0
            /declare DurationMod            float       outer       1
            /declare EventByPass            int         outer       0
            /declare EventFlag              int         outer       0
            /declare EventTimer             timer       outer       0
            /declare EngageWaitTimer        timer       outer       0
            /declare ExtendedBuffList       string      outer
            /declare FailCounter            int         outer       0
            /declare FailMax                int         outer       3
            /declare ForceBuffs             int         outer       0
            /declare GemSlots               int         outer       8
            /declare GMailEvents            string      outer
            /declare GSent                  int         outer       0
            /declare GoMActive              int         outer       0
            /declare GoMByPass              int         outer       0
            /declare GotHitToggle           int         outer       0
            /declare GlobalIndex            int         outer       0
            /declare HasBuffDuration        int         outer       0
            /declare HealAgain              int         outer       0
            /declare HealRemChk1            string      outer       Divine Barrier
            /declare HealRemChk2            string      outer       Touch of the Divine
            /declare HealRemChk3            string      outer       null
            /declare IAMCastingID           int         outer       0
            /declare IAmDead                int         outer       0
            /declare IAmMA                  int         outer       0
            /declare IniNextTimer           timer       outer       0
            /declare ItemsGiven             int         outer       0
            /declare JoinedParty            timer       outer       0
            /declare JustZoned              timer       outer       0
            /declare KABegActive            int         outer       0
            /declare KAPetBegActive         int         outer       0
            /declare KABegForList           string      outer
            /declare KABegForPetList        string      outer
            /declare LastDPSCast            string      outer
            /declare LastHealCheck          timer       outer       0
            /declare LastMobPullID          int         outer       0
            /declare LastResisted           int         outer
            /declare LastTargetID           int         outer
            /declare LastZone               int         outer       ${Zone.ID}
            /declare LocDelayCheckUW        int         outer       0
            /declare LooterAssigned         int         outer       0
            /declare MacroReturn            string      outer
            /declare MASitTime              timer       outer       0
            /declare MainAssist             string      outer
            /declare MainAssistClass        string      outer
            /declare MainAssistType         string      outer
            /declare MapSet                 int         outer       0
            /declare MashArray[10]          string      outer       null
            /declare MedStat                string      outer
            /declare MedStat2               string      outer       Endurance
            /declare Medding                int         outer       0
            /declare MeddingInterrupted     int         outer       0
            /declare MercAssisting          int         outer       0
            /declare MercInGroup            int         outer       0
            /declare MezAETimer             timer       outer       0
            /declare MezArray[50,3]         string      outer       NULL
            /declare MezBroke               int         outer       0
            /declare MezImmuneIDs           string      outer
            /declare MezMobAECount          int         outer       0
            /declare MezMobCount            int         outer       0
            /declare MezMobDone             int         outer       0
            /declare MezMobFlag             int         outer       0
            /declare MissingComponent       int         outer       0
            /declare MobCount               int         outer       0
            /declare MobFlag                int         outer       1
            /declare MobsToIgnoreByID       string      outer       null
            /declare MountOn                int         outer       1
            /declare MQ2MeleeReload         int         outer       0
            /declare MQ2CastReload          int         outer       0
            /declare MyAAExp                float       outer       ${Me.PctAAExp}
            /declare MyExp                  float       outer       ${Me.PctExp}
            /declare MyMerc                 string      outer       0
            /declare MyOriginalRole         string      outer
            /declare MyTargetID             int         outer       0
            /declare MyTargetName           string      outer       0
            /declare NamedCheck             int         outer       0
            /declare NeedCuring             int         outer       0
            /declare OrigRanged             string      outer       ${Me.Inventory[ranged].Name}
            /declare ParseDPSTimer          int         outer       0
            /declare PetActiveState         int         outer       0
            /declare PetAttack              timer       outer       0
            /declare PetAttackRange         int         outer       0
            /declare PetBuffCheck           timer       outer       0
            /declare PetFocusOn             int         outer       0
            /declare PetFollowTimer         timer       outer       60s
            /declare PetSuspendState        int         outer       0
            /declare PetTanking             int         outer       0
            |/declare PetTauntOn             int         outer       0
            /declare PetTotCount            int         outer       0
            /declare PetToyList             string      outer        
            /declare PullAggroTargetID      string      outer
            /declare PullAlertTimer         timer       outer       0
            /declare PullAmmo               string      outer       NULL
            /declare Pulled                 int         outer       0
            /declare PullHeading            float       outer       0
            /declare PullLSide              float       outer       0
            /declare PullRSide              float       outer       0
            /declare PullHold               int         outer       0
            /declare PullHoldCond           string      outer       0
            /declare PullIgnore1            string      outer       NULL
            /declare PullIgnore2            string      outer       NULL
            /declare PullIgnore3            string      outer       NULL
            /declare Pulling                int         outer       0
            /declare PullItem               string      outer       NULL
            /declare PullMax                int         outer       0
            /declare PullMaxCount           int         outer       500
            /declare PullMin                int         outer       0
            /declare PullMob                int         outer       0
            /declare PullMoveUse            string      outer
            /declare PullNavDistance        int         outer       0
            /declare PullPathArrayX[999]    float       outer
            /declare PullPathArrayY[999]    float       outer
            /declare PullPathArrayZ[999]    float       outer
            /declare PullPathWpCount        int         outer       0
            /declare PullSearchIter         int         outer       1
            /declare PullRange              int         outer       0
            /declare PullTimer              timer       outer       0
            /declare PullTooFar             int         outer       0
            /declare PullWithAlt            string      outer       Melee
            /declare PullWaitTimer1         timer       outer       0
            /declare PullWaitTimer2         timer       outer       0
            /declare PullWaitRemaining      int         outer       0
            /declare PullXPCheck            int         outer       1
            /declare p_AssistAt             int         outer       0
            /declare p_PullPath             string      outer       null
            /declare p_Role                 string      outer       null
            /declare RangedSwitch           int         outer       0
            /declare ReMemCast              int         outer       0
            /declare ReMemCastLW            int         outer       0
            /declare ReMemWaitLong          string      outer       null
            /declare ReMemWaitShort         string      outer       null
            /declare ReadBuffsTimer         timer       outer       0
            /declare Redguides              int         outer       1
            /declare RememberCamp           int         outer       0
            /declare SearchType             string      outer
            /declare SHealPct               int         outer
            /declare SingleHealPoint        int         outer       0
            /declare SingleHealPointMA      int         outer       0
            /declare SingleHealPointRange   int         outer       0
            /declare SitToMedTimer          timer       outer       6s
            /declare SpamTimer              timer       outer       0
            /declare SpamTimer1             timer       outer       0
            /declare SpamTimer2             timer       outer       0
            /declare SpamTimer3             timer       outer       0
            /declare SpellReadyL            int         outer       0
            /declare StayPut                int         outer       0
            /declare StickDist              int         outer       13
            /declare StickDistUW            int         outer       10
            /declare TankTimer              timer       outer       0
            /declare TempAmmo               string      outer       ${Me.Inventory[ammo].Name}
            /declare TempMaxRadius          int         outer       0
            /declare ToClose                int         outer       0
            /declare TributeTimer           timer       outer       0
            /declare Twisting               int         outer       0
            /declare TwistHold              int         outer       0
            /declare ValidTarget            int         outer       0
            /declare WasTwisting            bool        outer       FALSE
            /declare WaitTimer              timer       outer       0
            /declare WeaveArray[50]         string      outer       null
            /declare WhoToChase             string      outer
            /declare WorkSpawn              spawn       outer
            /declare WriteBuffsMercTimer    timer       outer       0
            /declare WriteBuffsPetTimer     timer       outer       0
            /declare WriteBuffsTimer        timer       outer       0
            /declare XSlotTotal             int         outer       20
            /declare XTSlot                 int         outer       0
            /declare XTSlot2                int         outer       0
            /declare XTarAutoSet            int         outer       1
            /declare XTarToHeal[20]         int         outer       0
            /declare ZDist                  float       outer       0
        } else /if (${declareFlag.Equal[post]}) {
            /declare ReMemMiscSpell         string      outer       ${Me.Gem[${MiscGem}].Name}
            /declare ReMemMiscSpellLW       string      outer       ${Me.Gem[${MiscGemLW}].Name}
            /declare WayPointZRange         int         outer       ${MaxZRange}
        } else /if (${declareFlag.Equal[global]}) {
            /if (!${Defined[k_globals]}) {
                /declare k_globals          int         global      2
                /declare g_PetToysGave      string      global
                /declare g_ExtendedBuffList string      global
            } else /if (${k_globals}==1) {
                /declare g_ExtendedBuffList string      global
                /varset k_globals 2
            }
        }
    DEBUGN Misc Declares Processed
    /return
| -------------------------------------------------------------------------------------
| SUB: PParse Parse passed command line parameters
| -------------------------------------------------------------------------------------
    Sub PParse(int iniLoaded, int nump)
        DEBUGN PParse: iniLoaded: ${iniLoaded} NumP: ${nump}
        /declare i int local 0
        /declare j int local 0
        /declare k int local 0
        /declare pMaxRadius int local 0
        /declare TempPathX float local 0
        /declare TempPathY float local 0
        /declare TempPathZ float local 0
        /declare ipa int local 0
        /declare ipb int local 0
        /declare numc int local ${Math.Calc[${nump}-1]}
        /if (!${nump}) /return
        | Command Line Passed Parameterss start with the number 0. 0 is the first param and is counted as 1 param even though the loop is 0 to 0.
        /for i 0 to ${numc}
            DEBUGN PParse: ${i}. ${Defined[PParam${i}]} P${i}: ${PParam${i}}
            /if (${Defined[PParam${i}]}) {
                | ipa increases the param counter by 1 so we can assign the variable after the current parma.
                | /mac kissassist assist ma bob - if Param1 is ma for mainassist the next param is bob
                /varcalc ipa ${i}+1
                /if (${i}>0) /varcalc ipb ${i}-1
                /if (${Select[${PParam${i}},debug,debugall]}) /continue
                /if (!${iniLoaded}) {
                    /if (${PParam${i}.Equal[ini]}) {
                        /varset IniFileName ${PParam${ipa}}
                        /echo Ini file has been set to >> ${PParam${ipa}} <<
                        /varset PIniSet 1
                    } else /if (${PParam${i}.Equal[forcealias]}) {
                        /varset ForceAlias 1
                    }
                } else {
                    /if (${PParam${i}.Equal[ini]}) {
                        /varcalc i ${i}+1
                        /continue
                    } else /if (${Select[${PParam${i}},debug,debugall,forcealias]}) {
                        /continue
                    } else /if (${Select[${PParam${i}},assist,manual,petassist,tank,pettank,puller,pullertank,pullerpettank,hunter,hunterpettank,offtank]}) {
                        /varset p_Role ${PParam${i}}
                    } else /if (${PParam${i}.Equal[ma]}) {
                        /if (${Defined[PParam${ipa}]}) {
                            /varset MainAssist ${PParam${ipa}}
                            /varcalc i ${i}+1
                        } else {
                            /varset MainAssist
                            /break
                        }
                    } else /if (${PParam${i}.Equal[assistat]}) {
                        /if (${Defined[PParam${ipa}]}) {
                            /varset p_AssistAt ${PParam${ipa}}
                            /varcalc i ${i}+1
                        } else {
                            /varset p_AssistAt 95
                        }
                        /continue
                    } else /if (${PParam${i}.Equal[parse]}) {
                        /if (${Defined[PParam${ipa}]}) {
                            /varset ParseDPSTimer ${PParam${ipa}}
                            /varcalc i ${i}+1
                        } else {
                            /varset ParseDPSTimer 60
                        }
                        /continue
                    } else /if (${PParam${i}.Equal[scanini]}) {
                        /ini "KissAssist_Buffs.ini" ${Me.ID} Zone NULL
                    } else /if (${PParam${i}.Equal[autoload]}) {
                        /varset LoadFromINI 1
                    } else /if (${PParam${i}.Equal[path]}) {
                        /if (!${Defined[PParam${ipa}]}) {
                            /echo Please provide a Path name when using the Path paramater.
                            /varset PullMoveUse
                            /varset PullPathWpCount 0
                        } else {
                            /call CheckPlugin MQ2AdvPath
                            /if (${Bool[${Plugin[MQ2AdvPath]}]}) {
                                /delay 20 ${AdvPath.Active}
                                | Play path on pause to load info . Only way we can grab info from advpath
                                /if (${AdvPath.PathList[${PParam${ipa}}]}) {
                                    /play ${PParam${ipa}} pause
                                    /varset p_PullPath ${PParam${ipa}}
                                    /delay 10
                                    | Set PullPathWpCount with total amount of waypoints in path
                                    /varset PullPathWpCount ${AdvPath.Waypoints}
                                    | Load path points into array
                                    /for k 1 to ${PullPathWpCount}
                                        DEBUGN PParse WP#: ${Int[${Math.Calc[${k}-1]}]}-${k} Distance Between: ${Math.Distance[${TempPathY},${TempPathX}:${AdvPath.Y[${k}]},${AdvPath.X[${k}]}]}
                                        /varset PullPathArrayX[${k}] ${AdvPath.X[${k}]}
                                        /varset PullPathArrayY[${k}] ${AdvPath.Y[${k}]}
                                        /varset PullPathArrayZ[${k}] ${AdvPath.Z[${k}]}
                                        /varset TempPathX ${PullPathArrayX[${k}]}
                                        /varset TempPathY ${PullPathArrayY[${k}]}
                                        /varset TempMaxRadius ${Math.Distance[${CampYLoc},${CampXLoc}:${PullPathArrayY[${k}]},${PullPathArrayX[${k}]}]}
                                        /if (${TempMaxRadius}>${pMaxRadius}) /varset pMaxRadius ${TempMaxRadius}
                                        DEBUGN PParse: WP: ${k} WPX: ${PullPathArrayX[${k}]} WPY: ${PullPathArrayY[${k}]}
                                    /next k
                                    /varset TempMaxRadius ${pMaxRadius}
                                    /play off
                                    | Tell Kiss we are using MQ2advpath for pulling
                                    /varset PullMoveUse advpath
                                }
                            } else {
                                /echo Path ${PParam${ipa}} not found.
                                /varset PullMoveUse
                                /varset PullPathWpCount 0
                            }
                        }
                    } else {
                        /if (${Int[${PParam${i}}]}==0) {
                            /varset MainAssist ${PParam${i}}
                        } else /if (${Int[${PParam${i}}]} >= 1 && ${Int[${PParam${i}}]} <= 100) {
                            /varset p_AssistAt ${PParam${i}}
                        }
                    }
                }
            }
        /next i
        /if (${iniLoaded}) {
            /if (${Debug}) /echo \atDEBUG PParse Leave Role: ${p_Role} MA: ${MainAssist} AssistAt: ${p_AssistAt} PullPath: ${p_PullPath} Parse: ${ParseDPSTimer}
        } else {
            /if (${Debug}) /echo \atDEBUG PParse Leave IniFile: ${IniFileName} InitAlias: ${ForceAlias}
        }
    /return
| ----------------------------------------------------------------------------
| SUB: Write Buffs
| ----------------------------------------------------------------------------
    Sub WriteBuffs
        /if (${WriteBuffsTimer} || !${Redguides} || ${AggroTargetID} || ${EverQuest.GameState.NotEqual[INGAME]}) /return
        /if (${DanNetOn}) /return
        DEBUGBUFF WriteBuffs Enter
        /declare i int local 0
        /declare k int local 0
        /declare Blockedbuff string local
        /declare Blockedbufflist string local
        /declare BuffList string local
        /declare Writebufflist string local
        | Set block buffs count to 30 on emu servers and 40 on live
        /if (${MacroQuest.Build}==4) {
            /varset BlockedBuffsCount 30
        } else {
            /varset BlockedBuffsCount 40
        }
        /call CleanBuffsFile
        | Write day of the month and hour. Entry will be deleted if more than a hour old
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Day].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Day "${Time.Day}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Hour].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Hour "${Time.Hour}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Zone].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Zone "${Zone.ID}"
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Buffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs
        /if (!${Ini["KissAssist_Buffs.ini",${Me.ID},Blockedbuffs].Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs
        /ini "KissAssist_Buffs.ini" "${Me.ID}" AmILooting ${LootOn}
        /ini "KissAssist_Buffs.ini" "${Me.ID}" MyRole ${Role}
        | Write all current buffs to Kissassist_Buffs.ini file
        /for i 1 to 41
            /varset BuffList ${Me.Buff[${i}].Name}
            /if (${BuffList.Length} && ${BuffList.NotEqual[null]}) {
                DEBUGN WriteBuffs: ${i}-${BuffList}
                /if (${BuffList.Find[:Permanent]}>1) /varset BuffList ${BuffList.Left[${Math.Calc[${BuffList.Find[:Permanent]}-1]}]}
                /varset Writebufflist ${Writebufflist}${BuffList}|
            }
        /next i
        /ini "KissAssist_Buffs.ini" "${Me.ID}" Buffs "${Writebufflist}"
        |/delay 15
        | Write all blocked buffs to Kissassist_Buffs.ini file
        /for k 1 to ${BlockedBuffsCount}
            /varset Blockedbuff ${Me.BlockedBuff[${k}].Name}
            /if (${Blockedbuff.Length} && ${Blockedbuff.NotEqual[null]}) {
                /varset Blockedbufflist ${Blockedbufflist}${Blockedbuff}|
            }
        /next k
        /if (${Blockedbufflist.Length}) /ini "KissAssist_Buffs.ini" "${Me.ID}" Blockedbuffs "${Blockedbufflist}"
        /if (${Window[BlockedBuffWnd].Open}) /windowstate BlockedBuffWnd close
        /varset WriteBuffsTimer 30s
        DEBUGBUFF WriteBuffs Leave
    /return
| ----------------------------------------------------------------------------
| Bind SUB: For my commands to be included in the kissmycmds.inc
| ----------------------------------------------------------------------------
    Sub Bind_MyCmds(myCMD, p_1, p_2, p_3)
        /if (!${SubDefined[mycmds]}) /return false
        /if (!${Bool[${myCMD}]}) /return false
        /if (!${SubDefined[${myCMD}]}) /return false
        /call mycmds "${myCMD}" "${p_1}" "${p_2}" "${p_3}"
    /return ${Macro.Return}
#include_optional kissmycmds.inc
